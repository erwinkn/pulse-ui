---
title: effects
---

<PyAttribute name={"__all__"} type={null} value={"['effects', 'EffectsHookState']"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"EffectsHookState"} href={"/docs/api/pulse/hooks/effects/EffectsHookState"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"_build_effects"} type={"(fns, on_error) -> list[Effect]"}>

<PySourceCode >

```python
def _build_effects(
	fns: tuple[EffectFn, ...],
	on_error: Callable[[Exception], None] | None,
) -> list[Effect]:
	effects: list[Effect] = []
	with Untrack():
		for fn in fns:
			if not callable(fn):
				raise ValueError(
					"Only pass functions or callable objects to `ps.effects`"
				)
			effects.append(
				Effect(fn, name=getattr(fn, "__name__", "effect"), on_error=on_error)
			)
	return effects
```

</PySourceCode>

<div >

<PyParameter name={"fns"} type={"tuple[EffectFn, ...]"} value={null} />
<PyParameter name={"on_error"} type={"Callable[[Exception], None] | None"} value={null} />

</div>

<PyFunctionReturn type={"list[pulse.reactive.Effect]"} />

</PyFunction>
<PyFunction name={"_effects_factory"} type={"(*_) -> HookState"}>

<PySourceCode >

```python
def _effects_factory(*_: object) -> HookState:
	return EffectsHookState()
```

</PySourceCode>

<div >

<PyParameter name={"_"} type={"object"} value={"()"} />

</div>

<PyFunctionReturn type={"pulse.hooks.core.HookState"} />

</PyFunction>
<PyFunction name={"effects"} type={"(*fns, /, *, on_error=None, key=None) -> None"}>

Register effects that persist across renders.

Effects are reactive functions that automatically re-run when their
dependencies change. They are disposed when the component unmounts
or when the key changes.

Example:

```python
def user_profile(user_id: str):
    s = ps.state("user", lambda: UserState(user_id))

    ps.effects(
        lambda: print(f"User changed: \{s.name\}"),
        lambda: subscribe_to_updates(s.user_id),
        key=user_id,  # Recreate effects when user_id changes
    )

    return m.Text(s.name)
```

<Callout title={"Notes"} type={"notes"}>

- Can only be called once per component render
- Effects are disposed when component unmounts
- Changing ``key`` disposes old effects and creates new ones

</Callout>

<PySourceCode >

```python
def effects(
	*fns: EffectFn,
	on_error: Callable[[Exception], None] | None = None,
	key: str | None = None,
) -> None:
	"""Register effects that persist across renders.

	Effects are reactive functions that automatically re-run when their
	dependencies change. They are disposed when the component unmounts
	or when the key changes.

	Args:
		*fns: Effect functions to register. Each function will be wrapped
			in a reactive Effect that tracks its dependencies.
		on_error: Optional error handler called if an effect throws an exception.
		key: Optional key; if changed between renders, existing effects are
			disposed and new ones are created.

	Raises:
		RuntimeError: If called more than once per component render.
		ValueError: If any of the provided functions is not callable.

	Example:

	\```python
	def user_profile(user_id: str):
	    s = ps.state("user", lambda: UserState(user_id))

	    ps.effects(
	        lambda: print(f"User changed: {s.name}"),
	        lambda: subscribe_to_updates(s.user_id),
	        key=user_id,  # Recreate effects when user_id changes
	    )

	    return m.Text(s.name)
	\```

	Notes:
		- Can only be called once per component render
		- Effects are disposed when component unmounts
		- Changing ``key`` disposes old effects and creates new ones
	"""
	state = cast(EffectsHookState, _effects_hook())
	state.ensure_not_called()

	if not state.initialized:
		state.replace(_build_effects(fns, on_error), key)
		state.mark_called()
		return

	if key is not None and key != state.key:
		state.replace(_build_effects(fns, on_error), key)
		state.mark_called()
		return

	state.mark_called()
```

</PySourceCode>

<div >

<PyParameter name={"fns"} type={"EffectFn"} value={"()"} />
<PyParameter name={"on_error"} type={"Callable[[Exception], None] | None"} value={"None"}>

Optional error handler called if an effect throws an exception.

</PyParameter>
<PyParameter name={"key"} type={"str | None"} value={"None"}>

Optional key; if changed between renders, existing effects are
disposed and new ones are created.

</PyParameter>

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

</Tab>

</Tabs>