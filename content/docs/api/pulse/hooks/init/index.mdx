---
title: init
---

<PyAttribute name={"PyFrame_LocalsToFast"} type={null} value={"ctypes.pythonapi.PyFrame_LocalsToFast"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"InitContext"} href={"/docs/api/pulse/hooks/init/InitContext"} />
<Card title={"InitCPythonRewriter"} href={"/docs/api/pulse/hooks/init/InitCPythonRewriter"} />
<Card title={"InitFallbackRewriter"} href={"/docs/api/pulse/hooks/init/InitFallbackRewriter"} />
<Card title={"_InitCallChecker"} href={"/docs/api/pulse/hooks/init/_InitCallChecker"} />
<Card title={"InitState"} href={"/docs/api/pulse/hooks/init/InitState"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"previous_frame"} type={"() -> types.FrameType"}>

Get the previous frame (caller's frame) with assertions.

This skips the frame of this helper function and its immediate caller
to return the actual previous frame.

<PySourceCode >

```python
def previous_frame() -> types.FrameType:
	"""Get the previous frame (caller's frame) with assertions.

	This skips the frame of this helper function and its immediate caller
	to return the actual previous frame.
	"""
	current = inspect.currentframe()
	assert current is not None, "currentframe() returned None"
	# Skip this helper function's frame
	caller = current.f_back
	assert caller is not None, "f_back is None"
	# Skip the caller's frame (e.g., __enter__) to get the actual previous frame
	frame = caller.f_back
	assert frame is not None, "f_back.f_back is None"
	return frame
```

</PySourceCode>

<PyFunctionReturn type={"types.types.FrameType"} />

</PyFunction>
<PyFunction name={"init"} type={"() -> InitContext"}>

Context manager for one-time initialization in components.

Variables assigned inside the block persist across re-renders. Uses AST
rewriting to transform the code at decoration time.

Example:

```python
def my_component():
    with ps.init():
        counter = 0
        api = ApiClient()
        data = fetch_initial_data()
    # counter, api, data retain their values across renders
    return m.Text(f"Counter: \{counter\}")
```

<Callout title={"Rules"} type={"rules"}>

- Can only be used once per component
- Must be at the top level of the component function (not inside
  conditionals, loops, or nested functions)
- Cannot contain control flow (if, for, while, try, with, match)
- Cannot use ``as`` binding (``with ps.init() as ctx:`` not allowed)
- Variables are restored from first render on subsequent renders

</Callout>

<Callout title={"Notes"} type={"notes"}>

If you encounter issues with ``ps.init()`` (e.g., source code not
available in some deployment environments), use ``ps.setup()`` instead.
It provides the same functionality without AST rewriting.

</Callout>

<PySourceCode >

```python
def init() -> InitContext:
	"""Context manager for one-time initialization in components.

	Variables assigned inside the block persist across re-renders. Uses AST
	rewriting to transform the code at decoration time.

	Returns:
		InitContext: Context manager that captures and restores variables.

	Example:

	\```python
	def my_component():
	    with ps.init():
	        counter = 0
	        api = ApiClient()
	        data = fetch_initial_data()
	    # counter, api, data retain their values across renders
	    return m.Text(f"Counter: {counter}")
	\```

	Rules:
		- Can only be used once per component
		- Must be at the top level of the component function (not inside
		  conditionals, loops, or nested functions)
		- Cannot contain control flow (if, for, while, try, with, match)
		- Cannot use ``as`` binding (``with ps.init() as ctx:`` not allowed)
		- Variables are restored from first render on subsequent renders

	Notes:
		If you encounter issues with ``ps.init()`` (e.g., source code not
		available in some deployment environments), use ``ps.setup()`` instead.
		It provides the same functionality without AST rewriting.
	"""
	return InitContext()
```

</PySourceCode>

<PyFunctionReturn type={"pulse.hooks.init.InitContext"}>

Context manager that captures and restores variables.

</PyFunctionReturn>

</PyFunction>
<PyFunction name={"_collect_assigned_names"} type={"(body) -> list[str]"}>

<PySourceCode >

```python
def _collect_assigned_names(body: list[ast.stmt]) -> list[str]:
	names: set[str] = set()

	def add_target(target: ast.AST):
		if isinstance(target, ast.Name):
			names.add(target.id)
		elif isinstance(target, (ast.Tuple, ast.List)):
			for elt in target.elts:
				add_target(elt)

	for stmt in body:
		if isinstance(stmt, ast.Assign):
			for target in stmt.targets:
				add_target(target)
		elif isinstance(stmt, ast.AnnAssign) and isinstance(stmt.target, ast.Name):
			names.add(stmt.target.id)
		elif isinstance(stmt, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
			names.add(stmt.name)
	return list(names)
```

</PySourceCode>

<div >

<PyParameter name={"body"} type={"list[ast.stmt]"} value={null} />

</div>

<PyFunctionReturn type={"list[str]"} />

</PyFunction>
<PyFunction name={"rewrite_init_blocks"} type={"(func) -> Callable[..., Any]"}>

Rewrite `with ps.init()` blocks in the provided function, if present.

<PySourceCode >

```python
def rewrite_init_blocks(func: Callable[..., Any]) -> Callable[..., Any]:
	"""Rewrite `with ps.init()` blocks in the provided function, if present."""

	source = textwrap.dedent(getsourcecode(func))  # raises immediately if missing
	try:
		source_start_line = inspect.getsourcelines(func)[1]
	except (OSError, TypeError):
		source_start_line = None

	if "init" not in source:  # quick prefilter, allow alias detection later
		return func

	tree = ast.parse(source)

	init_names, init_modules = _resolve_init_bindings(func)

	target_def: ast.FunctionDef | ast.AsyncFunctionDef | None = None
	# Remove decorators so the re-exec'd function isn't double-wrapped.
	for node in ast.walk(tree):
		if (
			isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef))
			and node.name == func.__name__
		):
			node.decorator_list = []
			target_def = node

	if target_def is None:
		return func

	if not _contains_ps_init(tree, init_names, init_modules):
		return func

	init_items = _find_init_items(target_def.body, init_names, init_modules)
	if len(init_items) > 1:
		try:
			filename = inspect.getsourcefile(func) or inspect.getfile(func)
		except (TypeError, OSError):
			filename = None
		raise TranspileError(
			"ps.init may only be used once per component render",
			node=init_items[1].context_expr,
			source=source,
			filename=filename,
			func_name=func.__name__,
			source_start_line=source_start_line,
		) from None

	if init_items and init_items[0].optional_vars is not None:
		try:
			filename = inspect.getsourcefile(func) or inspect.getfile(func)
		except (TypeError, OSError):
			filename = None
		raise TranspileError(
			"ps.init does not support 'as' bindings",
			node=init_items[0].optional_vars,
			source=source,
			filename=filename,
			func_name=func.__name__,
			source_start_line=source_start_line,
		) from None

	disallowed = _find_disallowed_control_flow(
		target_def.body, init_names, init_modules
	)
	if disallowed is not None:
		try:
			filename = inspect.getsourcefile(func) or inspect.getfile(func)
		except (TypeError, OSError):
			filename = None
		raise TranspileError(
			"ps.init blocks cannot contain control flow (if/for/while/try/with/match)",
			node=disallowed,
			source=source,
			filename=filename,
			func_name=func.__name__,
			source_start_line=source_start_line,
		) from None

	rewriter: ast.NodeTransformer
	if _CAN_USE_CPYTHON:
		rewriter = InitCPythonRewriter(init_names, init_modules)
	else:
		rewriter = InitFallbackRewriter(init_names, init_modules)

	tree = rewriter.visit(tree)
	ast.fix_missing_locations(tree)

	filename = inspect.getsourcefile(func) or "<rewrite>"
	compiled = compile(tree, filename=filename, mode="exec")

	global_ns = dict(func.__globals__)
	closure_vars = inspect.getclosurevars(func)
	global_ns.update(closure_vars.nonlocals)
	# Ensure `ps` resolves during exec.
	if "ps" not in global_ns:
		try:
			import pulse as ps

			global_ns["ps"] = ps
		except Exception:
			pass
	local_ns: dict[str, Any] = {}
	exec(compiled, global_ns, local_ns)
	rewritten = local_ns.get(func.__name__) or global_ns[func.__name__]
	functools.update_wrapper(rewritten, func)
	return rewritten
```

</PySourceCode>

<div >

<PyParameter name={"func"} type={"Callable[..., Any]"} value={null} />

</div>

<PyFunctionReturn type={"collections.abc.Callable[..., typing.Any]"} />

</PyFunction>
<PyFunction name={"_contains_ps_init"} type={"(tree, init_names, init_modules) -> bool"}>

<PySourceCode >

```python
def _contains_ps_init(
	tree: ast.AST, init_names: set[str], init_modules: set[str]
) -> bool:
	checker = _InitCallChecker(init_names, init_modules)
	return checker.contains_init(tree)
```

</PySourceCode>

<div >

<PyParameter name={"tree"} type={"ast.AST"} value={null} />
<PyParameter name={"init_names"} type={"set[str]"} value={null} />
<PyParameter name={"init_modules"} type={"set[str]"} value={null} />

</div>

<PyFunctionReturn type={"bool"} />

</PyFunction>
<PyFunction name={"_find_disallowed_control_flow"} type={"(body, init_names, init_modules) -> ast.stmt | None"}>

<PySourceCode >

```python
def _find_disallowed_control_flow(
	body: Sequence[ast.stmt], init_names: set[str], init_modules: set[str]
) -> ast.stmt | None:
	disallowed: tuple[type[ast.AST], ...] = (
		ast.If,
		ast.For,
		ast.AsyncFor,
		ast.While,
		ast.Try,
		ast.With,
		ast.AsyncWith,
		ast.Match,
	)
	checker = _InitCallChecker(init_names, init_modules)

	class _Finder(ast.NodeVisitor):
		found: ast.stmt | None

		def __init__(self) -> None:
			self.found = None

		@override
		def visit(self, node: ast.AST) -> Any:  # type: ignore[override]
			if self.found is not None:
				return None
			if isinstance(node, disallowed):
				self.found = cast(ast.stmt, node)
				return None
			return super().visit(node)

		@override
		def visit_FunctionDef(self, node: ast.FunctionDef) -> Any:
			return None

		@override
		def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Any:
			return None

		@override
		def visit_ClassDef(self, node: ast.ClassDef) -> Any:
			return None

	finder = _Finder()

	class _WithFinder(ast.NodeVisitor):
		@override
		def visit_With(self, node: ast.With) -> Any:  # type: ignore[override]
			first = node.items[0] if node.items else None
			if first and checker.is_init_call(first.context_expr):
				for stmt in node.body:
					finder.visit(stmt)
					if finder.found is not None:
						return None
			self.generic_visit(node)

		@override
		def visit_AsyncWith(self, node: ast.AsyncWith) -> Any:  # type: ignore[override]
			first = node.items[0] if node.items else None
			if first and checker.is_init_call(first.context_expr):
				for stmt in node.body:
					finder.visit(stmt)
					if finder.found is not None:
						return None
			self.generic_visit(node)

		@override
		def visit_FunctionDef(self, node: ast.FunctionDef) -> Any:
			return None

		@override
		def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Any:
			return None

		@override
		def visit_ClassDef(self, node: ast.ClassDef) -> Any:
			return None

	with_finder = _WithFinder()
	for stmt in body:
		with_finder.visit(stmt)
		if finder.found is not None:
			return finder.found
	return None
```

</PySourceCode>

<div >

<PyParameter name={"body"} type={"Sequence[ast.stmt]"} value={null} />
<PyParameter name={"init_names"} type={"set[str]"} value={null} />
<PyParameter name={"init_modules"} type={"set[str]"} value={null} />

</div>

<PyFunctionReturn type={"ast.ast.stmt | None"} />

</PyFunction>
<PyFunction name={"_find_init_items"} type={"(body, init_names, init_modules) -> list[ast.withitem]"}>

<PySourceCode >

```python
def _find_init_items(
	body: Sequence[ast.stmt], init_names: set[str], init_modules: set[str]
) -> list[ast.withitem]:
	checker = _InitCallChecker(init_names, init_modules)
	items: list[ast.withitem] = []

	class _Finder(ast.NodeVisitor):
		@override
		def visit_With(self, node: ast.With) -> Any:  # type: ignore[override]
			first = node.items[0] if node.items else None
			if first and checker.is_init_call(first.context_expr):
				items.append(first)
			self.generic_visit(node)

		@override
		def visit_AsyncWith(self, node: ast.AsyncWith) -> Any:  # type: ignore[override]
			first = node.items[0] if node.items else None
			if first and checker.is_init_call(first.context_expr):
				items.append(first)
			self.generic_visit(node)

		@override
		def visit_FunctionDef(self, node: ast.FunctionDef) -> Any:
			return None

		@override
		def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Any:
			return None

		@override
		def visit_ClassDef(self, node: ast.ClassDef) -> Any:
			return None

	finder = _Finder()
	for stmt in body:
		finder.visit(stmt)
	return items
```

</PySourceCode>

<div >

<PyParameter name={"body"} type={"Sequence[ast.stmt]"} value={null} />
<PyParameter name={"init_names"} type={"set[str]"} value={null} />
<PyParameter name={"init_modules"} type={"set[str]"} value={null} />

</div>

<PyFunctionReturn type={"list[ast.ast.withitem]"} />

</PyFunction>
<PyFunction name={"_resolve_init_bindings"} type={"(func) -> tuple[set[str], set[str]]"}>

Find names/modules that resolve to pulse.init in the function scope.

<PySourceCode >

```python
def _resolve_init_bindings(func: Callable[..., Any]) -> tuple[set[str], set[str]]:
	"""Find names/modules that resolve to pulse.init in the function scope."""

	init_names: set[str] = set()
	init_modules: set[str] = set()

	closure = inspect.getclosurevars(func)
	scopes = [func.__globals__, closure.nonlocals, closure.globals]

	for scope in scopes:
		for name, val in scope.items():
			if val is init:
				init_names.add(name)
			try:
				if getattr(val, "init", None) is init:
					init_modules.add(name)
			except Exception:
				continue

	return init_names, init_modules
```

</PySourceCode>

<div >

<PyParameter name={"func"} type={"Callable[..., Any]"} value={null} />

</div>

<PyFunctionReturn type={"tuple[set[str], set[str]]"} />

</PyFunction>

</Tab>

</Tabs>