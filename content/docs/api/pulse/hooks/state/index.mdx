---
title: state
---

<PyAttribute name={"S"} type={null} value={"TypeVar('S', bound=State)"} />

<PyAttribute name={"__all__"} type={null} value={"['state', 'StateHookState']"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"StateHookState"} href={"/docs/api/pulse/hooks/state/StateHookState"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"_instantiate_state"} type={"(arg) -> State"}>

<PySourceCode >

```python
def _instantiate_state(arg: State | Callable[[], State]) -> State:
	instance = arg() if callable(arg) else arg
	if not isinstance(instance, State):
		raise TypeError(
			"`pulse.state` expects a State instance or a callable returning a State instance"
		)
	return instance
```

</PySourceCode>

<div >

<PyParameter name={"arg"} type={"State | Callable[[], State]"} value={null} />

</div>

<PyFunctionReturn type={"pulse.state.State"} />

</PyFunction>
<PyFunction name={"_state_factory"} type={"()"}>

<PySourceCode >

```python
def _state_factory():
	return StateHookState()
```

</PySourceCode>

<PyFunctionReturn type={null} />

</PyFunction>
<PyFunction name={"state"} type={"(key, arg) -> S"}>

Get or create a State instance persisted across renders.

Example:

```python
def counter():
    s = ps.state("counter", lambda: CounterState())
    return m.Button(f"Count: \{s.count\}", on_click=lambda: s.increment())
```

<Callout title={"Notes"} type={"notes"}>

- Key must be non-empty string
- Can only be called once per render with the same key
- Factory is only called on first render; subsequent renders return cached instance
- State is disposed when component unmounts

</Callout>

<PySourceCode >

```python
def state(key: str, arg: S | Callable[[], S]) -> S:
	"""Get or create a State instance persisted across renders.

	Args:
		key: Unique identifier within the component. Must be a non-empty string.
		arg: State instance or factory function that returns a State instance.
			The factory is only called on first render; subsequent renders
			return the cached instance.

	Returns:
		The same State instance on subsequent renders with the same key.

	Raises:
		ValueError: If key is empty.
		RuntimeError: If called more than once per render with the same key.
		TypeError: If arg is not a State or callable returning a State.

	Example:

	\```python
	def counter():
	    s = ps.state("counter", lambda: CounterState())
	    return m.Button(f"Count: {s.count}", on_click=lambda: s.increment())
	\```

	Notes:
		- Key must be non-empty string
		- Can only be called once per render with the same key
		- Factory is only called on first render; subsequent renders return cached instance
		- State is disposed when component unmounts
	"""
	if not key:
		raise ValueError("state() requires a non-empty string key")
	hook_state = _state_hook()
	return hook_state.get_or_create_state(key, arg)  # pyright: ignore[reportReturnType]
```

</PySourceCode>

<div >

<PyParameter name={"key"} type={"str"} value={undefined}>

Unique identifier within the component. Must be a non-empty string.

</PyParameter>
<PyParameter name={"arg"} type={"S | Callable[[], S]"} value={undefined}>

State instance or factory function that returns a State instance.
The factory is only called on first render; subsequent renders
return the cached instance.

</PyParameter>

</div>

<PyFunctionReturn type={"pulse.hooks.state.S"}>

The same State instance on subsequent renders with the same key.

</PyFunctionReturn>

</PyFunction>

</Tab>

</Tabs>