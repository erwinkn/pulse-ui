---
title: InfiniteQuery
---

Paginated query that stores data as a list of Page(data, param).

## Attributes

<PyAttribute name={"key"} type={"QueryKey"} value={"key"} />

<PyAttribute name={"cfg"} type={"InfiniteQueryConfig[T, TParam]"} value={"InfiniteQueryConfig(retries=retries, retry_delay=retry_delay, initial_data=initial_data, initial_data_updated_at=initial_data_updated_at, gc_time=gc_time, on_dispose=on_dispose, initial_page_param=initial_page_param, get_next_page_param=get_next_page_param, get_previous_page_param=get_previous_page_param, max_pages=max_pages)"} />

<PyAttribute name={"fn"} type={"Callable[[TParam], Awaitable[T]]"} value={null}>

Get the fetch function from the first observer.

</PyAttribute>

<PyAttribute name={"pages"} type={"ReactiveList[Page[T, TParam]]"} value={"ReactiveList(initial_pages)"} />

<PyAttribute name={"error"} type={"Signal[Exception | None]"} value={"Signal(None, name=f'inf_query.error({key})')"} />

<PyAttribute name={"last_updated"} type={"Signal[float]"} value={"Signal(0.0, name=f'inf_query.last_updated({key})')"} />

<PyAttribute name={"status"} type={"Signal[QueryStatus]"} value={"Signal('loading' if len(initial_pages) == 0 else 'success', name=f'inf_query.status({key})')"} />

<PyAttribute name={"is_fetching"} type={"Signal[bool]"} value={"Signal(False, name=f'inf_query.is_fetching({key})')"} />

<PyAttribute name={"retries"} type={"Signal[int]"} value={"Signal(0, name=f'inf_query.retries({key})')"} />

<PyAttribute name={"retry_reason"} type={"Signal[Exception | None]"} value={"Signal(None, name=f'inf_query.retry_reason({key})')"} />

<PyAttribute name={"has_next_page"} type={"Signal[bool]"} value={"Signal(False, name=f'inf_query.has_next({key})')"} />

<PyAttribute name={"has_previous_page"} type={"Signal[bool]"} value={"Signal(False, name=f'inf_query.has_prev({key})')"} />

<PyAttribute name={"current_action"} type={"Signal[Action[T, TParam] | None]"} value={"Signal(None, name=f'inf_query.current_action({key})')"} />

## Functions

<PyFunction name={"__init__"} type={"(self, key, *, initial_page_param, get_next_page_param, get_previous_page_param=None, max_pages=0, retries=3, retry_delay=RETRY_DELAY_DEFAULT, initial_data=MISSING, initial_data_updated_at=None, gc_time=300.0, on_dispose=None)"}>

<PySourceCode >

```python
def __init__(
	self,
	key: QueryKey,
	*,
	initial_page_param: TParam,
	get_next_page_param: Callable[[list[Page[T, TParam]]], TParam | None],
	get_previous_page_param: (
		Callable[[list[Page[T, TParam]]], TParam | None] | None
	) = None,
	max_pages: int = 0,
	retries: int = 3,
	retry_delay: float = RETRY_DELAY_DEFAULT,
	initial_data: list[Page[T, TParam]] | None | Any = MISSING,
	initial_data_updated_at: float | dt.datetime | None = None,
	gc_time: float = 300.0,
	on_dispose: Callable[[Any], None] | None = None,
):
	self.key = key

	self.cfg = InfiniteQueryConfig(
		retries=retries,
		retry_delay=retry_delay,
		initial_data=initial_data,
		initial_data_updated_at=initial_data_updated_at,
		gc_time=gc_time,
		on_dispose=on_dispose,
		initial_page_param=initial_page_param,
		get_next_page_param=get_next_page_param,
		get_previous_page_param=get_previous_page_param,
		max_pages=max_pages,
	)

	initial_pages: list[Page[T, TParam]]
	if initial_data is MISSING:
		initial_pages = []
	else:
		initial_pages = cast(list[Page[T, TParam]], initial_data) or []

	self.pages = ReactiveList(initial_pages)
	self.error = Signal(None, name=f"inf_query.error({key})")
	self.last_updated = Signal(0.0, name=f"inf_query.last_updated({key})")
	if initial_data_updated_at:
		self.set_updated_at(initial_data_updated_at)

	self.status = Signal(
		"loading" if len(initial_pages) == 0 else "success",
		name=f"inf_query.status({key})",
	)
	self.is_fetching = Signal(False, name=f"inf_query.is_fetching({key})")
	self.retries = Signal(0, name=f"inf_query.retries({key})")
	self.retry_reason = Signal(None, name=f"inf_query.retry_reason({key})")

	self.has_next_page = Signal(False, name=f"inf_query.has_next({key})")
	self.has_previous_page = Signal(False, name=f"inf_query.has_prev({key})")
	self.current_action = Signal(None, name=f"inf_query.current_action({key})")

	self._queue = deque()
	self._queue_task = None
	self._observers = []
	self._gc_handle = None
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"key"} type={"QueryKey"} value={null} />
<PyParameter name={"initial_page_param"} type={"TParam"} value={null} />
<PyParameter name={"get_next_page_param"} type={"Callable[[list[Page[T, TParam]]], TParam | None]"} value={null} />
<PyParameter name={"get_previous_page_param"} type={"Callable[[list[Page[T, TParam]]], TParam | None] | None"} value={"None"} />
<PyParameter name={"max_pages"} type={"int"} value={"0"} />
<PyParameter name={"retries"} type={"int"} value={"3"} />
<PyParameter name={"retry_delay"} type={"float"} value={"RETRY_DELAY_DEFAULT"} />
<PyParameter name={"initial_data"} type={"list[Page[T, TParam]] | None | Any"} value={"MISSING"} />
<PyParameter name={"initial_data_updated_at"} type={"float | dt.datetime | None"} value={"None"} />
<PyParameter name={"gc_time"} type={"float"} value={"300.0"} />
<PyParameter name={"on_dispose"} type={"Callable[[Any], None] | None"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"commit"} type={"(self)"}>

Commit current pages state and run success callbacks.

<PySourceCode >

```python
async def commit(self):
	"""Commit current pages state and run success callbacks."""
	self._commit_sync()

	for obs in self._observers:
		if obs._on_success is not None:  # pyright: ignore[reportPrivateUsage]
			await maybe_await(call_flexible(obs._on_success, self.pages))  # pyright: ignore[reportPrivateUsage]
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_commit_error"} type={"(self, error)"}>

Commit error state and run error callbacks.

<PySourceCode >

```python
async def _commit_error(self, error: Exception):
	"""Commit error state and run error callbacks."""
	self._commit_error_sync(error)

	for obs in self._observers:
		if obs._on_error is not None:  # pyright: ignore[reportPrivateUsage]
			await maybe_await(call_flexible(obs._on_error, error))  # pyright: ignore[reportPrivateUsage]
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"error"} type={"Exception"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_commit_sync"} type={"(self)"}>

Synchronous commit - updates state based on current pages.

<PySourceCode >

```python
def _commit_sync(self):
	"""Synchronous commit - updates state based on current pages."""
	self._update_has_more()
	self.last_updated.write(time.time())
	self.error.write(None)
	self.status.write("success")
	self.retries.write(0)
	self.retry_reason.write(None)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_commit_error_sync"} type={"(self, error)"}>

Synchronous error commit for set_error (no callbacks).

<PySourceCode >

```python
def _commit_error_sync(self, error: Exception):
	"""Synchronous error commit for set_error (no callbacks)."""
	self.error.write(error)
	self.last_updated.write(time.time())
	self.status.write("error")
	self.is_fetching.write(False)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"error"} type={"Exception"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_record_retry"} type={"(self, reason)"}>

Record a failed retry attempt.

<PySourceCode >

```python
def _record_retry(self, reason: Exception):
	"""Record a failed retry attempt."""
	self.retries.write(self.retries.read() + 1)
	self.retry_reason.write(reason)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"reason"} type={"Exception"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_reset_retries"} type={"(self)"}>

Reset retry state at start of operation.

<PySourceCode >

```python
def _reset_retries(self):
	"""Reset retry state at start of operation."""
	self.retries.write(0)
	self.retry_reason.write(None)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"set_updated_at"} type={"(self, updated_at)"}>

<PySourceCode >

```python
def set_updated_at(self, updated_at: float | dt.datetime):
	if isinstance(updated_at, dt.datetime):
		updated_at = updated_at.timestamp()
	self.last_updated.write(updated_at)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"updated_at"} type={"float | dt.datetime"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"set_initial_data"} type={"(self, pages, updated_at=None)"}>

Set initial pages while the query is still loading.

<PySourceCode >

```python
def set_initial_data(
	self,
	pages: list[Page[T, TParam]] | Callable[[], list[Page[T, TParam]]],
	updated_at: float | dt.datetime | None = None,
):
	"""Set initial pages while the query is still loading."""
	if self.status() != "loading":
		return
	value = pages() if callable(pages) else pages
	self.set_data(value, updated_at=updated_at)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"pages"} type={"list[Page[T, TParam]] | Callable[[], list[Page[T, TParam]]]"} value={null} />
<PyParameter name={"updated_at"} type={"float | dt.datetime | None"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"set_data"} type={"(self, pages, updated_at=None)"}>

Set pages manually, keeping has_next/prev in sync.

<PySourceCode >

```python
def set_data(
	self,
	pages: list[Page[T, TParam]]
	| Callable[[list[Page[T, TParam]]], list[Page[T, TParam]]],
	updated_at: float | dt.datetime | None = None,
):
	"""Set pages manually, keeping has_next/prev in sync."""
	new_pages = pages(self.pages) if callable(pages) else pages
	self.pages.clear()
	self.pages.extend(new_pages)
	self._trim_back()
	self._commit_sync()
	if updated_at is not None:
		self.set_updated_at(updated_at)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"pages"} type={"list[Page[T, TParam]] | Callable[[list[Page[T, TParam]]], list[Page[T, TParam]]]"} value={null} />
<PyParameter name={"updated_at"} type={"float | dt.datetime | None"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"set_error"} type={"(self, error, *, updated_at=None)"}>

<PySourceCode >

```python
def set_error(
	self, error: Exception, *, updated_at: float | dt.datetime | None = None
):
	self._commit_error_sync(error)
	if updated_at is not None:
		self.set_updated_at(updated_at)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"error"} type={"Exception"} value={null} />
<PyParameter name={"updated_at"} type={"float | dt.datetime | None"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"wait"} type={"(self, fetch_fn=None, observer=None) -> ActionResult[list[Page[T, TParam]]]"}>

Wait for initial data or until queue is empty.

<PySourceCode >

```python
async def wait(
	self,
	fetch_fn: Callable[[TParam], Awaitable[T]] | None = None,
	observer: "InfiniteQueryResult[T, TParam] | None" = None,
) -> ActionResult[list[Page[T, TParam]]]:
	"""Wait for initial data or until queue is empty."""
	# If no data and loading, enqueue initial fetch (unless already processing)
	if len(self.pages) == 0 and self.status() == "loading":
		if self._queue_task is None or self._queue_task.done():
			# Use provided fetch_fn or fall back to first observer's fetch_fn
			fn = fetch_fn if fetch_fn is not None else self.fn
			self._enqueue(Refetch(fetch_fn=fn, observer=observer))
	# Wait for any in-progress queue processing
	if self._queue_task and not self._queue_task.done():
		await self._queue_task
	# Return result based on current state
	if self.status() == "error":
		return ActionError(cast(Exception, self.error()))
	return ActionSuccess(list(self.pages))
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fetch_fn"} type={"Callable[[TParam], Awaitable[T]] | None"} value={"None"} />
<PyParameter name={"observer"} type={"InfiniteQueryResult[T, TParam] | None"} value={"None"} />

</div>

<PyFunctionReturn type={"pulse.queries.common.ActionResult[list[pulse.queries.infinite_query.Page[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam]]]"} />

</PyFunction>

<PyFunction name={"observe"} type={"(self, observer)"}>

<PySourceCode >

```python
def observe(self, observer: Any):
	self._observers.append(observer)
	self.cancel_gc()
	gc_time = getattr(observer, "_gc_time", 0)
	if gc_time and gc_time > 0:
		self.cfg.gc_time = max(self.cfg.gc_time, gc_time)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"observer"} type={"Any"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"unobserve"} type={"(self, observer)"}>

Unregister an observer. Cancels pending actions. Schedules GC if no observers remain.

<PySourceCode >

```python
def unobserve(self, observer: "InfiniteQueryResult[T, TParam]"):
	"""Unregister an observer. Cancels pending actions. Schedules GC if no observers remain."""
	if observer in self._observers:
		self._observers.remove(observer)

	# Cancel pending actions from this observer
	self._cancel_observer_actions(observer)

	if len(self._observers) == 0:
		self.schedule_gc()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"observer"} type={"InfiniteQueryResult[T, TParam]"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"invalidate"} type={"(self, *, cancel_fetch=False, refetch_page=None, fetch_fn=None, observer=None)"}>

Enqueue a refetch. Synchronous - does not wait for completion.

<PySourceCode >

```python
def invalidate(
	self,
	*,
	cancel_fetch: bool = False,
	refetch_page: Callable[[T, int, list[T]], bool] | None = None,
	fetch_fn: Callable[[TParam], Awaitable[T]] | None = None,
	observer: "InfiniteQueryResult[T, TParam] | None" = None,
):
	"""Enqueue a refetch. Synchronous - does not wait for completion."""
	if cancel_fetch:
		self._cancel_queue()
	if len(self._observers) > 0:
		# Use provided fetch_fn or fall back to first observer's fetch_fn
		fn = fetch_fn if fetch_fn is not None else self.fn
		self._enqueue(
			Refetch(fetch_fn=fn, observer=observer, refetch_page=refetch_page)
		)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"cancel_fetch"} type={"bool"} value={"False"} />
<PyParameter name={"refetch_page"} type={"Callable[[T, int, list[T]], bool] | None"} value={"None"} />
<PyParameter name={"fetch_fn"} type={"Callable[[TParam], Awaitable[T]] | None"} value={"None"} />
<PyParameter name={"observer"} type={"InfiniteQueryResult[T, TParam] | None"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"schedule_gc"} type={"(self)"}>

<PySourceCode >

```python
def schedule_gc(self):
	self.cancel_gc()
	if self.cfg.gc_time > 0:
		self._gc_handle = later(self.cfg.gc_time, self.dispose)
	else:
		self.dispose()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"cancel_gc"} type={"(self)"}>

<PySourceCode >

```python
def cancel_gc(self):
	if self._gc_handle:
		self._gc_handle.cancel()
		self._gc_handle = None
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"compute_next_param"} type={"(self) -> TParam | None"}>

<PySourceCode >

```python
def compute_next_param(self) -> TParam | None:
	if len(self.pages) == 0:
		return self.cfg.initial_page_param
	return self.cfg.get_next_page_param(self.pages)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"pulse.queries.infinite_query.TParam | None"} />

</PyFunction>

<PyFunction name={"compute_previous_param"} type={"(self) -> TParam | None"}>

<PySourceCode >

```python
def compute_previous_param(self) -> TParam | None:
	if self.cfg.get_previous_page_param is None:
		return None
	if len(self.pages) == 0:
		return None
	return self.cfg.get_previous_page_param(self.pages)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"pulse.queries.infinite_query.TParam | None"} />

</PyFunction>

<PyFunction name={"_update_has_more"} type={"(self)"}>

<PySourceCode >

```python
def _update_has_more(self):
	if len(self.pages) == 0:
		self.has_next_page.write(False)
		self.has_previous_page.write(self.cfg.get_previous_page_param is not None)
		return
	next_param = self.cfg.get_next_page_param(self.pages)
	prev_param = None
	if self.cfg.get_previous_page_param:
		prev_param = self.cfg.get_previous_page_param(self.pages)
	self.has_next_page.write(next_param is not None)
	self.has_previous_page.write(prev_param is not None)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_trim_front"} type={"(self)"}>

Trim pages from front when over max_pages.

<PySourceCode >

```python
def _trim_front(self):
	"""Trim pages from front when over max_pages."""
	if self.cfg.max_pages and self.cfg.max_pages > 0:
		while len(self.pages) > self.cfg.max_pages:
			self.pages.pop(0)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_trim_back"} type={"(self)"}>

Trim pages from back when over max_pages.

<PySourceCode >

```python
def _trim_back(self):
	"""Trim pages from back when over max_pages."""
	if self.cfg.max_pages and self.cfg.max_pages > 0:
		while len(self.pages) > self.cfg.max_pages:
			self.pages.pop()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_cancel_queue"} type={"(self)"}>

Cancel all pending and in-flight actions.

<PySourceCode >

```python
def _cancel_queue(self):
	"""Cancel all pending and in-flight actions."""
	# Cancel pending actions in the queue
	while self._queue:
		action = self._queue.popleft()
		if not action.future.done():
			action.future.cancel()

	# Cancel the currently executing action and task
	current = self.current_action.read()
	if current is not None and not current.future.done():
		current.future.cancel()

	if self._queue_task and not self._queue_task.done():
		self._queue_task.cancel()
		self._queue_task = None
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_cancel_observer_actions"} type={"(self, observer) -> None"}>

Cancel pending actions from a specific observer.

Note: Does not cancel the currently executing action to avoid disrupting the
queue processor. The fetch will complete but results will be ignored since
the observer is disposed.

<PySourceCode >

```python
def _cancel_observer_actions(
	self, observer: "InfiniteQueryResult[T, TParam]"
) -> None:
	"""Cancel pending actions from a specific observer.

	Note: Does not cancel the currently executing action to avoid disrupting the
	queue processor. The fetch will complete but results will be ignored since
	the observer is disposed.
	"""
	# Cancel pending actions from this observer (not the currently executing one)
	remaining: deque[Action[T, TParam]] = deque()
	while self._queue:
		action = self._queue.popleft()
		if action.observer is observer:
			if not action.future.done():
				action.future.cancel()
		else:
			remaining.append(action)
	self._queue = remaining
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"observer"} type={"InfiniteQueryResult[T, TParam]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"_enqueue"} type={"(self, action, *, cancel_fetch=False) -> asyncio.Future[Any]"}>

Enqueue an action and ensure the processor is running.

<PySourceCode >

```python
def _enqueue(
	self,
	action: "FetchNext[T, TParam] | FetchPrevious[T, TParam] | Refetch[T, TParam] | RefetchPage[T, TParam]",
	*,
	cancel_fetch: bool = False,
) -> asyncio.Future[Any]:
	"""Enqueue an action and ensure the processor is running."""
	if cancel_fetch:
		self._cancel_queue()

	self._queue.append(action)
	self._ensure_processor()
	return action.future
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"action"} type={"FetchNext[T, TParam] | FetchPrevious[T, TParam] | Refetch[T, TParam] | RefetchPage[T, TParam]"} value={null} />
<PyParameter name={"cancel_fetch"} type={"bool"} value={"False"} />

</div>

<PyFunctionReturn type={"asyncio.asyncio.Future[typing.Any]"} />

</PyFunction>

<PyFunction name={"_ensure_processor"} type={"(self)"}>

Ensure the queue processor task is running.

<PySourceCode >

```python
def _ensure_processor(self):
	"""Ensure the queue processor task is running."""
	if self._queue_task is None or self._queue_task.done():
		# Create task with no reactive scope to avoid inheriting deps from caller
		with Untrack():
			self._queue_task = asyncio.create_task(self._process_queue())
	return self._queue_task
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_process_queue"} type={"(self)"}>

Process queued actions sequentially with retry logic.

<PySourceCode >

```python
async def _process_queue(self):
	"""Process queued actions sequentially with retry logic."""
	while self._queue:
		action = self._queue.popleft()

		if action.future.cancelled():
			continue

		# Reset state for new action
		self._reset_retries()
		self.is_fetching.write(True)
		self.current_action.write(action)

		try:
			while True:
				try:
					result = await self._execute_action(action)
					if not action.future.done():
						action.future.set_result(ActionSuccess(result))
					break
				except asyncio.CancelledError:
					raise
				except Exception as e:
					if self.retries.read() < self.cfg.retries:
						self._record_retry(e)
						await asyncio.sleep(self.cfg.retry_delay)
						continue
					raise
		except asyncio.CancelledError:
			if not action.future.done():
				action.future.cancel()
			raise
		except Exception as e:
			self.retry_reason.write(e)
			await self._commit_error(e)
			if not action.future.done():
				action.future.set_result(ActionError(e))
		finally:
			# Only reset state if we're still the current action
			# (not replaced by another action via cancel_fetch)
			if self.current_action.read() is action:
				self.is_fetching.write(False)
				self.current_action.write(None)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_execute_action"} type={"(self, action) -> Any"}>

Execute a single action.

<PySourceCode >

```python
async def _execute_action(
	self,
	action: "FetchNext[T, TParam] | FetchPrevious[T, TParam] | Refetch[T, TParam] | RefetchPage[T, TParam]",
) -> Any:
	"""Execute a single action."""
	if isinstance(action, FetchNext):
		return await self._execute_fetch_next(action)
	elif isinstance(action, FetchPrevious):
		return await self._execute_fetch_previous(action)
	elif isinstance(action, Refetch):
		return await self._execute_refetch_all(action)
	elif isinstance(action, RefetchPage):
		return await self._execute_refetch_one(action)
	else:
		raise TypeError(f"Unknown action type: {type(action)}")
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"action"} type={"FetchNext[T, TParam] | FetchPrevious[T, TParam] | Refetch[T, TParam] | RefetchPage[T, TParam]"} value={null} />

</div>

<PyFunctionReturn type={"typing.Any"} />

</PyFunction>

<PyFunction name={"_execute_fetch_next"} type={"(self, action) -> Page[T, TParam] | None"}>

<PySourceCode >

```python
async def _execute_fetch_next(
	self, action: "FetchNext[T, TParam]"
) -> Page[T, TParam] | None:
	next_param = self.compute_next_param()
	if next_param is None:
		self.has_next_page.write(False)
		return None

	page = await action.fetch_fn(next_param)
	page = Page(page, next_param)
	self.pages.append(page)
	self._trim_front()
	await self.commit()
	return page
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"action"} type={"FetchNext[T, TParam]"} value={null} />

</div>

<PyFunctionReturn type={"pulse.queries.infinite_query.Page[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam] | None"} />

</PyFunction>

<PyFunction name={"_execute_fetch_previous"} type={"(self, action) -> Page[T, TParam] | None"}>

<PySourceCode >

```python
async def _execute_fetch_previous(
	self, action: "FetchPrevious[T, TParam]"
) -> Page[T, TParam] | None:
	prev_param = self.compute_previous_param()
	if prev_param is None:
		self.has_previous_page.write(False)
		return None

	data = await action.fetch_fn(prev_param)
	page = Page(data, prev_param)
	self.pages.insert(0, page)
	self._trim_back()
	await self.commit()
	return page
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"action"} type={"FetchPrevious[T, TParam]"} value={null} />

</div>

<PyFunctionReturn type={"pulse.queries.infinite_query.Page[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam] | None"} />

</PyFunction>

<PyFunction name={"_execute_refetch_all"} type={"(self, action) -> list[Page[T, TParam]]"}>

<PySourceCode >

```python
async def _execute_refetch_all(
	self, action: "Refetch[T, TParam]"
) -> list[Page[T, TParam]]:
	if len(self.pages) == 0:
		page = await action.fetch_fn(self.cfg.initial_page_param)
		self.pages.append(Page(page, self.cfg.initial_page_param))
		await self.commit()
		return self.pages

	page_param: TParam = self.pages[0].param
	num_existing = len(self.pages)

	for idx in range(num_existing):
		old_page = self.pages[idx]
		should_refetch = True
		if action.refetch_page is not None:
			should_refetch = bool(
				action.refetch_page(
					old_page.data, idx, [p.data for p in self.pages]
				)
			)

		if should_refetch:
			page = await action.fetch_fn(page_param)
		else:
			page = old_page.data
		self.pages[idx] = Page(page, page_param)

		next_param = self.cfg.get_next_page_param(self.pages[: idx + 1])
		if next_param is None:
			# Trim remaining pages if we ended early
			while len(self.pages) > idx + 1:
				self.pages.pop()
			break
		page_param = next_param

	await self.commit()
	return self.pages
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"action"} type={"Refetch[T, TParam]"} value={null} />

</div>

<PyFunctionReturn type={"list[pulse.queries.infinite_query.Page[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam]]"} />

</PyFunction>

<PyFunction name={"_execute_refetch_one"} type={"(self, action) -> T | None"}>

<PySourceCode >

```python
async def _execute_refetch_one(self, action: "RefetchPage[T, TParam]") -> T | None:
	idx = next(
		(i for i, p in enumerate(self.pages) if p.param == action.param),
		None,
	)
	if idx is None:
		return None

	page = await action.fetch_fn(action.param)
	self.pages[idx] = Page(page, action.param)
	await self.commit()
	return page
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"action"} type={"RefetchPage[T, TParam]"} value={null} />

</div>

<PyFunctionReturn type={"pulse.queries.infinite_query.T | None"} />

</PyFunction>

<PyFunction name={"fetch_next_page"} type={"(self, fetch_fn=None, *, observer=None, cancel_fetch=False) -> ActionResult[Page[T, TParam] | None]"}>

Fetch the next page. Queued for sequential execution.

Note: Prefer calling fetch_next_page() on InfiniteQueryResult to ensure the
correct fetch function is used. When called directly on InfiniteQuery, uses
the first observer's fetch function if not provided.

<PySourceCode >

```python
async def fetch_next_page(
	self,
	fetch_fn: Callable[[TParam], Awaitable[T]] | None = None,
	*,
	observer: "InfiniteQueryResult[T, TParam] | None" = None,
	cancel_fetch: bool = False,
) -> ActionResult[Page[T, TParam] | None]:
	"""
	Fetch the next page. Queued for sequential execution.

	Note: Prefer calling fetch_next_page() on InfiniteQueryResult to ensure the
	correct fetch function is used. When called directly on InfiniteQuery, uses
	the first observer's fetch function if not provided.
	"""
	fn = fetch_fn if fetch_fn is not None else self.fn
	action: FetchNext[T, TParam] = FetchNext(fetch_fn=fn, observer=observer)
	return await self._enqueue(action, cancel_fetch=cancel_fetch)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fetch_fn"} type={"Callable[[TParam], Awaitable[T]] | None"} value={"None"} />
<PyParameter name={"observer"} type={"InfiniteQueryResult[T, TParam] | None"} value={"None"} />
<PyParameter name={"cancel_fetch"} type={"bool"} value={"False"} />

</div>

<PyFunctionReturn type={"pulse.queries.common.ActionResult[pulse.queries.infinite_query.Page[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam] | None]"} />

</PyFunction>

<PyFunction name={"fetch_previous_page"} type={"(self, fetch_fn=None, *, observer=None, cancel_fetch=False) -> ActionResult[Page[T, TParam] | None]"}>

Fetch the previous page. Queued for sequential execution.

Note: Prefer calling fetch_previous_page() on InfiniteQueryResult to ensure
the correct fetch function is used. When called directly on InfiniteQuery,
uses the first observer's fetch function if not provided.

<PySourceCode >

```python
async def fetch_previous_page(
	self,
	fetch_fn: Callable[[TParam], Awaitable[T]] | None = None,
	*,
	observer: "InfiniteQueryResult[T, TParam] | None" = None,
	cancel_fetch: bool = False,
) -> ActionResult[Page[T, TParam] | None]:
	"""
	Fetch the previous page. Queued for sequential execution.

	Note: Prefer calling fetch_previous_page() on InfiniteQueryResult to ensure
	the correct fetch function is used. When called directly on InfiniteQuery,
	uses the first observer's fetch function if not provided.
	"""
	fn = fetch_fn if fetch_fn is not None else self.fn
	action: FetchPrevious[T, TParam] = FetchPrevious(fetch_fn=fn, observer=observer)
	return await self._enqueue(action, cancel_fetch=cancel_fetch)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fetch_fn"} type={"Callable[[TParam], Awaitable[T]] | None"} value={"None"} />
<PyParameter name={"observer"} type={"InfiniteQueryResult[T, TParam] | None"} value={"None"} />
<PyParameter name={"cancel_fetch"} type={"bool"} value={"False"} />

</div>

<PyFunctionReturn type={"pulse.queries.common.ActionResult[pulse.queries.infinite_query.Page[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam] | None]"} />

</PyFunction>

<PyFunction name={"refetch"} type={"(self, fetch_fn=None, *, observer=None, cancel_fetch=False, refetch_page=None) -> ActionResult[list[Page[T, TParam]]]"}>

Refetch all pages. Queued for sequential execution.

Note: Prefer calling refetch() on InfiniteQueryResult to ensure the correct
fetch function is used. When called directly on InfiniteQuery, uses the first
observer's fetch function if not provided.

<PySourceCode >

```python
async def refetch(
	self,
	fetch_fn: Callable[[TParam], Awaitable[T]] | None = None,
	*,
	observer: "InfiniteQueryResult[T, TParam] | None" = None,
	cancel_fetch: bool = False,
	refetch_page: Callable[[T, int, list[T]], bool] | None = None,
) -> ActionResult[list[Page[T, TParam]]]:
	"""
	Refetch all pages. Queued for sequential execution.

	Note: Prefer calling refetch() on InfiniteQueryResult to ensure the correct
	fetch function is used. When called directly on InfiniteQuery, uses the first
	observer's fetch function if not provided.
	"""
	fn = fetch_fn if fetch_fn is not None else self.fn
	action: Refetch[T, TParam] = Refetch(
		fetch_fn=fn, observer=observer, refetch_page=refetch_page
	)
	return await self._enqueue(action, cancel_fetch=cancel_fetch)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fetch_fn"} type={"Callable[[TParam], Awaitable[T]] | None"} value={"None"} />
<PyParameter name={"observer"} type={"InfiniteQueryResult[T, TParam] | None"} value={"None"} />
<PyParameter name={"cancel_fetch"} type={"bool"} value={"False"} />
<PyParameter name={"refetch_page"} type={"Callable[[T, int, list[T]], bool] | None"} value={"None"} />

</div>

<PyFunctionReturn type={"pulse.queries.common.ActionResult[list[pulse.queries.infinite_query.Page[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam]]]"} />

</PyFunction>

<PyFunction name={"refetch_page"} type={"(self, param, fetch_fn=None, *, observer=None, cancel_fetch=False) -> ActionResult[T | None]"}>

Refetch an existing page by its param. Queued for sequential execution.

Note: Prefer calling refetch_page() on InfiniteQueryResult to ensure the
correct fetch function is used. When called directly on InfiniteQuery, uses
the first observer's fetch function if not provided.

<PySourceCode >

```python
async def refetch_page(
	self,
	param: TParam,
	fetch_fn: Callable[[TParam], Awaitable[T]] | None = None,
	*,
	observer: "InfiniteQueryResult[T, TParam] | None" = None,
	cancel_fetch: bool = False,
) -> ActionResult[T | None]:
	"""
	Refetch an existing page by its param. Queued for sequential execution.

	Note: Prefer calling refetch_page() on InfiniteQueryResult to ensure the
	correct fetch function is used. When called directly on InfiniteQuery, uses
	the first observer's fetch function if not provided.
	"""
	fn = fetch_fn if fetch_fn is not None else self.fn
	action: RefetchPage[T, TParam] = RefetchPage(
		fetch_fn=fn, param=param, observer=observer
	)
	return await self._enqueue(action, cancel_fetch=cancel_fetch)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"param"} type={"TParam"} value={null} />
<PyParameter name={"fetch_fn"} type={"Callable[[TParam], Awaitable[T]] | None"} value={"None"} />
<PyParameter name={"observer"} type={"InfiniteQueryResult[T, TParam] | None"} value={"None"} />
<PyParameter name={"cancel_fetch"} type={"bool"} value={"False"} />

</div>

<PyFunctionReturn type={"pulse.queries.common.ActionResult[pulse.queries.infinite_query.T | None]"} />

</PyFunction>

<PyFunction name={"dispose"} type={"(self)"}>

<PySourceCode >

```python
@override
def dispose(self):
	self._cancel_queue()
	if self._queue_task and not self._queue_task.done():
		self._queue_task.cancel()
	if self.cfg.on_dispose:
		self.cfg.on_dispose(self)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>