---
title: UnkeyedQueryResult
---

Query for unkeyed queries (single observer with dependency tracking).
Uses an AsyncEffect to track dependencies and re-run on changes.

Unlike KeyedQuery which separates the query from its observer (KeyedQueryResult),
UnkeyedQuery combines both since there's always exactly one observer.

## Attributes

<PyAttribute name={"state"} type={"QueryState[T]"} value={"QueryState(name='unkeyed', retries=retries, retry_delay=retry_delay, initial_data=initial_data, initial_data_updated_at=initial_data_updated_at, gc_time=gc_time, on_dispose=None)"} />

<PyAttribute name={"status"} type={"QueryStatus"} value={null} />

<PyAttribute name={"is_loading"} type={"bool"} value={null} />

<PyAttribute name={"is_success"} type={"bool"} value={null} />

<PyAttribute name={"is_error"} type={"bool"} value={null} />

<PyAttribute name={"is_fetching"} type={"bool"} value={null} />

<PyAttribute name={"error"} type={"Exception | None"} value={null} />

<PyAttribute name={"data"} type={"T | None"} value={null} />

<PyAttribute name={"is_scheduled"} type={"bool"} value={null}>

Check if a fetch is currently scheduled/running.

</PyAttribute>

## Functions

<PyFunction name={"__init__"} type={"(self, fetch_fn, on_success=None, on_error=None, retries=3, retry_delay=RETRY_DELAY_DEFAULT, initial_data=MISSING, initial_data_updated_at=None, gc_time=300.0, stale_time=0.0, refetch_interval=None, keep_previous_data=False, enabled=True, fetch_on_mount=True)"}>

<PySourceCode >

```python
def __init__(
	self,
	fetch_fn: Callable[[], Awaitable[T]],
	on_success: Callable[[T], Awaitable[None] | None] | None = None,
	on_error: Callable[[Exception], Awaitable[None] | None] | None = None,
	retries: int = 3,
	retry_delay: float = RETRY_DELAY_DEFAULT,
	initial_data: T | None = MISSING,
	initial_data_updated_at: float | dt.datetime | None = None,
	gc_time: float = 300.0,
	stale_time: float = 0.0,
	refetch_interval: float | None = None,
	keep_previous_data: bool = False,
	enabled: bool = True,
	fetch_on_mount: bool = True,
):
	self.state = QueryState(
		name="unkeyed",
		retries=retries,
		retry_delay=retry_delay,
		initial_data=initial_data,
		initial_data_updated_at=initial_data_updated_at,
		gc_time=gc_time,
		on_dispose=None,
	)
	self._fetch_fn = fetch_fn
	self._on_success = on_success
	self._on_error = on_error
	self._stale_time = stale_time
	self._refetch_interval = refetch_interval
	self._keep_previous_data = keep_previous_data
	self._enabled = Signal(enabled, name="query.enabled(unkeyed)")
	self._interval_effect = None

	# Create effect with auto-tracking (deps=None)
	# Pass state as fetcher since it has the Signal attributes directly
	self._effect = AsyncQueryEffect(
		self._run,
		fetcher=self.state,
		name="unkeyed_query_effect",
		deps=None,  # Auto-track dependencies
		lazy=True,
	)

	# Computed for keep_previous_data logic
	self._data_computed = Computed(
		self._data_computed_fn, name="query_data(unkeyed)"
	)

	# Schedule initial fetch if stale (untracked to avoid reactive loop)
	with Untrack():
		if enabled and fetch_on_mount and self.is_stale():
			self.schedule()

	# Set up interval effect if interval is specified
	if refetch_interval is not None and refetch_interval > 0:
		self._setup_interval_effect(refetch_interval)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fetch_fn"} type={"Callable[[], Awaitable[T]]"} value={null} />
<PyParameter name={"on_success"} type={"Callable[[T], Awaitable[None] | None] | None"} value={"None"} />
<PyParameter name={"on_error"} type={"Callable[[Exception], Awaitable[None] | None] | None"} value={"None"} />
<PyParameter name={"retries"} type={"int"} value={"3"} />
<PyParameter name={"retry_delay"} type={"float"} value={"RETRY_DELAY_DEFAULT"} />
<PyParameter name={"initial_data"} type={"T | None"} value={"MISSING"} />
<PyParameter name={"initial_data_updated_at"} type={"float | dt.datetime | None"} value={"None"} />
<PyParameter name={"gc_time"} type={"float"} value={"300.0"} />
<PyParameter name={"stale_time"} type={"float"} value={"0.0"} />
<PyParameter name={"refetch_interval"} type={"float | None"} value={"None"} />
<PyParameter name={"keep_previous_data"} type={"bool"} value={"False"} />
<PyParameter name={"enabled"} type={"bool"} value={"True"} />
<PyParameter name={"fetch_on_mount"} type={"bool"} value={"True"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_setup_interval_effect"} type={"(self, interval)"}>

Create an effect that invalidates the query at the specified interval.

<PySourceCode >

```python
def _setup_interval_effect(self, interval: float):
	"""Create an effect that invalidates the query at the specified interval."""

	def interval_fn():
		if self._enabled():
			self.schedule()

	self._interval_effect = Effect(
		interval_fn,
		name="query_interval(unkeyed)",
		interval=interval,
		immediate=True,
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"interval"} type={"float"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_data_computed_fn"} type={"(self, prev) -> T | None"}>

<PySourceCode >

```python
def _data_computed_fn(self, prev: T | None) -> T | None:
	if self._keep_previous_data and self.state.status() != "success":
		return prev
	raw = self.state.data()
	if raw is None:
		return None
	return raw
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"prev"} type={"T | None"} value={null} />

</div>

<PyFunctionReturn type={"pulse.queries.query.T | None"} />

</PyFunction>

<PyFunction name={"set_data"} type={"(self, data)"}>

Optimistically set data without changing loading/error state.

<PySourceCode >

```python
def set_data(self, data: T | Callable[[T | None], T]):
	"""Optimistically set data without changing loading/error state."""
	self.state.set_data(data)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"data"} type={"T | Callable[[T | None], T]"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"set_initial_data"} type={"(self, data, *, updated_at=None)"}>

Seed initial data and optional freshness timestamp.

<PySourceCode >

```python
def set_initial_data(
	self,
	data: T | Callable[[], T],
	*,
	updated_at: float | dt.datetime | None = None,
):
	"""Seed initial data and optional freshness timestamp."""
	self.state.set_initial_data(data, updated_at=updated_at)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"data"} type={"T | Callable[[], T]"} value={null} />
<PyParameter name={"updated_at"} type={"float | dt.datetime | None"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"set_error"} type={"(self, error)"}>

Set error state on the query.

<PySourceCode >

```python
def set_error(self, error: Exception):
	"""Set error state on the query."""
	self.state.set_error(error)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"error"} type={"Exception"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"enable"} type={"(self)"}>

Enable the query.

<PySourceCode >

```python
def enable(self):
	"""Enable the query."""
	self._enabled.write(True)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"disable"} type={"(self)"}>

Disable the query, preventing it from fetching.

<PySourceCode >

```python
def disable(self):
	"""Disable the query, preventing it from fetching."""
	self._enabled.write(False)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"is_stale"} type={"(self) -> bool"}>

Check if the query data is stale based on stale_time.

<PySourceCode >

```python
def is_stale(self) -> bool:
	"""Check if the query data is stale based on stale_time."""
	return (time.time() - self.state.last_updated.read()) > self._stale_time
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"bool"} />

</PyFunction>

<PyFunction name={"_run"} type={"(self)"}>

Run the fetch through the effect (for dependency tracking).

<PySourceCode >

```python
async def _run(self):
	"""Run the fetch through the effect (for dependency tracking)."""
	# Unkeyed queries run inside AsyncEffect which has its own scope,
	# so we don't need untrack=True here - deps should be tracked
	await run_fetch_with_retries(
		self.state,
		self._fetch_fn,
		on_success=self._on_success,
		on_error=self._on_error,
		untrack=False,
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"schedule"} type={"(self)"}>

Schedule the effect to run.

<PySourceCode >

```python
def schedule(self):
	"""Schedule the effect to run."""
	self._effect.schedule()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"refetch"} type={"(self, cancel_refetch=True) -> ActionResult[T]"}>

Refetch the query data through the effect.

<PySourceCode >

```python
async def refetch(self, cancel_refetch: bool = True) -> ActionResult[T]:
	"""Refetch the query data through the effect."""
	if cancel_refetch:
		self.cancel()
	self.schedule()
	return await self.wait()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"cancel_refetch"} type={"bool"} value={"True"} />

</div>

<PyFunctionReturn type={"pulse.queries.common.ActionResult[pulse.queries.query.T]"} />

</PyFunction>

<PyFunction name={"wait"} type={"(self) -> ActionResult[T]"}>

Wait for the current query to complete.

<PySourceCode >

```python
async def wait(self) -> ActionResult[T]:
	"""Wait for the current query to complete."""
	# If loading and no task, schedule a fetch
	if self.state.status() == "loading" and not self.state.is_fetching():
		self.schedule()
	await self._effect.wait()
	if self.state.status() == "error":
		return ActionError(cast(Exception, self.state.error.read()))
	return ActionSuccess(cast(T, self.state.data.read()))
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"pulse.queries.common.ActionResult[pulse.queries.query.T]"} />

</PyFunction>

<PyFunction name={"invalidate"} type={"(self)"}>

Mark the query as stale and refetch through the effect.

<PySourceCode >

```python
def invalidate(self):
	"""Mark the query as stale and refetch through the effect."""
	if not self.is_scheduled:
		self.schedule()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"cancel"} type={"(self) -> None"}>

Cancel the current fetch if running.

<PySourceCode >

```python
def cancel(self) -> None:
	"""Cancel the current fetch if running."""
	self._effect.cancel(cancel_interval=False)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"dispose"} type={"(self)"}>

Clean up the query and its effect.

<PySourceCode >

```python
@override
def dispose(self):
	"""Clean up the query and its effect."""
	if self._interval_effect is not None:
		self._interval_effect.dispose()
	self._effect.dispose()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>