---
title: query
---

<PyAttribute name={"T"} type={null} value={"TypeVar('T')"} />

<PyAttribute name={"TState"} type={null} value={"TypeVar('TState', bound=State)"} />

<PyAttribute name={"RETRY_DELAY_DEFAULT"} type={null} value={"2.0 if not is_pytest() else 0.01"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"QueryConfig"} href={"/docs/api/pulse/queries/query/QueryConfig"} />
<Card title={"QueryState"} href={"/docs/api/pulse/queries/query/QueryState"} />
<Card title={"KeyedQuery"} href={"/docs/api/pulse/queries/query/KeyedQuery"} />
<Card title={"UnkeyedQueryResult"} href={"/docs/api/pulse/queries/query/UnkeyedQueryResult"} />
<Card title={"KeyedQueryResult"} href={"/docs/api/pulse/queries/query/KeyedQueryResult"} />
<Card title={"QueryProperty"} href={"/docs/api/pulse/queries/query/QueryProperty"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"run_fetch_with_retries"} type={"(state, fetch_fn, on_success=None, on_error=None, untrack=False) -> None"}>

Execute a fetch with retry logic, updating QueryState.

<PySourceCode >

```python
async def run_fetch_with_retries(
	state: QueryState[T],
	fetch_fn: Callable[[], Awaitable[T]],
	on_success: Callable[[T], Awaitable[None] | None] | None = None,
	on_error: Callable[[Exception], Awaitable[None] | None] | None = None,
	untrack: bool = False,
) -> None:
	"""
	Execute a fetch with retry logic, updating QueryState.

	Args:
		state: The QueryState to update
		fetch_fn: Async function to fetch data
		on_success: Optional callback on success
		on_error: Optional callback on error
		untrack: If True, wrap fetch_fn in Untrack() to prevent dependency tracking.
		         Use for keyed queries where fetch is triggered via asyncio.create_task.
	"""
	state.reset_retries()

	while True:
		try:
			if untrack:
				with Untrack():
					result = await fetch_fn()
			else:
				result = await fetch_fn()
			state.set_success(result)
			if on_success:
				await maybe_await(call_flexible(on_success, result))
			return
		except asyncio.CancelledError:
			raise
		except Exception as e:
			current_retries = state.retries.read()
			if current_retries < state.cfg.retries:
				state.failed_retry(e)
				await asyncio.sleep(state.cfg.retry_delay)
			else:
				state.retry_reason.write(e)
				state.apply_error(e)
				if on_error:
					await maybe_await(call_flexible(on_error, e))
				return
```

</PySourceCode>

<div >

<PyParameter name={"state"} type={"QueryState[T]"} value={undefined}>

The QueryState to update

</PyParameter>
<PyParameter name={"fetch_fn"} type={"Callable[[], Awaitable[T]]"} value={undefined}>

Async function to fetch data

</PyParameter>
<PyParameter name={"on_success"} type={"Callable[[T], Awaitable[None] | None] | None"} value={"None"}>

Optional callback on success

</PyParameter>
<PyParameter name={"on_error"} type={"Callable[[Exception], Awaitable[None] | None] | None"} value={"None"}>

Optional callback on error

</PyParameter>
<PyParameter name={"untrack"} type={"bool"} value={"False"}>

If True, wrap fetch_fn in Untrack() to prevent dependency tracking.
Use for keyed queries where fetch is triggered via asyncio.create_task.

</PyParameter>

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>
<PyFunction name={"query"} type={"(fn=None, *, stale_time=0.0, gc_time=300.0, refetch_interval=None, keep_previous_data=False, retries=3, retry_delay=None, initial_data_updated_at=None, enabled=True, fetch_on_mount=True, key=None)"}>

Decorator for async data fetching on State methods.

Creates a reactive query that automatically fetches data, handles loading
states, retries on failure, and caches results. Queries can be shared
across components using keys.

Example:

Basic usage:

```python
class UserState(ps.State):
    user_id: str = ""

    @ps.query
    async def user(self) -> User:
        return await api.get_user(self.user_id)
```

With options:

```python
@ps.query(stale_time=60, refetch_interval=300)
async def user(self) -> User:
    return await api.get_user(self.user_id)
```

Keyed query (shared across instances):

```python
@ps.query(key=("users", "current"))
async def current_user(self) -> User:
    return await api.get_current_user()
```

<PySourceCode >

```python
def query(
	fn: Callable[[TState], Awaitable[T]] | None = None,
	*,
	stale_time: float = 0.0,
	gc_time: float | None = 300.0,
	refetch_interval: float | None = None,
	keep_previous_data: bool = False,
	retries: int = 3,
	retry_delay: float | None = None,
	initial_data_updated_at: float | dt.datetime | None = None,
	enabled: bool = True,
	fetch_on_mount: bool = True,
	key: QueryKey | None = None,
):
	"""Decorator for async data fetching on State methods.

	Creates a reactive query that automatically fetches data, handles loading
	states, retries on failure, and caches results. Queries can be shared
	across components using keys.

	Args:
		fn: The async method to decorate (when used without parentheses).
		stale_time: Seconds before data is considered stale (default 0.0).
		gc_time: Seconds to keep unused query in cache (default 300.0, None to disable).
		refetch_interval: Auto-refetch interval in seconds (default None, disabled).
		keep_previous_data: Keep previous data while refetching (default False).
		retries: Number of retry attempts on failure (default 3).
		retry_delay: Delay between retries in seconds (default 2.0).
		initial_data_updated_at: Timestamp for initial data staleness calculation.
		enabled: Whether query is enabled (default True).
		fetch_on_mount: Fetch when component mounts (default True).
		key: Static query key for sharing across instances.

	Returns:
		QueryProperty that creates QueryResult instances when accessed.

	Example:

	Basic usage:

	\```python
	class UserState(ps.State):
	    user_id: str = ""

	    @ps.query
	    async def user(self) -> User:
	        return await api.get_user(self.user_id)
	\```

	With options:

	\```python
	@ps.query(stale_time=60, refetch_interval=300)
	async def user(self) -> User:
	    return await api.get_user(self.user_id)
	\```

	Keyed query (shared across instances):

	\```python
	@ps.query(key=("users", "current"))
	async def current_user(self) -> User:
	    return await api.get_current_user()
	\```
	"""

	def decorator(
		func: Callable[[TState], Awaitable[T]], /
	) -> QueryProperty[T, TState]:
		sig = inspect.signature(func)
		params = list(sig.parameters.values())
		# Only state-method form supported for now (single 'self')
		if not (len(params) == 1 and params[0].name == "self"):
			raise TypeError("@query currently only supports state methods (self)")

		return QueryProperty(
			func.__name__,
			func,
			stale_time=stale_time,
			gc_time=gc_time if gc_time is not None else 300.0,
			refetch_interval=refetch_interval,
			keep_previous_data=keep_previous_data,
			retries=retries,
			retry_delay=RETRY_DELAY_DEFAULT if retry_delay is None else retry_delay,
			initial_data_updated_at=initial_data_updated_at,
			enabled=enabled,
			fetch_on_mount=fetch_on_mount,
			key=key,
		)

	if fn:
		return decorator(fn)
	return decorator
```

</PySourceCode>

<div >

<PyParameter name={"fn"} type={"Callable[[TState], Awaitable[T]] | None"} value={"None"}>

The async method to decorate (when used without parentheses).

</PyParameter>
<PyParameter name={"stale_time"} type={"float"} value={"0.0"}>

Seconds before data is considered stale (default 0.0).

</PyParameter>
<PyParameter name={"gc_time"} type={"float | None"} value={"300.0"}>

Seconds to keep unused query in cache (default 300.0, None to disable).

</PyParameter>
<PyParameter name={"refetch_interval"} type={"float | None"} value={"None"}>

Auto-refetch interval in seconds (default None, disabled).

</PyParameter>
<PyParameter name={"keep_previous_data"} type={"bool"} value={"False"}>

Keep previous data while refetching (default False).

</PyParameter>
<PyParameter name={"retries"} type={"int"} value={"3"}>

Number of retry attempts on failure (default 3).

</PyParameter>
<PyParameter name={"retry_delay"} type={"float | None"} value={"None"}>

Delay between retries in seconds (default 2.0).

</PyParameter>
<PyParameter name={"initial_data_updated_at"} type={"float | dt.datetime | None"} value={"None"}>

Timestamp for initial data staleness calculation.

</PyParameter>
<PyParameter name={"enabled"} type={"bool"} value={"True"}>

Whether query is enabled (default True).

</PyParameter>
<PyParameter name={"fetch_on_mount"} type={"bool"} value={"True"}>

Fetch when component mounts (default True).

</PyParameter>
<PyParameter name={"key"} type={"QueryKey | None"} value={"None"}>

Static query key for sharing across instances.

</PyParameter>

</div>

<PyFunctionReturn type={null}>

QueryProperty that creates QueryResult instances when accessed.

</PyFunctionReturn>

</PyFunction>

</Tab>

</Tabs>