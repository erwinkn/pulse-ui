---
title: Batch
---

Groups reactive updates to run effects once after all writes.

By default, effects are scheduled in a global batch that flushes on the
next event loop iteration. Use as a context manager to create an explicit
batch that flushes on exit.

## Attributes

<PyAttribute name={"name"} type={"str | None"} value={"name"} />

<PyAttribute name={"effects"} type={"list[Effect]"} value={"effects or []"} />

## Functions

<PyFunction name={"__init__"} type={"(self, effects=None, name=None) -> None"}>

<PySourceCode >

```python
def __init__(
	self, effects: list[Effect] | None = None, name: str | None = None
) -> None:
	self.effects: list[Effect] = effects or []
	self.name = name
	self._token: "Token[ReactiveContext] | None" = None
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"effects"} type={"list[Effect] | None"} value={"None"} />
<PyParameter name={"name"} type={"str | None"} value={"None"} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"register_effect"} type={"(self, effect)"}>

Add an effect to run when the batch flushes.

<PySourceCode >

```python
def register_effect(self, effect: Effect):
	"""Add an effect to run when the batch flushes.

	Args:
		effect: The effect to schedule.
	"""
	if effect not in self.effects:
		self.effects.append(effect)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"effect"} type={"Effect"} value={undefined}>

The effect to schedule.

</PyParameter>

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"flush"} type={"(self)"}>

Run all scheduled effects.

<PySourceCode >

```python
def flush(self):
	"""Run all scheduled effects."""
	token = None
	rc = REACTIVE_CONTEXT.get()
	if rc.batch is not self:
		token = REACTIVE_CONTEXT.set(ReactiveContext(rc.epoch, self, rc.scope))

	MAX_ITERS = 10000
	iters = 0

	while len(self.effects) > 0:
		if iters > MAX_ITERS:
			raise RuntimeError(
				f"Pulse's reactive system registered more than {MAX_ITERS} iterations. There is likely an update cycle in your application.\n"
				+ "This is most often caused through a state update during rerender or in an effect that ends up triggering the same rerender or effect."
			)

		# This ensures the epoch is incremented *after* all the signal
		# writes and associated effects have been run.

		current_effects = self.effects
		self.effects = []

		for effect in current_effects:
			effect.batch = None
			if not effect.should_run():
				continue
			try:
				effect.run()
			except Exception as exc:
				effect.handle_error(exc)

		iters += 1

	if token:
		REACTIVE_CONTEXT.reset(token)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"__enter__"} type={"(self)"}>

<PySourceCode >

```python
def __enter__(self):
	rc = REACTIVE_CONTEXT.get()
	# Create a new immutable reactive context with updated batch
	self._token = REACTIVE_CONTEXT.set(
		ReactiveContext(rc.epoch, self, rc.scope, rc.on_effect_error)
	)
	return self
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"__exit__"} type={"(self, exc_type, exc_value, exc_traceback) -> Literal[False]"}>

<PySourceCode >

```python
def __exit__(
	self,
	exc_type: type[BaseException] | None,
	exc_value: BaseException | None,
	exc_traceback: Any,
) -> Literal[False]:
	self.flush()
	# Restore previous reactive context
	if self._token:
		REACTIVE_CONTEXT.reset(self._token)
	return False
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"exc_type"} type={"type[BaseException] | None"} value={null} />
<PyParameter name={"exc_value"} type={"BaseException | None"} value={null} />
<PyParameter name={"exc_traceback"} type={"Any"} value={null} />

</div>

<PyFunctionReturn type={"typing.Literal[False]"} />

</PyFunction>