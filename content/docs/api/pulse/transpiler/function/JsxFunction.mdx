---
title: JsxFunction
---

A transpiled JSX/React component function.

Like JsFunction, but transpiles to a React component that receives
a single props object with destructuring.

For a Python function like:
        def Component(*children, visible=True): ...

Generates:
        function Component_1(\{children, visible = true\}) \{ ... \}

## Attributes

<PyAttribute name={"fn"} type={"Callable[P, R]"} value={"fn"} />

<PyAttribute name={"id"} type={"str"} value={"next_id()"} />

<PyAttribute name={"deps"} type={"dict[str, Expr]"} value={"analyze_deps(fn)"} />

<PyAttribute name={"js_name"} type={"str"} value={null}>

Unique JS identifier for this function.

</PyAttribute>

## Functions

<PyFunction name={"__init__"} type={"(self, fn) -> None"}>

<PySourceCode >

```python
def __init__(self, fn: Callable[..., Any]) -> None:
	self.fn = fn
	self.id = next_id()
	self._transpiled = None
	# Register self in cache BEFORE analyzing deps (handles cycles)
	FUNCTION_CACHE[fn] = self
	# Now analyze and build deps
	self.deps = analyze_deps(fn)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fn"} type={"Callable[..., Any]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"emit"} type={"(self, out) -> None"}>

Emit this function as its unique JS identifier.

<PySourceCode >

```python
@override
def emit(self, out: list[str]) -> None:
	"""Emit this function as its unique JS identifier."""
	out.append(self.js_name)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"out"} type={"list[str]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"render"} type={"(self) -> VDOMNode"}>

Render as a registry reference.

<PySourceCode >

```python
@override
def render(self) -> VDOMNode:
	"""Render as a registry reference."""
	return {"t": "ref", "key": self.id}
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.vdom.VDOMNode"} />

</PyFunction>

<PyFunction name={"transpile"} type={"(self) -> Function"}>

Transpile this JSX function to a React component.

The Transpiler handles converting parameters to a destructured props object.

<PySourceCode >

```python
def transpile(self) -> Function:
	"""Transpile this JSX function to a React component.

	The Transpiler handles converting parameters to a destructured props object.
	"""
	if self._transpiled is not None:
		return self._transpiled

	result, _ = _transpile_function_body(self.fn, self.deps, jsx=True)

	# JSX transpilation always returns Function (never Arrow)
	assert isinstance(result, Function), (
		"JSX transpilation should always return Function"
	)

	# Set the unique name
	self._transpiled = Function(
		params=result.params,
		body=result.body,
		name=self.js_name,
		is_async=result.is_async,
	)
	return self._transpiled
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Function"} />

</PyFunction>

<PyFunction name={"imports"} type={"(self) -> dict[str, Expr]"}>

Get all Import dependencies.

<PySourceCode >

```python
def imports(self) -> dict[str, Expr]:
	"""Get all Import dependencies."""
	return {k: v for k, v in self.deps.items() if isinstance(v, Import)}
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"dict[str, pulse.transpiler.nodes.Expr]"} />

</PyFunction>

<PyFunction name={"functions"} type={"(self) -> dict[str, AnyJsFunction]"}>

Get all function dependencies.

<PySourceCode >

```python
def functions(self) -> dict[str, AnyJsFunction]:
	"""Get all function dependencies."""
	return {
		k: v
		for k, v in self.deps.items()
		if isinstance(v, (JsFunction, JsxFunction))
	}
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"dict[str, pulse.transpiler.function.AnyJsFunction]"} />

</PyFunction>

<PyFunction name={"transpile_call"} type={"(self, args, keywords, ctx) -> Expr"}>

<PySourceCode >

```python
@override
def transpile_call(
	self, args: list[ast.expr], keywords: list[ast.keyword], ctx: Transpiler
) -> Expr:
	# delegate JSX element building to the generic Jsx wrapper
	return Jsx(self).transpile_call(args, keywords, ctx)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"args"} type={"list[ast.expr]"} value={null} />
<PyParameter name={"keywords"} type={"list[ast.keyword]"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>

<PyFunction name={"__call__"} type={"(self, *args, **kwargs) -> R"}>

<PySourceCode >

```python
@override
def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R:  # pyright: ignore[reportIncompatibleMethodOverride]
	# runtime/type-checking: produce Element via Jsx wrapper
	return Jsx(self)(*args, **kwargs)  # pyright: ignore[reportReturnType]
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"args"} type={"P.args"} value={"()"} />
<PyParameter name={"kwargs"} type={"P.kwargs"} value={"{}"} />

</div>

<PyFunctionReturn type={"pulse.transpiler.function.R"} />

</PyFunction>