---
title: nodes
---

<PyAttribute name={"Primitive"} type={"TypeAlias"} value={"bool | int | float | str | dt.datetime | None"} />

<PyAttribute name={"EXPR_REGISTRY"} type={"dict[int, 'Expr']"} value={"{}"} />

<PyAttribute name={"UNDEFINED"} type={null} value={"Undefined()"} />

<PyAttribute name={"Node"} type={"TypeAlias"} value={"Primitive | Expr | PulseNode"} />

<PyAttribute name={"Child"} type={"TypeAlias"} value={"Node | Iterable[Node]"} />

<PyAttribute name={"Children"} type={"TypeAlias"} value={"Sequence[Child]"} />

<PyAttribute name={"Prop"} type={"TypeAlias"} value={"Primitive | Expr"} />

<PyAttribute name={"Emittable"} type={"TypeAlias"} value={"Expr | Stmt"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"Expr"} href={"/docs/api/pulse/transpiler/nodes/Expr"} />
<Card title={"Stmt"} href={"/docs/api/pulse/transpiler/nodes/Stmt"} />
<Card title={"ExprWrapper"} href={"/docs/api/pulse/transpiler/nodes/ExprWrapper"} />
<Card title={"Jsx"} href={"/docs/api/pulse/transpiler/nodes/Jsx"} />
<Card title={"Signature"} href={"/docs/api/pulse/transpiler/nodes/Signature"} />
<Card title={"Value"} href={"/docs/api/pulse/transpiler/nodes/Value"} />
<Card title={"Element"} href={"/docs/api/pulse/transpiler/nodes/Element"} />
<Card title={"PulseNode"} href={"/docs/api/pulse/transpiler/nodes/PulseNode"} />
<Card title={"Identifier"} href={"/docs/api/pulse/transpiler/nodes/Identifier"} />
<Card title={"Literal"} href={"/docs/api/pulse/transpiler/nodes/Literal"} />
<Card title={"Undefined"} href={"/docs/api/pulse/transpiler/nodes/Undefined"} />
<Card title={"Array"} href={"/docs/api/pulse/transpiler/nodes/Array"} />
<Card title={"Object"} href={"/docs/api/pulse/transpiler/nodes/Object"} />
<Card title={"Member"} href={"/docs/api/pulse/transpiler/nodes/Member"} />
<Card title={"Subscript"} href={"/docs/api/pulse/transpiler/nodes/Subscript"} />
<Card title={"Call"} href={"/docs/api/pulse/transpiler/nodes/Call"} />
<Card title={"Unary"} href={"/docs/api/pulse/transpiler/nodes/Unary"} />
<Card title={"Binary"} href={"/docs/api/pulse/transpiler/nodes/Binary"} />
<Card title={"Ternary"} href={"/docs/api/pulse/transpiler/nodes/Ternary"} />
<Card title={"Arrow"} href={"/docs/api/pulse/transpiler/nodes/Arrow"} />
<Card title={"Template"} href={"/docs/api/pulse/transpiler/nodes/Template"} />
<Card title={"Spread"} href={"/docs/api/pulse/transpiler/nodes/Spread"} />
<Card title={"New"} href={"/docs/api/pulse/transpiler/nodes/New"} />
<Card title={"TransformerFn"} href={"/docs/api/pulse/transpiler/nodes/TransformerFn"} />
<Card title={"Transformer"} href={"/docs/api/pulse/transpiler/nodes/Transformer"} />
<Card title={"Return"} href={"/docs/api/pulse/transpiler/nodes/Return"} />
<Card title={"If"} href={"/docs/api/pulse/transpiler/nodes/If"} />
<Card title={"ForOf"} href={"/docs/api/pulse/transpiler/nodes/ForOf"} />
<Card title={"While"} href={"/docs/api/pulse/transpiler/nodes/While"} />
<Card title={"Break"} href={"/docs/api/pulse/transpiler/nodes/Break"} />
<Card title={"Continue"} href={"/docs/api/pulse/transpiler/nodes/Continue"} />
<Card title={"Assign"} href={"/docs/api/pulse/transpiler/nodes/Assign"} />
<Card title={"ExprStmt"} href={"/docs/api/pulse/transpiler/nodes/ExprStmt"} />
<Card title={"Block"} href={"/docs/api/pulse/transpiler/nodes/Block"} />
<Card title={"StmtSequence"} href={"/docs/api/pulse/transpiler/nodes/StmtSequence"} />
<Card title={"Throw"} href={"/docs/api/pulse/transpiler/nodes/Throw"} />
<Card title={"TryStmt"} href={"/docs/api/pulse/transpiler/nodes/TryStmt"} />
<Card title={"Function"} href={"/docs/api/pulse/transpiler/nodes/Function"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"to_js_identifier"} type={"(name) -> str"}>

Normalize a string to a JS-compatible identifier.

<PySourceCode >

```python
def to_js_identifier(name: str) -> str:
	"""Normalize a string to a JS-compatible identifier."""
	if not name:
		return "_"
	out: list[str] = []
	for ch in name:
		out.append(ch if ch in _JS_IDENTIFIER_CONTINUE else "_")
	if not out or out[0] not in _JS_IDENTIFIER_START:
		out.insert(0, "_")
	return "".join(out)
```

</PySourceCode>

<div >

<PyParameter name={"name"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>
<PyFunction name={"flatten_children"} type={"(children, *, parent_name, warn_stacklevel=5) -> list[Node]"}>

<PySourceCode >

```python
def flatten_children(
	children: Sequence[Node | Iterable[Node]],
	*,
	parent_name: str,
	warn_stacklevel: int = 5,
) -> list[Node]:
	if env.pulse_env == "dev":
		return _flatten_children_dev(
			children, parent_name=parent_name, warn_stacklevel=warn_stacklevel
		)
	return _flatten_children_prod(children)
```

</PySourceCode>

<div >

<PyParameter name={"children"} type={"Sequence[Node | Iterable[Node]]"} value={null} />
<PyParameter name={"parent_name"} type={"str"} value={null} />
<PyParameter name={"warn_stacklevel"} type={"int"} value={"5"} />

</div>

<PyFunctionReturn type={"list[pulse.transpiler.nodes.Node]"} />

</PyFunction>
<PyFunction name={"_flatten_children_prod"} type={"(children) -> list[Node]"}>

<PySourceCode >

```python
def _flatten_children_prod(children: Sequence[Node | Iterable[Node]]) -> list[Node]:
	flat: list[Node] = []

	def visit(item: Node | Iterable[Node]) -> None:
		if isinstance(item, dict):
			raise TypeError("Dict is not a valid child")
		if isinstance(item, Iterable) and not isinstance(item, str):
			for sub in item:
				visit(sub)
		else:
			flat.append(item)

	for child in children:
		visit(child)

	return flat
```

</PySourceCode>

<div >

<PyParameter name={"children"} type={"Sequence[Node | Iterable[Node]]"} value={null} />

</div>

<PyFunctionReturn type={"list[pulse.transpiler.nodes.Node]"} />

</PyFunction>
<PyFunction name={"_flatten_children_dev"} type={"(children, *, parent_name, warn_stacklevel=5) -> list[Node]"}>

<PySourceCode >

```python
def _flatten_children_dev(
	children: Sequence[Node | Iterable[Node]],
	*,
	parent_name: str,
	warn_stacklevel: int = 5,
) -> list[Node]:
	flat: list[Node] = []
	seen_keys: set[str] = set()

	def visit(item: Node | Iterable[Node]) -> None:
		if isinstance(item, dict):
			raise TypeError("Dict is not a valid child")
		if isinstance(item, Iterable) and not isinstance(item, str):
			missing_key = False
			for sub in item:
				if isinstance(sub, PulseNode) and sub.key is None:
					missing_key = True
				if isinstance(sub, Element) and _normalize_key(sub.key) is None:
					missing_key = True
				visit(sub)  # type: ignore[arg-type]
			if missing_key:
				clean_name = clean_element_name(parent_name)
				warnings.warn(
					(
						f"[Pulse] Iterable children of {clean_name} contain elements without 'key'. "
						"Add a stable 'key' to each element inside iterables to improve reconciliation."
					),
					stacklevel=warn_stacklevel,
				)
		else:
			if isinstance(item, PulseNode) and item.key is not None:
				if item.key in seen_keys:
					clean_name = clean_element_name(parent_name)
					raise ValueError(
						f"[Pulse] Duplicate key '{item.key}' found among children of {clean_name}. "
						+ "Keys must be unique per sibling set."
					)
				seen_keys.add(item.key)
			if isinstance(item, Element):
				key = _normalize_key(item.key)
				if key is not None:
					if key in seen_keys:
						clean_name = clean_element_name(parent_name)
						raise ValueError(
							f"[Pulse] Duplicate key '{key}' found among children of {clean_name}. "
							+ "Keys must be unique per sibling set."
						)
					seen_keys.add(key)
			flat.append(item)

	for child in children:
		visit(child)

	return flat
```

</PySourceCode>

<div >

<PyParameter name={"children"} type={"Sequence[Node | Iterable[Node]]"} value={null} />
<PyParameter name={"parent_name"} type={"str"} value={null} />
<PyParameter name={"warn_stacklevel"} type={"int"} value={"5"} />

</div>

<PyFunctionReturn type={"list[pulse.transpiler.nodes.Node]"} />

</PyFunction>
<PyFunction name={"clean_element_name"} type={"(parent_name) -> str"}>

<PySourceCode >

```python
def clean_element_name(parent_name: str) -> str:
	if parent_name.startswith("<") and parent_name.endswith(">"):
		return parent_name
	return f"<{parent_name}>"
```

</PySourceCode>

<div >

<PyParameter name={"parent_name"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>
<PyFunction name={"_normalize_key"} type={"(key) -> str | None"}>

<PySourceCode >

```python
def _normalize_key(key: object | None) -> str | None:
	if isinstance(key, Literal):
		return key.value if isinstance(key.value, str) else None
	return key if isinstance(key, str) else None
```

</PySourceCode>

<div >

<PyParameter name={"key"} type={"object | None"} value={null} />

</div>

<PyFunctionReturn type={"str | None"} />

</PyFunction>
<PyFunction name={"spread_dict"} type={"(expr) -> Spread"}>

Wrap a spread expression with Map-to-object conversion.

Python dicts transpile to Map, which has no enumerable own properties.
This wraps the spread with an IIFE that converts Map to object:
        (...expr) -> ...($s => $s instanceof Map ? Object.fromEntries($s) : $s)(expr)

The IIFE ensures expr is evaluated only once.

<PySourceCode >

```python
def spread_dict(expr: Expr) -> Spread:
	"""Wrap a spread expression with Map-to-object conversion.

	Python dicts transpile to Map, which has no enumerable own properties.
	This wraps the spread with an IIFE that converts Map to object:
		(...expr) -> ...($s => $s instanceof Map ? Object.fromEntries($s) : $s)(expr)

	The IIFE ensures expr is evaluated only once.
	"""
	s = Identifier("$s")
	is_map = Binary(s, "instanceof", Identifier("Map"))
	as_obj = Call(Member(Identifier("Object"), "fromEntries"), [s])
	return Spread(Call(Arrow(["$s"], Ternary(is_map, as_obj, s)), [expr]))
```

</PySourceCode>

<div >

<PyParameter name={"expr"} type={"Expr"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Spread"} />

</PyFunction>
<PyFunction name={"transformer"} type={"(arg) -> Callable[[_F], _F] | _F"}>

Decorator/helper for Transformer.

Usage:
        @transformer("len")
        def emit_len(x, *, ctx): ...
or:
        emit_len = transformer(lambda x, *, ctx: ...)

Returns a Transformer, but the type signature lies and preserves
the original function type.

<PySourceCode >

```python
def transformer(arg: str | _F) -> Callable[[_F], _F] | _F:
	"""Decorator/helper for Transformer.

	Usage:
		@transformer("len")
		def emit_len(x, *, ctx): ...
	or:
		emit_len = transformer(lambda x, *, ctx: ...)

	Returns a Transformer, but the type signature lies and preserves
	the original function type.
	"""
	if isinstance(arg, str):

		def decorator(fn: _F) -> _F:
			return cast(_F, Transformer(fn, name=arg))

		return decorator
	elif isfunction(arg):
		# Use empty name for lambdas, function name for named functions
		name = "" if arg.__name__ == "<lambda>" else arg.__name__
		return cast(_F, Transformer(arg, name=name))
	else:
		raise TypeError(
			"transformer expects a function or string (for decorator usage)"
		)
```

</PySourceCode>

<div >

<PyParameter name={"arg"} type={"str | _F"} value={null} />

</div>

<PyFunctionReturn type={"collections.abc.Callable[[pulse.transpiler.nodes._F], pulse.transpiler.nodes._F] | pulse.transpiler.nodes._F"} />

</PyFunction>
<PyFunction name={"emit"} type={"(node) -> str"}>

Emit an expression or statement as JavaScript/JSX code.

<PySourceCode >

```python
def emit(node: Emittable) -> str:
	"""Emit an expression or statement as JavaScript/JSX code."""
	out: list[str] = []
	node.emit(out)
	return "".join(out)
```

</PySourceCode>

<div >

<PyParameter name={"node"} type={"Emittable"} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>
<PyFunction name={"_escape_string"} type={"(s) -> str"}>

Escape for double-quoted JS string literals.

<PySourceCode >

```python
def _escape_string(s: str) -> str:
	"""Escape for double-quoted JS string literals."""
	return (
		s.replace("\\", "\\\\")
		.replace('"', '\\"')
		.replace("\n", "\\n")
		.replace("\r", "\\r")
		.replace("\t", "\\t")
		.replace("\b", "\\b")
		.replace("\f", "\\f")
		.replace("\v", "\\v")
		.replace("\x00", "\\x00")
		.replace("\u2028", "\\u2028")
		.replace("\u2029", "\\u2029")
	)
```

</PySourceCode>

<div >

<PyParameter name={"s"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>
<PyFunction name={"_escape_template"} type={"(s) -> str"}>

Escape for template literal strings.

<PySourceCode >

```python
def _escape_template(s: str) -> str:
	"""Escape for template literal strings."""
	return (
		s.replace("\\", "\\\\")
		.replace("`", "\\`")
		.replace("${", "\\${")
		.replace("\n", "\\n")
		.replace("\r", "\\r")
		.replace("\t", "\\t")
		.replace("\b", "\\b")
		.replace("\f", "\\f")
		.replace("\v", "\\v")
		.replace("\x00", "\\x00")
		.replace("\u2028", "\\u2028")
		.replace("\u2029", "\\u2029")
	)
```

</PySourceCode>

<div >

<PyParameter name={"s"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>
<PyFunction name={"_escape_jsx_text"} type={"(s) -> str"}>

Escape text content for JSX.

<PySourceCode >

```python
def _escape_jsx_text(s: str) -> str:
	"""Escape text content for JSX."""
	return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
```

</PySourceCode>

<div >

<PyParameter name={"s"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>
<PyFunction name={"_escape_jsx_attr"} type={"(s) -> str"}>

Escape attribute value for JSX.

<PySourceCode >

```python
def _escape_jsx_attr(s: str) -> str:
	"""Escape attribute value for JSX."""
	return s.replace("&", "&amp;").replace('"', "&quot;")
```

</PySourceCode>

<div >

<PyParameter name={"s"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>
<PyFunction name={"_emit_paren"} type={"(node, parent_op, side, out) -> None"}>

Emit child with parens if needed for precedence.

<PySourceCode >

```python
def _emit_paren(node: Expr, parent_op: str, side: str, out: list[str]) -> None:
	"""Emit child with parens if needed for precedence."""
	# Ternary as child of binary always needs parens
	needs_parens = False
	if isinstance(node, Ternary):
		needs_parens = True
	else:
		child_prec = node.precedence()
		parent_prec = _PRECEDENCE.get(parent_op, 0)
		if child_prec < parent_prec:
			needs_parens = True
		elif child_prec == parent_prec and isinstance(node, Binary):
			# Handle associativity
			if parent_op in _RIGHT_ASSOC:
				needs_parens = side == "left"
			else:
				needs_parens = side == "right"

	if needs_parens:
		out.append("(")
		node.emit(out)
		out.append(")")
	else:
		node.emit(out)
```

</PySourceCode>

<div >

<PyParameter name={"node"} type={"Expr"} value={null} />
<PyParameter name={"parent_op"} type={"str"} value={null} />
<PyParameter name={"side"} type={"str"} value={null} />
<PyParameter name={"out"} type={"list[str]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>
<PyFunction name={"_emit_primary"} type={"(node, out) -> None"}>

Emit with parens if not primary precedence.

<PySourceCode >

```python
def _emit_primary(node: Expr, out: list[str]) -> None:
	"""Emit with parens if not primary precedence."""
	if node.precedence() < 20 or isinstance(node, Ternary):
		out.append("(")
		node.emit(out)
		out.append(")")
	else:
		node.emit(out)
```

</PySourceCode>

<div >

<PyParameter name={"node"} type={"Expr"} value={null} />
<PyParameter name={"out"} type={"list[str]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>
<PyFunction name={"_emit_value"} type={"(value, out) -> None"}>

Emit a Python value as JavaScript literal.

<PySourceCode >

```python
def _emit_value(value: Any, out: list[str]) -> None:
	"""Emit a Python value as JavaScript literal."""
	if value is None:
		out.append("null")
	elif isinstance(value, bool):
		out.append("true" if value else "false")
	elif isinstance(value, str):
		out.append('"')
		out.append(_escape_string(value))
		out.append('"')
	elif isinstance(value, (int, float)):
		out.append(str(value))
	elif isinstance(value, dt.datetime):
		out.append("new Date(")
		out.append(str(int(value.timestamp() * 1000)))
		out.append(")")
	elif isinstance(value, list):
		out.append("[")
		for i, v in enumerate(value):  # pyright: ignore[reportUnknownArgumentType]
			if i > 0:
				out.append(", ")
			_emit_value(v, out)
		out.append("]")
	elif isinstance(value, dict):
		out.append("{")
		for i, (k, v) in enumerate(value.items()):  # pyright: ignore[reportUnknownArgumentType]
			if i > 0:
				out.append(", ")
			out.append('"')
			out.append(_escape_string(str(k)))  # pyright: ignore[reportUnknownArgumentType]
			out.append('": ')
			_emit_value(v, out)
		out.append("}")
	elif isinstance(value, set):
		out.append("new Set([")
		for i, v in enumerate(value):  # pyright: ignore[reportUnknownArgumentType]
			if i > 0:
				out.append(", ")
			_emit_value(v, out)
		out.append("])")
	else:
		raise TypeError(f"Cannot emit {type(value).__name__} as JavaScript")
```

</PySourceCode>

<div >

<PyParameter name={"value"} type={"Any"} value={null} />
<PyParameter name={"out"} type={"list[str]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>
<PyFunction name={"_emit_jsx_prop"} type={"(name, value, out) -> None"}>

Emit a single JSX prop.

<PySourceCode >

```python
def _emit_jsx_prop(name: str, value: Prop, out: list[str]) -> None:
	"""Emit a single JSX prop."""
	# Spread props
	if isinstance(value, Spread):
		out.append("{...")
		value.expr.emit(out)
		out.append("}")
		return
	# Expression nodes
	if isinstance(value, Expr):
		# String literals can use compact form
		if isinstance(value, Literal) and isinstance(value.value, str):
			out.append(name)
			out.append('="')
			out.append(_escape_jsx_attr(value.value))
			out.append('"')
		else:
			out.append(name)
			out.append("={")
			value.emit(out)
			out.append("}")
		return
	# Primitives
	if value is None:
		out.append(name)
		out.append("={null}")
		return
	if isinstance(value, bool):
		out.append(name)
		out.append("={true}" if value else "={false}")
		return
	if isinstance(value, str):
		out.append(name)
		out.append('="')
		out.append(_escape_jsx_attr(value))
		out.append('"')
		return
	if isinstance(value, (int, float)):
		out.append(name)
		out.append("={")
		out.append(str(value))
		out.append("}")
		return
	# Value
	if isinstance(value, Value):
		out.append(name)
		out.append("={")
		_emit_value(value.value, out)
		out.append("}")
		return
	# Nested Element (render prop)
	if isinstance(value, Element):
		out.append(name)
		out.append("={")
		value.emit(out)
		out.append("}")
		return
	# Callable - error
	if callable(value):
		raise TypeError("Cannot emit callable in transpile context")
	# Fallback for other data
	out.append(name)
	out.append("={")
	_emit_value(value, out)
	out.append("}")
```

</PySourceCode>

<div >

<PyParameter name={"name"} type={"str"} value={null} />
<PyParameter name={"value"} type={"Prop"} value={null} />
<PyParameter name={"out"} type={"list[str]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>
<PyFunction name={"_emit_jsx_child"} type={"(child, out) -> None"}>

Emit a single JSX child.

<PySourceCode >

```python
def _emit_jsx_child(child: Node, out: list[str]) -> None:
	"""Emit a single JSX child."""
	# Primitives
	if child is None or isinstance(child, bool):
		return  # React ignores None/bool
	if isinstance(child, str):
		out.append(_escape_jsx_text(child))
		return
	if isinstance(child, (int, float)):
		out.append("{")
		out.append(str(child))
		out.append("}")
		return
	if isinstance(child, dt.datetime):
		out.append("{")
		_emit_value(child, out)
		out.append("}")
		return
	# PulseNode - error
	if isinstance(child, PulseNode):
		fn_name = getattr(child.fn, "__name__", "unknown")
		raise TypeError(
			f"Cannot transpile PulseNode '{fn_name}'. "
			+ "Server components must be rendered, not transpiled."
		)
	# Element - recurse
	if isinstance(child, Element):
		child.emit(out)
		return
	# Spread - emit as {expr} without the spread operator (arrays are already iterable in JSX)
	if isinstance(child, Spread):
		out.append("{")
		child.expr.emit(out)
		out.append("}")
		return
	# Expr
	if isinstance(child, Expr):
		out.append("{")
		child.emit(out)
		out.append("}")
		return
	# Value
	if isinstance(child, Value):
		out.append("{")
		_emit_value(child.value, out)
		out.append("}")
		return
	raise TypeError(f"Cannot emit {type(child).__name__} as JSX child")
```

</PySourceCode>

<div >

<PyParameter name={"child"} type={"Node"} value={null} />
<PyParameter name={"out"} type={"list[str]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

</Tab>

</Tabs>