---
title: "Effects"
---

Effects run code in response to state changes—for logging, analytics, syncing with external systems, or any side effect that shouldn't happen during rendering.

## What are effects?

An effect is a function that:
1. Runs after state changes
2. Automatically tracks which state it reads
3. Re-runs when any tracked state changes
4. Can return a cleanup function

Effects are for **side effects**—things that happen outside of rendering, like logging, API calls, timers, or subscriptions.

## Effects in State classes

Use the `@ps.effect` decorator to define effects on your state:

```python
class ToggleState(ps.State):
    enabled: bool = False

    @ps.effect
    def log_changes(self):
        print(f"Toggle is now: {self.enabled}")
```

Pulse tracks what the effect reads. When `self.enabled` changes, the effect runs again automatically.

### With cleanup

Effects can return a cleanup function. This is useful for timers, subscriptions, or anything that needs to be torn down:

```python
class TimerState(ps.State):
    count: int = 0
    running: bool = False

    @ps.effect
    def start_timer(self):
        if not self.running:
            return

        timer_id = set_interval(lambda: self.tick(), 1000)

        def cleanup():
            clear_interval(timer_id)

        return cleanup

    def tick(self):
        self.count += 1
```

Cleanup runs:
- Before the effect runs again (when tracked dependencies change)
- When the state is disposed

## Effects in components

Use `ps.effects()` to register effects that depend on component state:

```python
@ps.component
def OrderTracker():
    with ps.init():
        state = OrderState()

    @ps.effect
    def log_status_changes():
        print(f"Order status: {state.status}")
        analytics.track("order_status_changed", status=state.status)

    ps.effects(log_status_changes)

    return ps.div(f"Status: {state.status}")
```

The effect definition (`@ps.effect`) and registration (`ps.effects()`) are separate steps. Define effects inline or in the state class, then register them with `ps.effects()`.

### Multiple effects

You can register multiple effects at once:

```python
@ps.component
def Dashboard():
    with ps.init():
        state = DashboardState()

    @ps.effect
    def sync_title():
        document.title = f"Dashboard - {state.page_name}"

    @ps.effect
    def log_page_views():
        analytics.page_view(state.page_name)

    ps.effects(sync_title, log_page_views)

    return ps.div(f"Page: {state.page_name}")
```

---

## Common mistakes

**Using effects for derived data.** Use computed values instead:

```python
# Don't do this
@ps.effect
def update_visible(self):
    self.visible_todos = [t for t in self.todos if not t.done]

# Do this instead
@ps.computed
def visible_todos(self):
    return [t for t in self.todos if not t.done]
```

Computeds are synchronous and cached. Effects run after rendering and can cause additional rerenders—leading to flickering or infinite loops.

**Forgetting cleanup.** If your effect creates timers, subscriptions, or event listeners, always return a cleanup function:

```python
@ps.effect
def subscribe(self):
    subscription = event_bus.subscribe(self.on_event)

    def cleanup():
        subscription.unsubscribe()

    return cleanup  # Don't forget this!
```

## See also

- [State and Reactivity](/docs/concepts/state) - the core state and reactivity system
- [Tutorial: Hooks](/docs/tutorial/06-hooks)
