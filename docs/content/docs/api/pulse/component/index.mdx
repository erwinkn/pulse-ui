---
title: "component"
---

Component definition and VDOM node types for Pulse.

This module provides the core component abstraction for building Pulse UIs,
including the `@component` decorator and the `Component` class.

<PyAttribute name={"P"} type={null} value={"ParamSpec('P')"} />

<PyAttribute name={"__all__"} type={null} value={"['Node', 'Children', 'Component', 'Element', 'Primitive', 'VDOMNode', 'component']"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"Component"} href={"/docs/api/pulse/component/Component"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"component"} type={"(fn=None, *, name=None) -> Component[P] | Callable[[Callable[P, Any]], Component[P]]"}>

Decorator that creates a Pulse component from a function.

Can be used with or without parentheses. The decorated function becomes
callable and returns a `PulseNode` when invoked.

<Callout title={"Example"} type={"example"}>

Basic usage::

        @ps.component
        def Card(title: str):
                return ps.div(ps.h3(title))

With custom name::

        @ps.component(name="MyCard")
        def card_impl(title: str):
                return ps.div(ps.h3(title))

With children (use `*children` parameter)::

        @ps.component
        def Container(*children):
                return ps.div(*children, className="container")

        # Children can be passed via subscript syntax:
        Container()[
                Card(title="First"),
                Card(title="Second"),
        ]

</Callout>

<PySourceCode >

```python
def component(
	fn: Callable[P, Any] | None = None, *, name: str | None = None
) -> Component[P] | Callable[[Callable[P, Any]], Component[P]]:
	"""Decorator that creates a Pulse component from a function.

	Can be used with or without parentheses. The decorated function becomes
	callable and returns a `PulseNode` when invoked.

	Args:
		fn: Function to wrap as a component. When used as `@component` without
			parentheses, this is the decorated function.
		name: Custom component name for debugging/dev tools. Defaults to the
			function's `__name__`.

	Returns:
		A `Component` instance if `fn` is provided, otherwise a decorator.

	Example:
		Basic usage::

			@ps.component
			def Card(title: str):
				return ps.div(ps.h3(title))

		With custom name::

			@ps.component(name="MyCard")
			def card_impl(title: str):
				return ps.div(ps.h3(title))

		With children (use `*children` parameter)::

			@ps.component
			def Container(*children):
				return ps.div(*children, className="container")

			# Children can be passed via subscript syntax:
			Container()[
				Card(title="First"),
				Card(title="Second"),
			]
	"""

	def decorator(fn: Callable[P, Any]) -> Component[P]:
		return Component(fn, name)

	if fn is not None:
		return decorator(fn)
	return decorator
```

</PySourceCode>

<div >

<PyParameter name={"fn"} type={"Callable[P, Any] | None"} value={"None"}>

Function to wrap as a component. When used as `@component` without
parentheses, this is the decorated function.

</PyParameter>
<PyParameter name={"name"} type={"str | None"} value={"None"}>

Custom component name for debugging/dev tools. Defaults to the
function's `__name__`.

</PyParameter>

</div>

<PyFunctionReturn type={"Component[P] | Callable[[Callable[P, Any]], Component[P]]"}>

A `Component` instance if `fn` is provided, otherwise a decorator.

</PyFunctionReturn>

</PyFunction>
<PyFunction name={"_takes_children"} type={"(fn) -> bool"}>

<PySourceCode >

```python
def _takes_children(fn: Callable[..., Any]) -> bool:
	try:
		sig = signature(fn)
	except (ValueError, TypeError):
		return False
	for p in sig.parameters.values():
		if p.kind == Parameter.VAR_POSITIONAL and p.name == "children":
			return True
	return False
```

</PySourceCode>

<div >

<PyParameter name={"fn"} type={"Callable[..., Any]"} value={null} />

</div>

<PyFunctionReturn type={"bool"} />

</PyFunction>
<PyFunction name={"_infer_component_name"} type={"(fn) -> str"}>

<PySourceCode >

```python
def _infer_component_name(fn: Callable[..., Any]) -> str:
	name = getattr(fn, "__name__", None)
	if name:
		return name
	return "Component"
```

</PySourceCode>

<div >

<PyParameter name={"fn"} type={"Callable[..., Any]"} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>
<PyFunction name={"_callable_qualname"} type={"(fn) -> str"}>

<PySourceCode >

```python
def _callable_qualname(fn: Callable[..., Any]) -> str:
	mod = getattr(fn, "__module__", "<unknown>")
	qname = getattr(fn, "__qualname__", getattr(fn, "__name__", "<callable>"))
	return f"{mod}.{qname}"
```

</PySourceCode>

<div >

<PyParameter name={"fn"} type={"Callable[..., Any]"} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>

</Tab>

</Tabs>