---
title: "runtime"
---

<PyAttribute name={"P"} type={null} value={"ParamSpec('P')"} />

<PyAttribute name={"S"} type={null} value={"TypeVar('S', covariant=True, bound=State)"} />

<PyAttribute name={"GLOBAL_STATES"} type={"dict[str, State]"} value={"{}"}>

Global dictionary storing state instances keyed by their qualified names.

</PyAttribute>

<PyAttribute name={"__all__"} type={null} value={"['RedirectInterrupt', 'NotFoundInterrupt', 'route', 'session', 'session_id', 'websocket_id', 'call_api', 'set_cookie', 'navigate', 'redirect', 'not_found', 'server_address', 'client_address', 'global_state', 'GLOBAL_STATES', 'GlobalStateAccessor']"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"RedirectInterrupt"} href={"/docs/api/pulse/hooks/runtime/RedirectInterrupt"} />
<Card title={"NotFoundInterrupt"} href={"/docs/api/pulse/hooks/runtime/NotFoundInterrupt"} />
<Card title={"GlobalStateAccessor"} href={"/docs/api/pulse/hooks/runtime/GlobalStateAccessor"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"route"} type={"() -> RouteContext"}>

Get the current route context.

<Callout title={"Example"} type={"example"}>

>>> def user_page():
...     r = ps.route()
...     user_id = r.params.get("user_id")  # From /users/:user_id
...     page = r.query.get("page", "1")    # From ?page=2
...     return m.Text(f"User \{user_id\}, Page \{page\}")

</Callout>

<PySourceCode >

```python
def route() -> RouteContext:
	"""Get the current route context.

	Returns:
		RouteContext: Object with access to route parameters, path, and query.

	Raises:
		RuntimeError: If called outside of a component render context.

	Example:
		>>> def user_page():
		...     r = ps.route()
		...     user_id = r.params.get("user_id")  # From /users/:user_id
		...     page = r.query.get("page", "1")    # From ?page=2
		...     return m.Text(f"User {user_id}, Page {page}")
	"""
	ctx = PulseContext.get()
	if not ctx or not ctx.route:
		raise RuntimeError(
			"`pulse.route` can only be called within a component during rendering."
		)
	return ctx.route
```

</PySourceCode>

<PyFunctionReturn type={"pulse.routing.RouteContext"}>

Object with access to route parameters, path, and query.

</PyFunctionReturn>

</PyFunction>
<PyFunction name={"session"} type={"() -> ReactiveDict[str, Any]"}>

Get the current user session data.

<Callout title={"Example"} type={"example"}>

>>> def my_component():
...     sess = ps.session()
...     sess["last_visited"] = datetime.now()
...     return m.Text(f"Visits: \{sess.get('visit_count', 0)\}")

</Callout>

<PySourceCode >

```python
def session() -> ReactiveDict[str, Any]:
	"""Get the current user session data.

	Returns:
		ReactiveDict[str, Any]: Reactive dictionary of session data that persists
			across page navigations.

	Raises:
		RuntimeError: If called outside of a session context.

	Example:
		>>> def my_component():
		...     sess = ps.session()
		...     sess["last_visited"] = datetime.now()
		...     return m.Text(f"Visits: {sess.get('visit_count', 0)}")
	"""
	ctx = PulseContext.get()
	if not ctx.session:
		raise RuntimeError("Could not resolve user session")
	return ctx.session.data
```

</PySourceCode>

<PyFunctionReturn type={"pulse.reactive_extensions.ReactiveDict"}>

ReactiveDict[str, Any]: Reactive dictionary of session data that persists
across page navigations.

</PyFunctionReturn>

</PyFunction>
<PyFunction name={"session_id"} type={"() -> str"}>

Get the current session identifier.

<PySourceCode >

```python
def session_id() -> str:
	"""Get the current session identifier.

	Returns:
		str: Unique identifier for the current user session.

	Raises:
		RuntimeError: If called outside of a session context.
	"""
	ctx = PulseContext.get()
	if not ctx.session:
		raise RuntimeError("Could not resolve user session")
	return ctx.session.sid
```

</PySourceCode>

<PyFunctionReturn type={"str"}>

Unique identifier for the current user session.

</PyFunctionReturn>

</PyFunction>
<PyFunction name={"websocket_id"} type={"() -> str"}>

Get the current WebSocket connection identifier.

<PySourceCode >

```python
def websocket_id() -> str:
	"""Get the current WebSocket connection identifier.

	Returns:
		str: Unique identifier for the current WebSocket connection.

	Raises:
		RuntimeError: If called outside of a WebSocket session context.
	"""
	ctx = PulseContext.get()
	if not ctx.render:
		raise RuntimeError("Could not resolve WebSocket session")
	return ctx.render.id
```

</PySourceCode>

<PyFunctionReturn type={"str"}>

Unique identifier for the current WebSocket connection.

</PyFunctionReturn>

</PyFunction>
<PyFunction name={"call_api"} type={"(path, *, method='POST', headers=None, body=None, credentials='include') -> dict[str, Any]"}>

Make an API call through the client browser.

This function sends a request to the specified path via the client's browser,
which is useful for calling third-party APIs that require browser cookies
or credentials.

<PySourceCode >

```python
async def call_api(
	path: str,
	*,
	method: str = "POST",
	headers: Mapping[str, str] | None = None,
	body: Any | None = None,
	credentials: str = "include",
) -> dict[str, Any]:
	"""Make an API call through the client browser.

	This function sends a request to the specified path via the client's browser,
	which is useful for calling third-party APIs that require browser cookies
	or credentials.

	Args:
		path: The URL path to call.
		method: HTTP method (default: "POST").
		headers: Optional HTTP headers to include in the request.
		body: Optional request body (will be JSON serialized).
		credentials: Credential mode for the request (default: "include").

	Returns:
		dict[str, Any]: The JSON response from the API.

	Raises:
		RuntimeError: If called outside of a Pulse callback context.
	"""
	ctx = PulseContext.get()
	if ctx.render is None:
		raise RuntimeError("call_api() must be invoked inside a Pulse callback context")

	return await ctx.render.call_api(
		path,
		method=method,
		headers=dict(headers or {}),
		body=body,
		credentials=credentials,
	)
```

</PySourceCode>

<div >

<PyParameter name={"path"} type={"str"} value={undefined}>

The URL path to call.

</PyParameter>
<PyParameter name={"method"} type={"str"} value={"'POST'"}>

HTTP method (default: "POST").

</PyParameter>
<PyParameter name={"headers"} type={"Mapping[str, str] | None"} value={"None"}>

Optional HTTP headers to include in the request.

</PyParameter>
<PyParameter name={"body"} type={"Any | None"} value={"None"}>

Optional request body (will be JSON serialized).

</PyParameter>
<PyParameter name={"credentials"} type={"str"} value={"'include'"}>

Credential mode for the request (default: "include").

</PyParameter>

</div>

<PyFunctionReturn type={"dict"}>

dict[str, Any]: The JSON response from the API.

</PyFunctionReturn>

</PyFunction>
<PyFunction name={"set_cookie"} type={"(name, value, domain=None, secure=True, samesite='lax', max_age_seconds=7 * 24 * 3600) -> None"}>

Set a cookie on the client.

<PySourceCode >

```python
async def set_cookie(
	name: str,
	value: str,
	domain: str | None = None,
	secure: bool = True,
	samesite: Literal["lax", "strict", "none"] = "lax",
	max_age_seconds: int = 7 * 24 * 3600,
) -> None:
	"""Set a cookie on the client.

	Args:
		name: The cookie name.
		value: The cookie value.
		domain: Optional domain for the cookie.
		secure: Whether the cookie should only be sent over HTTPS (default: True).
		samesite: SameSite attribute ("lax", "strict", or "none"; default: "lax").
		max_age_seconds: Cookie lifetime in seconds (default: 7 days).

	Raises:
		RuntimeError: If called outside of a session context.
	"""
	ctx = PulseContext.get()
	if ctx.session is None:
		raise RuntimeError("Could not resolve the user session")
	ctx.session.set_cookie(
		name=name,
		value=value,
		domain=domain,
		secure=secure,
		samesite=samesite,
		max_age_seconds=max_age_seconds,
	)
```

</PySourceCode>

<div >

<PyParameter name={"name"} type={"str"} value={undefined}>

The cookie name.

</PyParameter>
<PyParameter name={"value"} type={"str"} value={undefined}>

The cookie value.

</PyParameter>
<PyParameter name={"domain"} type={"str | None"} value={"None"}>

Optional domain for the cookie.

</PyParameter>
<PyParameter name={"secure"} type={"bool"} value={"True"}>

Whether the cookie should only be sent over HTTPS (default: True).

</PyParameter>
<PyParameter name={"samesite"} type={"Literal['lax', 'strict', 'none']"} value={"'lax'"}>

SameSite attribute ("lax", "strict", or "none"; default: "lax").

</PyParameter>
<PyParameter name={"max_age_seconds"} type={"int"} value={"7 * 24 * 3600"}>

Cookie lifetime in seconds (default: 7 days).

</PyParameter>

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>
<PyFunction name={"navigate"} type={"(path, *, replace=False, hard=False) -> None"}>

Navigate to a new URL.

Triggers client-side navigation to the specified path. By default, uses
client-side routing which is faster and preserves application state.

<Callout title={"Example"} type={"example"}>

>>> async def handle_login():
...     await api.login(username, password)
...     ps.navigate("/dashboard")

</Callout>

<PySourceCode >

```python
def navigate(path: str, *, replace: bool = False, hard: bool = False) -> None:
	"""Navigate to a new URL.

	Triggers client-side navigation to the specified path. By default, uses
	client-side routing which is faster and preserves application state.

	Args:
		path: Destination URL to navigate to.
		replace: If True, replaces the current history entry instead of pushing
			a new one (default: False).
		hard: If True, performs a full page reload instead of client-side
			navigation (default: False).

	Raises:
		RuntimeError: If called outside of a Pulse callback context.

	Example:
		>>> async def handle_login():
		...     await api.login(username, password)
		...     ps.navigate("/dashboard")
	"""
	ctx = PulseContext.get()
	if ctx.render is None:
		raise RuntimeError("navigate() must be invoked inside a Pulse callback context")
	ctx.render.send(
		{"type": "navigate_to", "path": path, "replace": replace, "hard": hard}
	)
```

</PySourceCode>

<div >

<PyParameter name={"path"} type={"str"} value={undefined}>

Destination URL to navigate to.

</PyParameter>
<PyParameter name={"replace"} type={"bool"} value={"False"}>

If True, replaces the current history entry instead of pushing
a new one (default: False).

</PyParameter>
<PyParameter name={"hard"} type={"bool"} value={"False"}>

If True, performs a full page reload instead of client-side
navigation (default: False).

</PyParameter>

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>
<PyFunction name={"redirect"} type={"(path, *, replace=False) -> NoReturn"}>

Redirect during render (throws exception to interrupt render).

Unlike ``navigate()``, this function is intended for use during the render
phase to immediately redirect before the component finishes rendering.
It raises a ``RedirectInterrupt`` exception that is caught by the framework.

<Callout title={"Example"} type={"example"}>

>>> def protected_page():
...     user = get_current_user()
...     if not user:
...         ps.redirect("/login")  # Interrupts render
...
...     return m.Text(f"Welcome, \{user.name\}")

</Callout>

<PySourceCode >

```python
def redirect(path: str, *, replace: bool = False) -> NoReturn:
	"""Redirect during render (throws exception to interrupt render).

	Unlike ``navigate()``, this function is intended for use during the render
	phase to immediately redirect before the component finishes rendering.
	It raises a ``RedirectInterrupt`` exception that is caught by the framework.

	Args:
		path: Destination URL to redirect to.
		replace: If True, replaces the current history entry instead of pushing
			a new one (default: False).

	Raises:
		RuntimeError: If called outside of component render.
		RedirectInterrupt: Always raised to interrupt the render.

	Example:
		>>> def protected_page():
		...     user = get_current_user()
		...     if not user:
		...         ps.redirect("/login")  # Interrupts render
		...
		...     return m.Text(f"Welcome, {user.name}")
	"""
	ctx = HOOK_CONTEXT.get()
	if not ctx:
		raise RuntimeError("redirect() must be invoked during component render")
	raise RedirectInterrupt(path, replace=replace)
```

</PySourceCode>

<div >

<PyParameter name={"path"} type={"str"} value={undefined}>

Destination URL to redirect to.

</PyParameter>
<PyParameter name={"replace"} type={"bool"} value={"False"}>

If True, replaces the current history entry instead of pushing
a new one (default: False).

</PyParameter>

</div>

<PyFunctionReturn type={"typing.NoReturn"} />

</PyFunction>
<PyFunction name={"not_found"} type={"() -> NoReturn"}>

Trigger 404 during render (throws exception to interrupt render).

Interrupts the current render and displays the 404 not found page.
Raises a ``NotFoundInterrupt`` exception that is caught by the framework.

<Callout title={"Example"} type={"example"}>

>>> def user_page():
...     r = ps.route()
...     user = get_user(r.params["id"])
...     if not user:
...         ps.not_found()  # Shows 404 page
...
...     return m.Text(user.name)

</Callout>

<PySourceCode >

```python
def not_found() -> NoReturn:
	"""Trigger 404 during render (throws exception to interrupt render).

	Interrupts the current render and displays the 404 not found page.
	Raises a ``NotFoundInterrupt`` exception that is caught by the framework.

	Raises:
		RuntimeError: If called outside of component render.
		NotFoundInterrupt: Always raised to trigger 404 page.

	Example:
		>>> def user_page():
		...     r = ps.route()
		...     user = get_user(r.params["id"])
		...     if not user:
		...         ps.not_found()  # Shows 404 page
		...
		...     return m.Text(user.name)
	"""
	ctx = HOOK_CONTEXT.get()
	if not ctx:
		raise RuntimeError("not_found() must be invoked during component render")
	raise NotFoundInterrupt()
```

</PySourceCode>

<PyFunctionReturn type={"typing.NoReturn"} />

</PyFunction>
<PyFunction name={"server_address"} type={"() -> str"}>

Get the server's public address.

<PySourceCode >

```python
def server_address() -> str:
	"""Get the server's public address.

	Returns:
		str: The server's public address (e.g., "https://example.com").

	Raises:
		RuntimeError: If called outside of a Pulse render/callback context
			or if the server address is not configured.
	"""
	ctx = PulseContext.get()
	if ctx.render is None:
		raise RuntimeError(
			"server_address() must be called inside a Pulse render/callback context"
		)
	if not ctx.render.server_address:
		raise RuntimeError(
			"Server address unavailable. Ensure App.run_codegen/asgi_factory configured server_address."
		)
	return ctx.render.server_address
```

</PySourceCode>

<PyFunctionReturn type={"str"}>

The server's public address (e.g., "https://example.com").

</PyFunctionReturn>

</PyFunction>
<PyFunction name={"client_address"} type={"() -> str"}>

Get the client's IP address.

<PySourceCode >

```python
def client_address() -> str:
	"""Get the client's IP address.

	Returns:
		str: The client's IP address.

	Raises:
		RuntimeError: If called outside of a Pulse render/callback context
			or if the client address is not available.
	"""
	ctx = PulseContext.get()
	if ctx.render is None:
		raise RuntimeError(
			"client_address() must be called inside a Pulse render/callback context"
		)
	if not ctx.render.client_address:
		raise RuntimeError(
			"Client address unavailable. It is set during prerender or socket connect."
		)
	return ctx.render.client_address
```

</PySourceCode>

<PyFunctionReturn type={"str"}>

The client's IP address.

</PyFunctionReturn>

</PyFunction>
<PyFunction name={"global_state"} type={"(factory, key=None) -> GlobalStateAccessor[P, S]"}>

Create a globally shared state accessor.

Creates a decorator or callable that provides access to a shared state
instance. The state is shared across all components that use the same
accessor.

Can be used as a decorator on a State class or with a factory function.

<Callout title={"Example"} type={"example"}>

>>> @ps.global_state
... class AppSettings(ps.State):
...     theme: str = "light"
...     language: str = "en"
...
>>> def settings_panel():
...     settings = AppSettings()  # Same instance across all components
...     return m.Select(
...         value=settings.theme,
...         data=["light", "dark"],
...         on_change=lambda v: setattr(settings, "theme", v),
...     )

With instance ID for per-entity global state:

>>> @ps.global_state
... class UserCache(ps.State):
...     data: dict = \{\}
...
>>> def user_profile(user_id: str):
...     cache = UserCache(id=user_id)  # Shared per user_id
...     return m.Text(cache.data.get("name", "Loading..."))

</Callout>

<PySourceCode >

```python
def global_state(
	factory: Callable[P, S] | type[S], key: str | None = None
) -> GlobalStateAccessor[P, S]:
	"""Create a globally shared state accessor.

	Creates a decorator or callable that provides access to a shared state
	instance. The state is shared across all components that use the same
	accessor.

	Can be used as a decorator on a State class or with a factory function.

	Args:
		factory: State class or factory function that creates the state instance.
		key: Optional custom key for the global state. If not provided, a key
			is derived from the factory's module and qualified name.

	Returns:
		GlobalStateAccessor: A callable that returns the shared state instance.
			Call with ``id=`` parameter for per-entity global state.

	Example:
		>>> @ps.global_state
		... class AppSettings(ps.State):
		...     theme: str = "light"
		...     language: str = "en"
		...
		>>> def settings_panel():
		...     settings = AppSettings()  # Same instance across all components
		...     return m.Select(
		...         value=settings.theme,
		...         data=["light", "dark"],
		...         on_change=lambda v: setattr(settings, "theme", v),
		...     )

		With instance ID for per-entity global state:

		>>> @ps.global_state
		... class UserCache(ps.State):
		...     data: dict = {}
		...
		>>> def user_profile(user_id: str):
		...     cache = UserCache(id=user_id)  # Shared per user_id
		...     return m.Text(cache.data.get("name", "Loading..."))
	"""
	if isinstance(factory, type):
		cls = factory

		def _mk(*args: P.args, **kwargs: P.kwargs) -> S:
			return cast(S, cls(*args, **kwargs))

		default_key = f"{cls.__module__}:{cls.__qualname__}"
		mk = _mk
	else:
		default_key = f"{factory.__module__}:{factory.__qualname__}"
		mk = factory

	base_key = key or default_key

	def accessor(id: str | None = None, *args: P.args, **kwargs: P.kwargs) -> S:
		if id is not None:
			shared_key = f"{base_key}|{id}"
			inst = cast(S | None, GLOBAL_STATES.get(shared_key))
			if inst is None:
				inst = mk(*args, **kwargs)
				GLOBAL_STATES[shared_key] = inst
			return inst

		ctx = PulseContext.get()
		if ctx.render is None:
			raise RuntimeError(
				"ps.global_state must be called inside a Pulse render/callback context"
			)
		return cast(
			S, ctx.render.get_global_state(base_key, lambda: mk(*args, **kwargs))
		)

	return accessor
```

</PySourceCode>

<div >

<PyParameter name={"factory"} type={"Callable[P, S] | type[S]"} value={undefined}>

State class or factory function that creates the state instance.

</PyParameter>
<PyParameter name={"key"} type={"str | None"} value={"None"}>

Optional custom key for the global state. If not provided, a key
is derived from the factory's module and qualified name.

</PyParameter>

</div>

<PyFunctionReturn type={"pulse.hooks.runtime.GlobalStateAccessor"}>

A callable that returns the shared state instance.
Call with ``id=`` parameter for per-entity global state.

</PyFunctionReturn>

</PyFunction>

</Tab>

</Tabs>