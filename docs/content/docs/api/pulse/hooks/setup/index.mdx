---
title: "setup"
---

<PyAttribute name={"P"} type={null} value={"ParamSpec('P')"} />

<PyAttribute name={"T"} type={null} value={"TypeVar('T')"} />

<PyAttribute name={"__all__"} type={null} value={"['setup', 'setup_key', 'SetupHookState']"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"SetupHookState"} href={"/docs/api/pulse/hooks/setup/SetupHookState"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"_setup_factory"} type={"()"}>

<PySourceCode >

```python
def _setup_factory():
	return SetupHookState()
```

</PySourceCode>

<PyFunctionReturn type={null} />

</PyFunction>
<PyFunction name={"setup"} type={"(init_func, *args, **kwargs) -> T"}>

One-time initialization that persists across renders.

Calls the init function on first render and caches the result. On subsequent
renders, returns the cached value without re-running the function.

This is the lower-level alternative to ``ps.init()`` that doesn't require
AST rewriting and works in all environments.

<Callout title={"Example"} type={"example"}>

>>> @ps.component
... def Counter():
...     def init():
...         return CounterState(), expensive_calculation()
...
...     state, value = ps.setup(init)
...
...     return ps.div(f"Count: \{state.count\}")

</Callout>

<Callout title={"Notes"} type={"notes"}>

- ``ps.init()`` is syntactic sugar that transforms into ``ps.setup()`` calls
- Use ``ps.setup()`` directly when AST rewriting is problematic
- Arguments must be consistent across renders (same count and names)

</Callout>

<PySourceCode >

```python
def setup(init_func: Callable[P, T], *args: P.args, **kwargs: P.kwargs) -> T:
	"""One-time initialization that persists across renders.

	Calls the init function on first render and caches the result. On subsequent
	renders, returns the cached value without re-running the function.

	This is the lower-level alternative to ``ps.init()`` that doesn't require
	AST rewriting and works in all environments.

	Args:
		init_func: Function to call on first render. Its return value is cached.
		*args: Positional arguments passed to init_func. Changes to these are
			tracked via reactive signals.
		**kwargs: Keyword arguments passed to init_func. Changes to these are
			tracked via reactive signals.

	Returns:
		The value returned by init_func (cached on first render).

	Raises:
		RuntimeError: If called more than once per component render.
		RuntimeError: If the number or names of arguments change between renders.

	Example:
		>>> @ps.component
		... def Counter():
		...     def init():
		...         return CounterState(), expensive_calculation()
		...
		...     state, value = ps.setup(init)
		...
		...     return ps.div(f"Count: {state.count}")

	Notes:
		- ``ps.init()`` is syntactic sugar that transforms into ``ps.setup()`` calls
		- Use ``ps.setup()`` directly when AST rewriting is problematic
		- Arguments must be consistent across renders (same count and names)
	"""
	state = _setup_hook()
	state.ensure_not_called()

	key = state.consume_pending_key()
	args_tuple = tuple(args)
	kwargs_dict = dict(kwargs)

	if state.initialized:
		if key is not None and key != state.key:
			state.initialize(init_func, args_tuple, kwargs_dict, key)
			state.mark_called()
			return cast(T, state.value)
		state.ensure_signature(args_tuple, kwargs_dict)
		state.update_args(args_tuple, kwargs_dict)
		if key is not None:
			state.key = key
		state.mark_called()
		return cast(T, state.value)

	state.initialize(init_func, args_tuple, kwargs_dict, key)
	state.mark_called()
	return cast(T, state.value)
```

</PySourceCode>

<div >

<PyParameter name={"init_func"} type={"Callable[P, T]"} value={undefined}>

Function to call on first render. Its return value is cached.

</PyParameter>
<PyParameter name={"args"} type={"P.args"} value={"()"} />
<PyParameter name={"kwargs"} type={"P.kwargs"} value={"{}"} />

</div>

<PyFunctionReturn type={"pulse.hooks.setup.T"}>

The value returned by init_func (cached on first render).

</PyFunctionReturn>

</PyFunction>
<PyFunction name={"setup_key"} type={"(key) -> None"}>

Set a key for the next setup call to control re-initialization.

When the key changes between renders, the setup function is re-run
and a new value is created. This is useful for resetting state when
a prop changes.

<Callout title={"Example"} type={"example"}>

>>> def user_profile(user_id: str):
...     ps.setup_key(user_id)  # Re-run setup when user_id changes
...     data = ps.setup(lambda: fetch_user_data(user_id))
...     return m.Text(data.name)

</Callout>

<PySourceCode >

```python
def setup_key(key: str) -> None:
	"""Set a key for the next setup call to control re-initialization.

	When the key changes between renders, the setup function is re-run
	and a new value is created. This is useful for resetting state when
	a prop changes.

	Args:
		key: String key that, when changed, triggers re-initialization
			of the subsequent setup call.

	Raises:
		TypeError: If key is not a string.
		RuntimeError: If called after setup() in the same render.

	Example:
		>>> def user_profile(user_id: str):
		...     ps.setup_key(user_id)  # Re-run setup when user_id changes
		...     data = ps.setup(lambda: fetch_user_data(user_id))
		...     return m.Text(data.name)
	"""
	if not isinstance(key, str):
		raise TypeError("setup_key() requires a string key")
	state = _setup_hook()
	if state.called_this_render:
		raise RuntimeError("setup_key() must be called before setup() in a render")
	state.set_pending_key(key)
```

</PySourceCode>

<div >

<PyParameter name={"key"} type={"str"} value={undefined}>

String key that, when changed, triggers re-initialization
of the subsequent setup call.

</PyParameter>

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

</Tab>

</Tabs>