---
title: "InfiniteQueryProperty"
---

Descriptor for state-bound infinite queries created by the @infinite_query decorator.

InfiniteQueryProperty is the return type of the ``@infinite_query`` decorator.
It acts as a descriptor that creates and manages InfiniteQueryResult instances
for each State object.

When accessed on a State instance, returns an InfiniteQueryResult with reactive
properties for pagination state and methods for fetching pages.

Required decorators:
        - ``@infinite_query_prop.key``: Define the query key (required).
        - ``@infinite_query_prop.get_next_page_param``: Define how to get next page param.

Optional decorators:
        - ``@infinite_query_prop.get_previous_page_param``: For bi-directional pagination.
        - ``@infinite_query_prop.on_success``: Handle successful fetch.
        - ``@infinite_query_prop.on_error``: Handle fetch errors.

Example:
        ::

                class FeedState(ps.State):
                    feed_type: str = "home"

                    @ps.infinite_query(initial_page_param=None)
                    async def posts(self, cursor: str | None) -> list[Post]:
                        return await api.get_posts(cursor=cursor)

                    @posts.key
                    def _posts_key(self):
                        return ("feed", self.feed_type)

                    @posts.get_next_page_param
                    def _next_cursor(self, pages: list[Page]) -> str | None:
                        if not pages:
                            return None
                        last = pages[-1]
                        return last.data[-1].id if last.data else None

## Attributes

<PyAttribute name={"name"} type={"str"} value={"name"} />

## Functions

<PyFunction name={"__init__"} type={"(self, name, fetch_fn, *, initial_page_param, max_pages, stale_time, gc_time, refetch_interval=None, keep_previous_data, retries, retry_delay, initial_data_updated_at=None, enabled=True, fetch_on_mount=True, key=None)"}>

<PySourceCode >

```python
def __init__(
	self,
	name: str,
	fetch_fn: "Callable[[TState, TParam], Awaitable[T]]",
	*,
	initial_page_param: TParam,
	max_pages: int,
	stale_time: float,
	gc_time: float,
	refetch_interval: float | None = None,
	keep_previous_data: bool,
	retries: int,
	retry_delay: float,
	initial_data_updated_at: float | dt.datetime | None = None,
	enabled: bool = True,
	fetch_on_mount: bool = True,
	key: QueryKey | Callable[[TState], QueryKey] | None = None,
):
	self.name = name
	self._fetch_fn = fetch_fn
	self._initial_page_param = initial_page_param
	self._get_next_page_param = None
	self._get_previous_page_param = None
	self._max_pages = max_pages
	self._keep_previous_data = keep_previous_data
	self._stale_time = stale_time
	self._gc_time = gc_time
	self._refetch_interval = refetch_interval
	self._retries = retries
	self._retry_delay = retry_delay
	self._on_success_fn = None
	self._on_error_fn = None
	self._key = key
	self._initial_data_updated_at = initial_data_updated_at
	self._enabled = enabled
	self._fetch_on_mount = fetch_on_mount
	self._priv_result = f"__inf_query_{name}"
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"name"} type={"str"} value={null} />
<PyParameter name={"fetch_fn"} type={"Callable[[TState, TParam], Awaitable[T]]"} value={null} />
<PyParameter name={"initial_page_param"} type={"TParam"} value={null} />
<PyParameter name={"max_pages"} type={"int"} value={null} />
<PyParameter name={"stale_time"} type={"float"} value={null} />
<PyParameter name={"gc_time"} type={"float"} value={null} />
<PyParameter name={"refetch_interval"} type={"float | None"} value={"None"} />
<PyParameter name={"keep_previous_data"} type={"bool"} value={null} />
<PyParameter name={"retries"} type={"int"} value={null} />
<PyParameter name={"retry_delay"} type={"float"} value={null} />
<PyParameter name={"initial_data_updated_at"} type={"float | dt.datetime | None"} value={"None"} />
<PyParameter name={"enabled"} type={"bool"} value={"True"} />
<PyParameter name={"fetch_on_mount"} type={"bool"} value={"True"} />
<PyParameter name={"key"} type={"QueryKey | Callable[[TState], QueryKey] | None"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"key"} type={"(self, fn)"}>

<PySourceCode >

```python
def key(self, fn: Callable[[TState], QueryKey]):
	if self._key is not None:
		raise RuntimeError(
			f"Cannot use @{self.name}.key decorator when a key is already provided to @infinite_query(key=...)."
		)
	self._key = fn
	return fn
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fn"} type={"Callable[[TState], QueryKey]"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"on_success"} type={"(self, fn)"}>

<PySourceCode >

```python
def on_success(self, fn: OnSuccessFn[TState, list[T]]):
	if self._on_success_fn is not None:
		raise RuntimeError(
			f"Duplicate on_success() decorator for infinite query '{self.name}'. Only one is allowed."
		)
	self._on_success_fn = fn  # pyright: ignore[reportAttributeAccessIssue]
	return fn
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fn"} type={"OnSuccessFn[TState, list[T]]"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"on_error"} type={"(self, fn)"}>

<PySourceCode >

```python
def on_error(self, fn: OnErrorFn[TState]):
	if self._on_error_fn is not None:
		raise RuntimeError(
			f"Duplicate on_error() decorator for infinite query '{self.name}'. Only one is allowed."
		)
	self._on_error_fn = fn  # pyright: ignore[reportAttributeAccessIssue]
	return fn
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fn"} type={"OnErrorFn[TState]"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"get_next_page_param"} type={"(self, fn) -> Callable[[TState, list[Page[T, TParam]]], TParam | None]"}>

<PySourceCode >

```python
def get_next_page_param(
	self,
	fn: Callable[[TState, list[Page[T, TParam]]], TParam | None],
) -> Callable[[TState, list[Page[T, TParam]]], TParam | None]:
	if self._get_next_page_param is not None:
		raise RuntimeError(
			f"Duplicate get_next_page_param() decorator for infinite query '{self.name}'. Only one is allowed."
		)
	self._get_next_page_param = fn
	return fn
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fn"} type={"Callable[[TState, list[Page[T, TParam]]], TParam | None]"} value={null} />

</div>

<PyFunctionReturn type={"collections.abc.Callable[[pulse.queries.infinite_query.TState, list[pulse.queries.infinite_query.Page[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam]]], pulse.queries.infinite_query.TParam | None]"} />

</PyFunction>

<PyFunction name={"get_previous_page_param"} type={"(self, fn) -> Callable[[TState, list[Page[T, TParam]]], TParam | None]"}>

<PySourceCode >

```python
def get_previous_page_param(
	self,
	fn: Callable[[TState, list[Page[T, TParam]]], TParam | None],
) -> Callable[[TState, list[Page[T, TParam]]], TParam | None]:
	if self._get_previous_page_param is not None:
		raise RuntimeError(
			f"Duplicate get_previous_page_param() decorator for infinite query '{self.name}'. Only one is allowed."
		)
	self._get_previous_page_param = fn
	return fn
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fn"} type={"Callable[[TState, list[Page[T, TParam]]], TParam | None]"} value={null} />

</div>

<PyFunctionReturn type={"collections.abc.Callable[[pulse.queries.infinite_query.TState, list[pulse.queries.infinite_query.Page[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam]]], pulse.queries.infinite_query.TParam | None]"} />

</PyFunction>

<PyFunction name={"initialize"} type={"(self, state, name) -> InfiniteQueryResult[T, TParam]"}>

<PySourceCode >

```python
@override
def initialize(self, state: Any, name: str) -> InfiniteQueryResult[T, TParam]:
	result: InfiniteQueryResult[T, TParam] | None = getattr(
		state, self._priv_result, None
	)
	if result:
		return result

	if self._get_next_page_param is None:
		raise RuntimeError(
			f"get_next_page_param must be set via @{self.name}.get_next_page_param decorator"
		)

	fetch_fn = bind_state(state, self._fetch_fn)

	next_fn = bind_state(state, self._get_next_page_param)
	prev_fn = (
		bind_state(state, self._get_previous_page_param)
		if self._get_previous_page_param
		else None
	)

	if self._key is None:
		raise RuntimeError(
			f"key is required for infinite query '{self.name}'. Provide a key via @infinite_query(key=...) or @{self.name}.key decorator."
		)
	query = self._resolve_keyed(
		state, fetch_fn, next_fn, prev_fn, self._initial_data_updated_at
	)

	on_success = None
	if self._on_success_fn:
		bound_fn = bind_state(state, self._on_success_fn)

		async def on_success_wrapper(data: list[Page[T, TParam]]):
			await maybe_await(call_flexible(bound_fn, [p.data for p in data]))

		on_success = on_success_wrapper

	result = InfiniteQueryResult(
		query=query,
		fetch_fn=fetch_fn,
		stale_time=self._stale_time,
		keep_previous_data=self._keep_previous_data,
		gc_time=self._gc_time,
		refetch_interval=self._refetch_interval,
		on_success=on_success,
		on_error=bind_state(state, self._on_error_fn)
		if self._on_error_fn
		else None,
		enabled=self._enabled,
		fetch_on_mount=self._fetch_on_mount,
	)

	setattr(state, self._priv_result, result)
	return result
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"state"} type={"Any"} value={null} />
<PyParameter name={"name"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"pulse.queries.infinite_query.InfiniteQueryResult[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam]"} />

</PyFunction>

<PyFunction name={"_resolve_keyed"} type={"(self, state, fetch_fn, next_fn, prev_fn, initial_data_updated_at) -> Computed[InfiniteQuery[T, TParam]]"}>

<PySourceCode >

```python
def _resolve_keyed(
	self,
	state: TState,
	fetch_fn: Callable[[TParam], Awaitable[T]],
	next_fn: Callable[[list[Page[T, TParam]]], TParam | None],
	prev_fn: Callable[[list[Page[T, TParam]]], TParam | None] | None,
	initial_data_updated_at: float | dt.datetime | None,
) -> Computed[InfiniteQuery[T, TParam]]:
	assert self._key is not None

	# Create a Computed for the key - passthrough for constant keys, reactive for function keys
	if callable(self._key):
		key_computed = Computed(
			bind_state(state, self._key), name=f"inf_query.key.{self.name}"
		)
	else:
		constant_key = self._key  # ensure a constant reference
		key_computed = Computed(
			lambda: constant_key, name=f"inf_query.key.{self.name}"
		)

	render = PulseContext.get().render
	if render is None:
		raise RuntimeError("No render session available")
	store = render.query_store

	def query() -> InfiniteQuery[T, TParam]:
		key = key_computed()
		return cast(
			InfiniteQuery[T, TParam],
			store.ensure_infinite(
				key,
				initial_page_param=self._initial_page_param,
				get_next_page_param=next_fn,
				get_previous_page_param=prev_fn,
				max_pages=self._max_pages,
				gc_time=self._gc_time,
				retries=self._retries,
				retry_delay=self._retry_delay,
				initial_data_updated_at=initial_data_updated_at,
			),
		)

	return Computed(query, name=f"inf_query.{self.name}")
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"state"} type={"TState"} value={null} />
<PyParameter name={"fetch_fn"} type={"Callable[[TParam], Awaitable[T]]"} value={null} />
<PyParameter name={"next_fn"} type={"Callable[[list[Page[T, TParam]]], TParam | None]"} value={null} />
<PyParameter name={"prev_fn"} type={"Callable[[list[Page[T, TParam]]], TParam | None] | None"} value={null} />
<PyParameter name={"initial_data_updated_at"} type={"float | dt.datetime | None"} value={null} />

</div>

<PyFunctionReturn type={"pulse.reactive.Computed[pulse.queries.infinite_query.InfiniteQuery[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam]]"} />

</PyFunction>

<PyFunction name={"__get__"} type={"(self, obj, objtype=None) -> InfiniteQueryResult[T, TParam]"}>

<PySourceCode >

```python
def __get__(self, obj: Any, objtype: Any = None) -> InfiniteQueryResult[T, TParam]:
	if obj is None:
		return self  # pyright: ignore[reportReturnType]
	return self.initialize(obj, self.name)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"obj"} type={"Any"} value={null} />
<PyParameter name={"objtype"} type={"Any"} value={"None"} />

</div>

<PyFunctionReturn type={"pulse.queries.infinite_query.InfiniteQueryResult[pulse.queries.infinite_query.T, pulse.queries.infinite_query.TParam]"} />

</PyFunction>