---
title: "infinite_query"
---

<PyAttribute name={"T"} type={null} value={"TypeVar('T')"} />

<PyAttribute name={"TParam"} type={null} value={"TypeVar('TParam')"} />

<PyAttribute name={"TState"} type={null} value={"TypeVar('TState', bound=State)"} />

<PyAttribute name={"Action"} type={null} value={"FetchNext[T, TParam] | FetchPrevious[T, TParam] | Refetch[T, TParam] | RefetchPage[T, TParam]"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"Page"} href={"/docs/api/pulse/queries/infinite_query/Page"} />
<Card title={"FetchNext"} href={"/docs/api/pulse/queries/infinite_query/FetchNext"} />
<Card title={"FetchPrevious"} href={"/docs/api/pulse/queries/infinite_query/FetchPrevious"} />
<Card title={"Refetch"} href={"/docs/api/pulse/queries/infinite_query/Refetch"} />
<Card title={"RefetchPage"} href={"/docs/api/pulse/queries/infinite_query/RefetchPage"} />
<Card title={"InfiniteQueryConfig"} href={"/docs/api/pulse/queries/infinite_query/InfiniteQueryConfig"} />
<Card title={"InfiniteQuery"} href={"/docs/api/pulse/queries/infinite_query/InfiniteQuery"} />
<Card title={"InfiniteQueryResult"} href={"/docs/api/pulse/queries/infinite_query/InfiniteQueryResult"} />
<Card title={"InfiniteQueryProperty"} href={"/docs/api/pulse/queries/infinite_query/InfiniteQueryProperty"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"none_if_missing"} type={"(value)"}>

<PySourceCode >

```python
def none_if_missing(value: Any):
	return None if value is MISSING else value
```

</PySourceCode>

<div >

<PyParameter name={"value"} type={"Any"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>
<PyFunction name={"infinite_query"} type={"(fn=None, *, initial_page_param, max_pages=0, stale_time=0.0, gc_time=300.0, refetch_interval=None, keep_previous_data=False, retries=3, retry_delay=None, initial_data_updated_at=None, enabled=True, fetch_on_mount=True, key=None)"}>

Decorator for paginated queries on State methods.

Creates a reactive infinite query that supports cursor-based or offset-based
pagination. Data is stored as a list of pages, each with its data and the
parameter used to fetch it.

Requires ``@query_prop.key`` and ``@query_prop.get_next_page_param`` decorators.

<Callout title={"Example"} type={"example"}>

::

        class FeedState(ps.State):
            @ps.infinite_query(initial_page_param=None, key=("feed",))
            async def posts(self, cursor: str | None) -> list[Post]:
                return await api.get_posts(cursor=cursor)

            @posts.key
            def _posts_key(self):
                return ("feed", self.feed_type)

            @posts.get_next_page_param
            def _next_cursor(self, pages: list[Page]) -> str | None:
                if not pages:
                    return None
                last = pages[-1]
                return last.data[-1].id if last.data else None

            @posts.get_previous_page_param
            def _prev_cursor(self, pages: list[Page]) -> str | None:
                if not pages:
                    return None
                first = pages[0]
                return first.data[0].id if first.data else None

</Callout>

<PySourceCode >

```python
def infinite_query(
	fn: Callable[[TState, TParam], Awaitable[T]] | None = None,
	*,
	initial_page_param: TParam,
	max_pages: int = 0,
	stale_time: float = 0.0,
	gc_time: float | None = 300.0,
	refetch_interval: float | None = None,
	keep_previous_data: bool = False,
	retries: int = 3,
	retry_delay: float | None = None,
	initial_data_updated_at: float | dt.datetime | None = None,
	enabled: bool = True,
	fetch_on_mount: bool = True,
	key: QueryKey | None = None,
):
	"""Decorator for paginated queries on State methods.

	Creates a reactive infinite query that supports cursor-based or offset-based
	pagination. Data is stored as a list of pages, each with its data and the
	parameter used to fetch it.

	Requires ``@query_prop.key`` and ``@query_prop.get_next_page_param`` decorators.

	Args:
		fn: The async method to decorate (when used without parentheses).
		initial_page_param: The parameter for fetching the first page (required).
		max_pages: Maximum pages to keep in memory (0 = unlimited).
		stale_time: Seconds before data is considered stale (default 0.0).
		gc_time: Seconds to keep unused query in cache (default 300.0).
		refetch_interval: Auto-refetch interval in seconds (default None).
		keep_previous_data: Keep previous data while refetching (default False).
		retries: Number of retry attempts on failure (default 3).
		retry_delay: Delay between retries in seconds (default 2.0).
		initial_data_updated_at: Timestamp for initial data staleness.
		enabled: Whether query is enabled (default True).
		fetch_on_mount: Fetch when component mounts (default True).
		key: Static query key for sharing across instances.

	Returns:
		InfiniteQueryProperty that creates InfiniteQueryResult instances when accessed.

	Example:
		::

			class FeedState(ps.State):
			    @ps.infinite_query(initial_page_param=None, key=("feed",))
			    async def posts(self, cursor: str | None) -> list[Post]:
			        return await api.get_posts(cursor=cursor)

			    @posts.key
			    def _posts_key(self):
			        return ("feed", self.feed_type)

			    @posts.get_next_page_param
			    def _next_cursor(self, pages: list[Page]) -> str | None:
			        if not pages:
			            return None
			        last = pages[-1]
			        return last.data[-1].id if last.data else None

			    @posts.get_previous_page_param
			    def _prev_cursor(self, pages: list[Page]) -> str | None:
			        if not pages:
			            return None
			        first = pages[0]
			        return first.data[0].id if first.data else None
	"""

	def decorator(
		func: Callable[[TState, TParam], Awaitable[T]], /
	) -> InfiniteQueryProperty[T, TParam, TState]:
		sig = inspect.signature(func)
		params = list(sig.parameters.values())
		if not (len(params) == 2 and params[0].name == "self"):
			raise TypeError(
				"@infinite_query must be applied to a state method with signature (self, page_param)"
			)

		return InfiniteQueryProperty(
			func.__name__,
			func,
			initial_page_param=initial_page_param,
			max_pages=max_pages,
			stale_time=stale_time,
			gc_time=gc_time if gc_time is not None else 300.0,
			refetch_interval=refetch_interval,
			keep_previous_data=keep_previous_data,
			retries=retries,
			retry_delay=RETRY_DELAY_DEFAULT if retry_delay is None else retry_delay,
			initial_data_updated_at=initial_data_updated_at,
			enabled=enabled,
			fetch_on_mount=fetch_on_mount,
			key=key,
		)

	if fn:
		return decorator(fn)
	return decorator
```

</PySourceCode>

<div >

<PyParameter name={"fn"} type={"Callable[[TState, TParam], Awaitable[T]] | None"} value={"None"}>

The async method to decorate (when used without parentheses).

</PyParameter>
<PyParameter name={"initial_page_param"} type={"TParam"} value={undefined}>

The parameter for fetching the first page (required).

</PyParameter>
<PyParameter name={"max_pages"} type={"int"} value={"0"}>

Maximum pages to keep in memory (0 = unlimited).

</PyParameter>
<PyParameter name={"stale_time"} type={"float"} value={"0.0"}>

Seconds before data is considered stale (default 0.0).

</PyParameter>
<PyParameter name={"gc_time"} type={"float | None"} value={"300.0"}>

Seconds to keep unused query in cache (default 300.0).

</PyParameter>
<PyParameter name={"refetch_interval"} type={"float | None"} value={"None"}>

Auto-refetch interval in seconds (default None).

</PyParameter>
<PyParameter name={"keep_previous_data"} type={"bool"} value={"False"}>

Keep previous data while refetching (default False).

</PyParameter>
<PyParameter name={"retries"} type={"int"} value={"3"}>

Number of retry attempts on failure (default 3).

</PyParameter>
<PyParameter name={"retry_delay"} type={"float | None"} value={"None"}>

Delay between retries in seconds (default 2.0).

</PyParameter>
<PyParameter name={"initial_data_updated_at"} type={"float | dt.datetime | None"} value={"None"}>

Timestamp for initial data staleness.

</PyParameter>
<PyParameter name={"enabled"} type={"bool"} value={"True"}>

Whether query is enabled (default True).

</PyParameter>
<PyParameter name={"fetch_on_mount"} type={"bool"} value={"True"}>

Fetch when component mounts (default True).

</PyParameter>
<PyParameter name={"key"} type={"QueryKey | None"} value={"None"}>

Static query key for sharing across instances.

</PyParameter>

</div>

<PyFunctionReturn type={null}>

InfiniteQueryProperty that creates InfiniteQueryResult instances when accessed.

</PyFunctionReturn>

</PyFunction>

</Tab>

</Tabs>