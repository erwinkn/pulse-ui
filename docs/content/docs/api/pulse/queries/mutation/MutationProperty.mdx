---
title: "MutationProperty"
---

Descriptor for state-bound mutations created by the @mutation decorator.

MutationProperty is the return type of the ``@mutation`` decorator. It acts
as a descriptor that creates and manages MutationResult instances for each
State object.

When accessed on a State instance, returns a MutationResult that can be
called to execute the mutation and provides reactive state properties.

Supports additional decorators for customization:
        - ``@mutation_prop.on_success``: Handle successful mutation.
        - ``@mutation_prop.on_error``: Handle mutation errors.

Example:
        ::

                class UserState(ps.State):
                    @ps.mutation
                    async def update_name(self, name: str) -> User:
                        return await api.update_user(name=name)

                    @update_name.on_success
                    def _on_success(self, data: User):
                        self.user.invalidate()  # Refresh user query

                    @update_name.on_error
                    def _on_error(self, error: Exception):
                        logger.error(f"Update failed: \{error\}")

## Attributes

<PyAttribute name={"name"} type={"str"} value={"name"} />

<PyAttribute name={"fn"} type={"Callable[Concatenate[TState, P], Awaitable[T]]"} value={"fn"} />

## Functions

<PyFunction name={"__init__"} type={"(self, name, fn, on_success=None, on_error=None)"}>

Initialize the mutation property.

<PySourceCode >

```python
def __init__(
	self,
	name: str,
	fn: Callable[Concatenate[TState, P], Awaitable[T]],
	on_success: OnSuccessFn[TState, T] | None = None,
	on_error: OnErrorFn[TState] | None = None,
):
	"""Initialize the mutation property.

	Args:
		name: The method name.
		fn: The async method to wrap.
		on_success: Optional success callback.
		on_error: Optional error callback.
	"""
	self.name = name
	self.fn = fn
	self._on_success_fn = on_success  # pyright: ignore[reportAttributeAccessIssue]
	self._on_error_fn = on_error  # pyright: ignore[reportAttributeAccessIssue]
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"name"} type={"str"} value={undefined}>

The method name.

</PyParameter>
<PyParameter name={"fn"} type={"Callable[Concatenate[TState, P], Awaitable[T]]"} value={undefined}>

The async method to wrap.

</PyParameter>
<PyParameter name={"on_success"} type={"OnSuccessFn[TState, T] | None"} value={"None"}>

Optional success callback.

</PyParameter>
<PyParameter name={"on_error"} type={"OnErrorFn[TState] | None"} value={"None"}>

Optional error callback.

</PyParameter>

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"on_success"} type={"(self, fn)"}>

Decorator to attach an on-success handler (sync or async).

<PySourceCode >

```python
def on_success(self, fn: OnSuccessFn[TState, T]):
	"""Decorator to attach an on-success handler (sync or async).

	Args:
		fn: Callback receiving (self, data) on successful mutation.

	Returns:
		The callback function unchanged.
	"""
	if self._on_success_fn is not None:
		raise RuntimeError(
			f"Duplicate on_success() decorator for mutation '{self.name}'. Only one is allowed."
		)
	self._on_success_fn = fn  # pyright: ignore[reportAttributeAccessIssue]
	return fn
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fn"} type={"OnSuccessFn[TState, T]"} value={undefined}>

Callback receiving (self, data) on successful mutation.

</PyParameter>

</div>

<PyFunctionReturn type={null}>

The callback function unchanged.

</PyFunctionReturn>

</PyFunction>

<PyFunction name={"on_error"} type={"(self, fn)"}>

Decorator to attach an on-error handler (sync or async).

<PySourceCode >

```python
def on_error(self, fn: OnErrorFn[TState]):
	"""Decorator to attach an on-error handler (sync or async).

	Args:
		fn: Callback receiving (self, error) on mutation failure.

	Returns:
		The callback function unchanged.
	"""
	if self._on_error_fn is not None:
		raise RuntimeError(
			f"Duplicate on_error() decorator for mutation '{self.name}'. Only one is allowed."
		)
	self._on_error_fn = fn  # pyright: ignore[reportAttributeAccessIssue]
	return fn
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fn"} type={"OnErrorFn[TState]"} value={undefined}>

Callback receiving (self, error) on mutation failure.

</PyParameter>

</div>

<PyFunctionReturn type={null}>

The callback function unchanged.

</PyFunctionReturn>

</PyFunction>

<PyFunction name={"__get__"} type={"(self, obj, objtype=None) -> MutationResult[T, P]"}>

<PySourceCode >

```python
def __get__(self, obj: Any, objtype: Any = None) -> MutationResult[T, P]:
	if obj is None:
		return self  # pyright: ignore[reportReturnType]

	# Cache the result on the instance
	cache_key = f"__mutation_{self.name}"
	if not hasattr(obj, cache_key):
		# Bind methods to state
		bound_fn = bind_state(obj, self.fn)
		bound_on_success = (
			bind_state(obj, self._on_success_fn) if self._on_success_fn else None
		)
		bound_on_error = (
			bind_state(obj, self._on_error_fn) if self._on_error_fn else None
		)

		result = MutationResult[T, P](
			fn=bound_fn,
			on_success=bound_on_success,
			on_error=bound_on_error,
		)
		setattr(obj, cache_key, result)

	return getattr(obj, cache_key)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"obj"} type={"Any"} value={null} />
<PyParameter name={"objtype"} type={"Any"} value={"None"} />

</div>

<PyFunctionReturn type={"pulse.queries.mutation.MutationResult[pulse.queries.mutation.T, pulse.queries.mutation.P]"} />

</PyFunction>

<PyFunction name={"initialize"} type={"(self, state, name) -> MutationResult[T, P]"}>

<PySourceCode >

```python
@override
def initialize(self, state: State, name: str) -> MutationResult[T, P]:
	# For compatibility with InitializableProperty, but mutations don't need special initialization
	return self.__get__(state, state.__class__)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"state"} type={"State"} value={null} />
<PyParameter name={"name"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"pulse.queries.mutation.MutationResult[pulse.queries.mutation.T, pulse.queries.mutation.P]"} />

</PyFunction>