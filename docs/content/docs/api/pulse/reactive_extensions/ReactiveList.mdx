---
title: "ReactiveList"
---

A list with item-level reactivity and structural change signaling.

Index reads depend on that index's Signal. Setting an index writes to that
index's Signal. Structural operations (append/insert/pop/etc.) trigger a
structural version Signal. Iteration subscribes to all item signals and
structural changes. len() subscribes to structural changes.

## Attributes

<PyAttribute name={"__slots__"} type={null} value={"('_signals', '_structure')"} />

<PyAttribute name={"version"} type={"int"} value={null}>

Reactive counter that increments on any structural change.

</PyAttribute>

## Functions

<PyFunction name={"__init__"} type={"(self, initial=None) -> None"}>

<PySourceCode >

```python
def __init__(self, initial: Iterable[T1] | None = None) -> None:
	super().__init__()
	self._signals: list[Signal[T1]] = []
	self._structure: Signal[int] = Signal(0)
	if initial:
		for item in initial:
			v = reactive(item)
			self._signals.append(Signal(v))
			super().append(v)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"initial"} type={"Iterable[T1] | None"} value={"None"} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"_bump_structure"} type={"(self)"}>

<PySourceCode >

```python
def _bump_structure(self):
	self._structure.write(self._structure.read() + 1)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"__getitem__"} type={"(self, idx)"}>

<PySourceCode >

```python
@override
def __getitem__(self, idx: SupportsIndex | slice):
	if isinstance(idx, slice):
		# Return a plain list of values (non-reactive slice)
		start, stop, step = idx.indices(len(self))
		return [self._signals[i].read() for i in range(start, stop, step)]
	return self._signals[idx].read()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"idx"} type={"SupportsIndex | slice"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"__setitem__"} type={"(self, key, value)"}>

<PySourceCode >

```python
@override
def __setitem__(self, key: SupportsIndex | slice, value: T1 | Iterable[T1]):
	if isinstance(key, slice):
		value = cast(Iterable[T1], value)
		replacement_seq = list(value)
		start, stop, step = key.indices(len(self))
		target_indices = list(range(start, stop, step))

		if len(replacement_seq) == len(target_indices):
			wrapped = [reactive(v) for v in replacement_seq]
			super().__setitem__(key, wrapped)
			for i, v in zip(target_indices, wrapped, strict=True):
				self._signals[i].write(v)
			return

		super().__setitem__(key, replacement_seq)
		self._signals = [Signal(reactive(v)) for v in super().__iter__()]
		self._bump_structure()
		return
	# normal index
	value = cast(T1, value)
	v = reactive(value)
	super().__setitem__(key, v)
	self._signals[key].write(v)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"key"} type={"SupportsIndex | slice"} value={null} />
<PyParameter name={"value"} type={"T1 | Iterable[T1]"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"__delitem__"} type={"(self, idx)"}>

<PySourceCode >

```python
@override
def __delitem__(self, idx: SupportsIndex | slice):
	if isinstance(idx, slice):
		super().__delitem__(idx)
		self._signals = [Signal(v) for v in super().__iter__()]
		self._bump_structure()
		return
	super().__delitem__(idx)
	del self._signals[idx]
	self._bump_structure()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"idx"} type={"SupportsIndex | slice"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"append"} type={"(self, value) -> None"}>

<PySourceCode >

```python
@override
def append(self, value: T1) -> None:
	v = reactive(value)
	super().append(v)
	self._signals.append(Signal(v))
	self._bump_structure()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"value"} type={"T1"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"extend"} type={"(self, values) -> None"}>

<PySourceCode >

```python
@override
def extend(self, values: Iterable[T1]) -> None:
	any_added = False
	for v in values:
		vv = reactive(v)
		super().append(vv)
		self._signals.append(Signal(vv))
		any_added = True
	if any_added:
		self._bump_structure()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"values"} type={"Iterable[T1]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"insert"} type={"(self, index, value) -> None"}>

<PySourceCode >

```python
@override
def insert(self, index: SupportsIndex, value: T1) -> None:
	v = reactive(value)
	super().insert(index, v)
	self._signals.insert(index, Signal(v))
	self._bump_structure()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"index"} type={"SupportsIndex"} value={null} />
<PyParameter name={"value"} type={"T1"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"pop"} type={"(self, index=-1)"}>

<PySourceCode >

```python
@override
def pop(self, index: SupportsIndex = -1):
	val = super().pop(index)
	del self._signals[index]
	self._bump_structure()
	return val
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"index"} type={"SupportsIndex"} value={"-1"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"unwrap"} type={"(self) -> list[_Any]"}>

Return a plain list while subscribing to element signals.

<PySourceCode >

```python
def unwrap(self) -> list[_Any]:
	"""Return a plain list while subscribing to element signals.

	Returns:
		A plain list with all reactive containers recursively unwrapped.
	"""
	self._structure()
	return [unwrap(self[i]) for i in range(len(self._signals))]
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"list"}>

A plain list with all reactive containers recursively unwrapped.

</PyFunctionReturn>

</PyFunction>

<PyFunction name={"remove"} type={"(self, value) -> None"}>

<PySourceCode >

```python
@override
def remove(self, value: _Any) -> None:
	idx = super().index(value)
	self.pop(idx)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"value"} type={"_Any"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"clear"} type={"(self) -> None"}>

<PySourceCode >

```python
@override
def clear(self) -> None:
	super().clear()
	self._signals.clear()
	self._bump_structure()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"reverse"} type={"(self) -> None"}>

<PySourceCode >

```python
@override
def reverse(self) -> None:
	super().reverse()
	self._signals.reverse()
	self._bump_structure()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"sort"} type={"(self, key=None, reverse=False) -> None"}>

<PySourceCode >

```python
@override
def sort(
	self,
	key: Callable[[T1], SupportsRichComparison] | None = None,
	reverse: bool = False,
) -> None:
	# To preserve per-index subscriptions, we have to reorder signals to match
	# new order. We'll compute the permutation by sorting indices based on
	# current values.
	current = list(super().__iter__())
	idxs = list(range(len(current)))

	# Create a key that uses the same key as provided to sort, but applied to value.
	def key_for_index(i: int):
		v = current[i]
		return key(v) if callable(key) else v

	# Apply sort to underlying list
	idxs.sort(key=key_for_index, reverse=reverse)  # pyright: ignore[reportCallIssue, reportArgumentType]
	# Reorder signals to match
	self._signals = [self._signals[i] for i in idxs]
	self._bump_structure()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"key"} type={"Callable[[T1], SupportsRichComparison] | None"} value={"None"} />
<PyParameter name={"reverse"} type={"bool"} value={"False"} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"__len__"} type={"(self) -> int"}>

<PySourceCode >

```python
@override
def __len__(self) -> int:
	self._structure.read()
	return super().__len__()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"int"} />

</PyFunction>

<PyFunction name={"__iter__"} type={"(self) -> Iterator[T1]"}>

<PySourceCode >

```python
@override
def __iter__(self) -> Iterator[T1]:
	self._structure.read()
	for sig in self._signals:
		yield sig.read()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"collections.abc.Iterator[pulse.reactive_extensions.T1]"} />

</PyFunction>

<PyFunction name={"__copy__"} type={"(self)"}>

<PySourceCode >

```python
def __copy__(self):
	result = type(self)()
	for value in super().__iter__():
		result.append(copy.copy(value))
	return result
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"__deepcopy__"} type={"(self, memo)"}>

<PySourceCode >

```python
def __deepcopy__(self, memo: dict[int, _Any]):
	if id(self) in memo:
		return memo[id(self)]
	result = type(self)()
	memo[id(self)] = result
	for value in super().__iter__():
		result.append(copy.deepcopy(value, memo))
	return result
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"memo"} type={"dict[int, _Any]"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>