---
title: "ReactiveProperty"
---

Unified reactive descriptor used for State fields and dataclass fields.

## Attributes

<PyAttribute name={"name"} type={"str | None"} value={"name"} />

<PyAttribute name={"private_name"} type={"str | None"} value={"None"} />

<PyAttribute name={"owner_name"} type={"str | None"} value={"None"} />

<PyAttribute name={"default"} type={"T1 | _Any"} value={"reactive(default) if default is not _MISSING else _MISSING"} />

## Functions

<PyFunction name={"__init__"} type={"(self, name=None, default=_MISSING)"}>

<PySourceCode >

```python
def __init__(self, name: str | None = None, default: T1 | None = _MISSING):
	self.name = name
	self.private_name = None
	self.owner_name = None
	self.default = reactive(default) if default is not _MISSING else _MISSING
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"name"} type={"str | None"} value={"None"} />
<PyParameter name={"default"} type={"T1 | None"} value={"_MISSING"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"__set_name__"} type={"(self, owner, name)"}>

<PySourceCode >

```python
def __set_name__(self, owner: type[_Any], name: str):
	self.name = self.name or name
	self.private_name = f"__signal_{self.name}"
	self.owner_name = getattr(owner, "__name__", owner.__class__.__name__)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"owner"} type={"type[_Any]"} value={null} />
<PyParameter name={"name"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_get_signal"} type={"(self, obj) -> Signal[T1]"}>

<PySourceCode >

```python
def _get_signal(self, obj: _Any) -> Signal[T1]:
	priv = cast(str, self.private_name)
	# Try fast path: attribute on the instance
	try:
		sig = getattr(obj, priv)
	except AttributeError:
		sig = None

	# Fallback store for slotted instances (no __dict__) using id(obj)
	if sig is None:
		per_obj = _INSTANCE_SIGNAL_STORE_BY_ID.get(id(obj))
		if per_obj is not None:
			sig = per_obj.get(priv)

	if sig is None:
		init_value = None if self.default is _MISSING else self.default
		sig = Signal(init_value, name=f"{self.owner_name}.{self.name}")
		# Try to attach to the instance; if that fails (e.g., __slots__), use fallback store
		try:
			setattr(obj, priv, sig)
		except Exception:
			obj_id = id(obj)
			mapping = _INSTANCE_SIGNAL_STORE_BY_ID.get(obj_id)
			if mapping is None:
				mapping = {}
				_INSTANCE_SIGNAL_STORE_BY_ID[obj_id] = mapping
				# Install a weakref to clean up when object is GC'd
				try:
					_INSTANCE_STORE_WEAKREFS[obj_id] = weakref.ref(
						obj,
						lambda _r, oid=obj_id: (
							_INSTANCE_SIGNAL_STORE_BY_ID.pop(oid, None),
							_INSTANCE_STORE_WEAKREFS.pop(oid, None),
						),
					)
				except TypeError:
					# Object not weakref-able; best effort leak-free by reusing id slot if recreated
					pass
			mapping[priv] = sig
	return cast(Signal[T1], sig)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"obj"} type={"_Any"} value={null} />

</div>

<PyFunctionReturn type={"pulse.reactive.Signal[pulse.reactive_extensions.T1]"} />

</PyFunction>

<PyFunction name={"__get__"} type={"(self, obj, objtype=None) -> T1"}>

<PySourceCode >

```python
def __get__(self, obj: _Any, objtype: type[_Any] | None = None) -> T1:
	if obj is None:
		return self  # pyright: ignore[reportReturnType]
	# If there is no signal yet and there was no default, mirror normal attribute error
	priv = cast(str, self.private_name)
	sig = getattr(obj, priv, None)
	if sig is None and self.default is _MISSING:
		owner = self.owner_name or obj.__class__.__name__
		raise AttributeError(
			f"Reactive property '{owner}.{self.name}' accessed before initialization"
		)
	return self._get_signal(obj).read()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"obj"} type={"_Any"} value={null} />
<PyParameter name={"objtype"} type={"type[_Any] | None"} value={"None"} />

</div>

<PyFunctionReturn type={"pulse.reactive_extensions.T1"} />

</PyFunction>

<PyFunction name={"__set__"} type={"(self, obj, value) -> None"}>

<PySourceCode >

```python
def __set__(self, obj: _Any, value: T1) -> None:
	sig = self._get_signal(obj)
	value = reactive(value)
	sig.write(value)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"obj"} type={"_Any"} value={null} />
<PyParameter name={"value"} type={"T1"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"get_signal"} type={"(self, obj) -> Signal[_Any]"}>

<PySourceCode >

```python
def get_signal(self, obj: _Any) -> Signal[_Any]:
	return self._get_signal(obj)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"obj"} type={"_Any"} value={null} />

</div>

<PyFunctionReturn type={"pulse.reactive.Signal[typing.Any]"} />

</PyFunction>