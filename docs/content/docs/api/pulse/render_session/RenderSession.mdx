---
title: "RenderSession"
---

## Attributes

<PyAttribute name={"id"} type={"str"} value={"id"} />

<PyAttribute name={"routes"} type={"RouteTree"} value={"routes"} />

<PyAttribute name={"channels"} type={"ChannelsManager"} value={"ChannelsManager(self)"} />

<PyAttribute name={"forms"} type={"FormRegistry"} value={"FormRegistry(self)"} />

<PyAttribute name={"query_store"} type={"QueryStore"} value={"QueryStore()"} />

<PyAttribute name={"route_mounts"} type={"dict[str, RouteMount]"} value={"{}"} />

<PyAttribute name={"connected"} type={"bool"} value={"False"} />

<PyAttribute name={"prerender_queue_timeout"} type={"float"} value={"prerender_queue_timeout"} />

<PyAttribute name={"disconnect_queue_timeout"} type={"float"} value={"disconnect_queue_timeout"} />

<PyAttribute name={"server_address"} type={"str"} value={null} />

<PyAttribute name={"client_address"} type={"str"} value={null} />

## Functions

<PyFunction name={"__init__"} type={"(self, id, routes, *, server_address=None, client_address=None, prerender_queue_timeout=5.0, disconnect_queue_timeout=2.0) -> None"}>

<PySourceCode >

```python
def __init__(
	self,
	id: str,
	routes: RouteTree,
	*,
	server_address: str | None = None,
	client_address: str | None = None,
	prerender_queue_timeout: float = 5.0,
	disconnect_queue_timeout: float = 2.0,
) -> None:
	from pulse.channel import ChannelsManager
	from pulse.form import FormRegistry

	self.id = id
	self.routes = routes
	self.route_mounts = {}
	self._server_address = server_address
	self._client_address = client_address
	self._send_message = None
	self._global_states = {}
	self.query_store = QueryStore()
	self.connected = False
	self.channels = ChannelsManager(self)
	self.forms = FormRegistry(self)
	self._pending_api = {}
	self._pending_js_results = {}
	self.prerender_queue_timeout = prerender_queue_timeout
	self.disconnect_queue_timeout = disconnect_queue_timeout
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"id"} type={"str"} value={null} />
<PyParameter name={"routes"} type={"RouteTree"} value={null} />
<PyParameter name={"server_address"} type={"str | None"} value={"None"} />
<PyParameter name={"client_address"} type={"str | None"} value={"None"} />
<PyParameter name={"prerender_queue_timeout"} type={"float"} value={"5.0"} />
<PyParameter name={"disconnect_queue_timeout"} type={"float"} value={"2.0"} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"_on_effect_error"} type={"(self, effect, exc)"}>

<PySourceCode >

```python
def _on_effect_error(self, effect: Any, exc: Exception):
	details = {"effect": getattr(effect, "name", "<unnamed>")}
	for path in list(self.route_mounts.keys()):
		self.report_error(path, "effect", exc, details)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"effect"} type={"Any"} value={null} />
<PyParameter name={"exc"} type={"Exception"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"connect"} type={"(self, send_message)"}>

WebSocket connected. Set sender, don't auto-flush (attach does that).

<PySourceCode >

```python
def connect(self, send_message: Callable[[ServerMessage], Any]):
	"""WebSocket connected. Set sender, don't auto-flush (attach does that)."""
	self._send_message = send_message
	self.connected = True
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"send_message"} type={"Callable[[ServerMessage], Any]"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"disconnect"} type={"(self)"}>

WebSocket disconnected. Start queuing briefly before pausing.

<PySourceCode >

```python
def disconnect(self):
	"""WebSocket disconnected. Start queuing briefly before pausing."""
	self._send_message = None
	self.connected = False

	for path, mount in self.route_mounts.items():
		if mount.state == "active":
			mount.state = "pending"
			mount.queue = []
			mount.queue_timeout = self._schedule_timeout(
				self.disconnect_queue_timeout,
				lambda p=path: self._transition_to_idle(p),
			)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"send"} type={"(self, message)"}>

Route message based on mount state.

<PySourceCode >

```python
def send(self, message: ServerMessage):
	"""Route message based on mount state."""
	# Global messages (not path-specific) go directly if connected
	path = message.get("path")
	if path is None:
		if self._send_message:
			self._send_message(message)
		return

	# Normalize path for lookup
	path = ensure_absolute_path(path)
	mount = self.route_mounts.get(path)
	if not mount:
		# Unknown path - send directly if connected (for js_exec, etc.)
		if self._send_message:
			self._send_message(message)
		return

	if mount.state == "pending" and mount.queue is not None:
		mount.queue.append(message)
	elif mount.state == "active" and self._send_message:
		self._send_message(message)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"message"} type={"ServerMessage"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"report_error"} type={"(self, path, phase, exc, details=None)"}>

<PySourceCode >

```python
def report_error(
	self,
	path: str,
	phase: ServerErrorPhase,
	exc: BaseException,
	details: dict[str, Any] | None = None,
):
	self.send(
		{
			"type": "server_error",
			"path": path,
			"error": {
				"message": str(exc),
				"stack": traceback.format_exc(),
				"phase": phase,
				"details": details or {},
			},
		}
	)
	logger.error(
		"Error reported for path %r during %s: %s\n%s",
		path,
		phase,
		exc,
		traceback.format_exc(),
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />
<PyParameter name={"phase"} type={"ServerErrorPhase"} value={null} />
<PyParameter name={"exc"} type={"BaseException"} value={null} />
<PyParameter name={"details"} type={"dict[str, Any] | None"} value={"None"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_schedule_timeout"} type={"(self, delay, callback) -> asyncio.TimerHandle"}>

<PySourceCode >

```python
def _schedule_timeout(
	self, delay: float, callback: Callable[[], None]
) -> asyncio.TimerHandle:
	loop = asyncio.get_event_loop()
	return loop.call_later(delay, callback)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"delay"} type={"float"} value={null} />
<PyParameter name={"callback"} type={"Callable[[], None]"} value={null} />

</div>

<PyFunctionReturn type={"asyncio.asyncio.TimerHandle"} />

</PyFunction>

<PyFunction name={"_cancel_queue_timeout"} type={"(self, mount)"}>

<PySourceCode >

```python
def _cancel_queue_timeout(self, mount: RouteMount):
	if mount.queue_timeout is not None:
		mount.queue_timeout.cancel()
		mount.queue_timeout = None
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"mount"} type={"RouteMount"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_transition_to_idle"} type={"(self, path)"}>

<PySourceCode >

```python
def _transition_to_idle(self, path: str):
	mount = self.route_mounts.get(path)
	if mount is None or mount.state != "pending":
		return

	mount.state = "idle"
	mount.queue = None
	mount.queue_timeout = None
	if mount.effect:
		mount.effect.pause()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"prerender"} type={"(self, path, route_info=None) -> ServerInitMessage | ServerNavigateToMessage"}>

Synchronous render for SSR. Returns vdom_init or navigate_to message.
- First call: creates RouteMount in PENDING state, starts queue
- Subsequent calls: re-renders and returns fresh VDOM

<PySourceCode >

```python
def prerender(
	self, path: str, route_info: RouteInfo | None = None
) -> ServerInitMessage | ServerNavigateToMessage:
	"""
	Synchronous render for SSR. Returns vdom_init or navigate_to message.
	- First call: creates RouteMount in PENDING state, starts queue
	- Subsequent calls: re-renders and returns fresh VDOM
	"""
	path = ensure_absolute_path(path)
	mount = self.route_mounts.get(path)
	is_new = mount is None

	if is_new:
		route = self.routes.find(path)
		info = route_info or route.default_route_info()
		mount = RouteMount(self, route, info)
		mount.state = "pending"
		mount.queue = []
		self.route_mounts[path] = mount
	elif route_info:
		mount.route.update(route_info)

	with PulseContext.update(render=self, route=mount.route):
		try:
			vdom = mount.tree.render()
			if is_new:
				mount.initialized = True
		except RedirectInterrupt as r:
			del self.route_mounts[path]
			return ServerNavigateToMessage(
				type="navigate_to", path=r.path, replace=r.replace, hard=False
			)
		except NotFoundInterrupt:
			del self.route_mounts[path]
			ctx = PulseContext.get()
			return ServerNavigateToMessage(
				type="navigate_to", path=ctx.app.not_found, replace=True, hard=False
			)

	if is_new:
		self._create_render_effect(mount, path)
		mount.queue_timeout = self._schedule_timeout(
			self.prerender_queue_timeout,
			lambda: self._transition_to_idle(path),
		)

	return ServerInitMessage(type="vdom_init", path=path, vdom=vdom)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />
<PyParameter name={"route_info"} type={"RouteInfo | None"} value={"None"} />

</div>

<PyFunctionReturn type={"pulse.messages.ServerInitMessage | pulse.messages.ServerNavigateToMessage"} />

</PyFunction>

<PyFunction name={"attach"} type={"(self, path, route_info)"}>

Client ready to receive updates for path.
- PENDING: flush queue, transition to ACTIVE
- IDLE: fresh render, transition to ACTIVE
- ACTIVE: update route_info
- No mount: create fresh

<PySourceCode >

```python
def attach(self, path: str, route_info: RouteInfo):
	"""
	Client ready to receive updates for path.
	- PENDING: flush queue, transition to ACTIVE
	- IDLE: fresh render, transition to ACTIVE
	- ACTIVE: update route_info
	- No mount: create fresh
	"""
	path = ensure_absolute_path(path)
	mount = self.route_mounts.get(path)

	if mount is None:
		# No prerender, create fresh
		route = self.routes.find(path)
		mount = RouteMount(self, route, route_info)
		mount.state = "active"
		self.route_mounts[path] = mount
		self._create_render_effect(mount, path)
		return

	if mount.state == "pending":
		# Flush queue, go active
		self._cancel_queue_timeout(mount)
		if mount.queue:
			for msg in mount.queue:
				if self._send_message:
					self._send_message(msg)
		mount.queue = None
		mount.state = "active"
		mount.route.update(route_info)

	elif mount.state == "idle":
		# Need fresh render
		mount.initialized = False
		mount.state = "active"
		mount.route.update(route_info)
		if mount.effect:
			mount.effect.resume()

	elif mount.state == "active":
		# Already active, just update route
		mount.route.update(route_info)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />
<PyParameter name={"route_info"} type={"RouteInfo"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"update_route"} type={"(self, path, route_info)"}>

Update routing state (query params, etc.) for attached path.

<PySourceCode >

```python
def update_route(self, path: str, route_info: RouteInfo):
	"""Update routing state (query params, etc.) for attached path."""
	path = ensure_absolute_path(path)
	try:
		mount = self.get_route_mount(path)
		mount.route.update(route_info)
	except Exception as e:
		self.report_error(path, "navigate", e)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />
<PyParameter name={"route_info"} type={"RouteInfo"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"detach"} type={"(self, path)"}>

Client no longer wants updates. Dispose Effect, remove mount.

<PySourceCode >

```python
def detach(self, path: str):
	"""Client no longer wants updates. Dispose Effect, remove mount."""
	path = ensure_absolute_path(path)
	if path not in self.route_mounts:
		return
	try:
		mount = self.route_mounts.pop(path)
		self._cancel_queue_timeout(mount)
		mount.tree.unmount()
		if mount.effect:
			mount.effect.dispose()
	except Exception as e:
		self.report_error(path, "unmount", e)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_create_render_effect"} type={"(self, mount, path)"}>

<PySourceCode >

```python
def _create_render_effect(self, mount: RouteMount, path: str):
	ctx = PulseContext.get()
	session = ctx.session

	def _render_effect():
		with PulseContext.update(session=session, render=self, route=mount.route):
			try:
				if not mount.initialized:
					vdom = mount.tree.render()
					mount.initialized = True
					self.send(
						ServerInitMessage(type="vdom_init", path=path, vdom=vdom)
					)
				else:
					ops = mount.tree.rerender()
					if ops:
						self.send(
							ServerUpdateMessage(
								type="vdom_update", path=path, ops=ops
							)
						)
			except RedirectInterrupt as r:
				self.send(
					ServerNavigateToMessage(
						type="navigate_to",
						path=r.path,
						replace=r.replace,
						hard=False,
					)
				)
			except NotFoundInterrupt:
				self.send(
					ServerNavigateToMessage(
						type="navigate_to",
						path=ctx.app.not_found,
						replace=True,
						hard=False,
					)
				)

	mount.effect = Effect(
		_render_effect,
		immediate=True,
		name=f"{path}:render",
		on_error=lambda e: self.report_error(path, "render", e),
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"mount"} type={"RouteMount"} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"close"} type={"(self)"}>

<PySourceCode >

```python
def close(self):
	self.forms.dispose()
	for path in list(self.route_mounts.keys()):
		self.detach(path)
	self.route_mounts.clear()
	for value in self._global_states.values():
		value.dispose()
	self._global_states.clear()
	for channel_id in list(self.channels._channels.keys()):  # pyright: ignore[reportPrivateUsage]
		channel = self.channels._channels.get(channel_id)  # pyright: ignore[reportPrivateUsage]
		if channel:
			channel.closed = True
			self.channels.dispose_channel(channel, reason="render.close")
	for fut in self._pending_api.values():
		if not fut.done():
			fut.cancel()
	self._pending_api.clear()
	for fut in self._pending_js_results.values():
		if not fut.done():
			fut.cancel()
	self._pending_js_results.clear()
	self._send_message = None
	self.connected = False
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"get_route_mount"} type={"(self, path) -> RouteMount"}>

<PySourceCode >

```python
def get_route_mount(self, path: str) -> RouteMount:
	path = ensure_absolute_path(path)
	mount = self.route_mounts.get(path)
	if not mount:
		raise ValueError(f"No active route for '{path}'")
	return mount
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"pulse.render_session.RouteMount"} />

</PyFunction>

<PyFunction name={"get_global_state"} type={"(self, key, factory) -> Any"}>

Return a per-session singleton for the provided key.

<PySourceCode >

```python
def get_global_state(self, key: str, factory: Callable[[], Any]) -> Any:
	"""Return a per-session singleton for the provided key."""
	inst = self._global_states.get(key)
	if inst is None:
		inst = factory()
		self._global_states[key] = inst
	return inst
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"key"} type={"str"} value={null} />
<PyParameter name={"factory"} type={"Callable[[], Any]"} value={null} />

</div>

<PyFunctionReturn type={"typing.Any"} />

</PyFunction>

<PyFunction name={"flush"} type={"(self)"}>

<PySourceCode >

```python
def flush(self):
	with PulseContext.update(render=self):
		flush_effects()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"execute_callback"} type={"(self, path, key, args)"}>

<PySourceCode >

```python
def execute_callback(self, path: str, key: str, args: list[Any] | tuple[Any, ...]):
	mount = self.route_mounts[path]
	cb = mount.tree.callbacks[key]

	def report(e: BaseException, is_async: bool = False):
		self.report_error(path, "callback", e, {"callback": key, "async": is_async})

	try:
		with PulseContext.update(render=self, route=mount.route):
			res = cb.fn(*args[: cb.n_args])
			if iscoroutine(res):
				create_task(
					res, on_done=lambda t: (e := t.exception()) and report(e, True)
				)
	except Exception as e:
		report(e)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />
<PyParameter name={"key"} type={"str"} value={null} />
<PyParameter name={"args"} type={"list[Any] | tuple[Any, ...]"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"call_api"} type={"(self, url_or_path, *, method='POST', headers=None, body=None, credentials='include', timeout=30.0) -> dict[str, Any]"}>

Request the client to perform a fetch and await the result.

<PySourceCode >

```python
async def call_api(
	self,
	url_or_path: str,
	*,
	method: str = "POST",
	headers: dict[str, str] | None = None,
	body: Any | None = None,
	credentials: str = "include",
	timeout: float = 30.0,
) -> dict[str, Any]:
	"""Request the client to perform a fetch and await the result."""
	if url_or_path.startswith("http://") or url_or_path.startswith("https://"):
		url = url_or_path
	else:
		base = self.server_address
		if not base:
			raise RuntimeError(
				"Server address unavailable. Ensure App.run_codegen/asgi_factory set server_address."
			)
		api_path = url_or_path if url_or_path.startswith("/") else "/" + url_or_path
		url = f"{base}{api_path}"
	corr_id = uuid.uuid4().hex
	fut = create_future_on_loop()
	self._pending_api[corr_id] = fut
	headers = headers or {}
	headers["x-pulse-render-id"] = self.id
	self.send(
		ServerApiCallMessage(
			type="api_call",
			id=corr_id,
			url=url,
			method=method,
			headers=headers,
			body=body,
			credentials="include" if credentials == "include" else "omit",
		)
	)
	try:
		result = await asyncio.wait_for(fut, timeout=timeout)
	except asyncio.TimeoutError:
		self._pending_api.pop(corr_id, None)
		raise
	return result
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"url_or_path"} type={"str"} value={null} />
<PyParameter name={"method"} type={"str"} value={"'POST'"} />
<PyParameter name={"headers"} type={"dict[str, str] | None"} value={"None"} />
<PyParameter name={"body"} type={"Any | None"} value={"None"} />
<PyParameter name={"credentials"} type={"str"} value={"'include'"} />
<PyParameter name={"timeout"} type={"float"} value={"30.0"} />

</div>

<PyFunctionReturn type={"dict[str, typing.Any]"} />

</PyFunction>

<PyFunction name={"handle_api_result"} type={"(self, data)"}>

<PySourceCode >

```python
def handle_api_result(self, data: dict[str, Any]):
	id_ = data.get("id")
	if id_ is None:
		return
	id_ = str(id_)
	fut = self._pending_api.pop(id_, None)
	if fut and not fut.done():
		fut.set_result(
			{
				"ok": data.get("ok", False),
				"status": data.get("status", 0),
				"headers": data.get("headers", {}),
				"body": data.get("body"),
			}
		)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"data"} type={"dict[str, Any]"} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"run_js"} type={"(self, expr, *, result=False, timeout=10.0) -> asyncio.Future[object] | None"}>

Execute JavaScript on the client.

<Callout title={"Example - Fire and forget"} type={"example---fire-and-forget"}>

@javascript
def focus_element(selector: str):
        document.querySelector(selector).focus()

def on_save():
        save_data()
        run_js(focus_element("#next-input"))

</Callout>

<Callout title={"Example - Await result"} type={"example---await-result"}>

@javascript
def get_scroll_position():
        return \{"x": window.scrollX, "y": window.scrollY\}

async def on_click():
        pos = await run_js(get_scroll_position(), result=True)
        print(pos["x"], pos["y"])

</Callout>

<PySourceCode >

```python
def run_js(
	self, expr: Expr, *, result: bool = False, timeout: float = 10.0
) -> asyncio.Future[object] | None:
	"""Execute JavaScript on the client.

	Args:
		expr: An Expr from calling a @javascript function.
		result: If True, returns a Future that resolves with the JS return value.
		        If False (default), returns None (fire-and-forget).
		timeout: Maximum seconds to wait for result (default 10s, only applies when
		         result=True). Future raises asyncio.TimeoutError if exceeded.

	Returns:
		None if result=False, otherwise a Future resolving to the JS result.

	Example - Fire and forget:
		@javascript
		def focus_element(selector: str):
			document.querySelector(selector).focus()

		def on_save():
			save_data()
			run_js(focus_element("#next-input"))

	Example - Await result:
		@javascript
		def get_scroll_position():
			return {"x": window.scrollX, "y": window.scrollY}

		async def on_click():
			pos = await run_js(get_scroll_position(), result=True)
			print(pos["x"], pos["y"])
	"""
	ctx = PulseContext.get()
	exec_id = next_id()

	# Get route pattern path (e.g., "/users/:id") not pathname (e.g., "/users/123")
	# This must match the path used to key views on the client side
	path = ctx.route.pulse_route.unique_path() if ctx.route else "/"

	self.send(
		ServerJsExecMessage(
			type="js_exec",
			path=path,
			id=exec_id,
			expr=expr.render(),
		)
	)

	if result:
		loop = asyncio.get_running_loop()
		future: asyncio.Future[object] = loop.create_future()
		self._pending_js_results[exec_id] = future

		def _on_timeout() -> None:
			self._pending_js_results.pop(exec_id, None)
			if not future.done():
				future.set_exception(asyncio.TimeoutError())

		loop.call_later(timeout, _on_timeout)

		return future

	return None
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"expr"} type={"Expr"} value={undefined}>

An Expr from calling a @javascript function.

</PyParameter>
<PyParameter name={"result"} type={"bool"} value={"False"}>

If True, returns a Future that resolves with the JS return value.
If False (default), returns None (fire-and-forget).

</PyParameter>
<PyParameter name={"timeout"} type={"float"} value={"10.0"}>

Maximum seconds to wait for result (default 10s, only applies when
result=True). Future raises asyncio.TimeoutError if exceeded.

</PyParameter>

</div>

<PyFunctionReturn type={"asyncio.Future[object] | None"}>

None if result=False, otherwise a Future resolving to the JS result.

</PyFunctionReturn>

</PyFunction>

<PyFunction name={"handle_js_result"} type={"(self, data) -> None"}>

Handle js_result message from client.

<PySourceCode >

```python
def handle_js_result(self, data: dict[str, Any]) -> None:
	"""Handle js_result message from client."""
	exec_id = data.get("id")
	if exec_id is None:
		return
	exec_id = str(exec_id)
	fut = self._pending_js_results.pop(exec_id, None)
	if fut is None or fut.done():
		return
	error = data.get("error")
	if error is not None:
		fut.set_exception(JsExecError(error))
	else:
		fut.set_result(data.get("result"))
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"data"} type={"dict[str, Any]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>