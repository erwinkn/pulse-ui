---
title: "Route"
---

Defines a route in the application.

Routes map URL paths to components that render the page content.

## Attributes

<PyAttribute name={"path"} type={"str"} value={"ensure_relative_path(path)"}>

Normalized relative path (no leading/trailing slashes).

</PyAttribute>

<PyAttribute name={"segments"} type={"list[PathSegment]"} value={"parse_route_path(path)"}>

Parsed path segments.

</PyAttribute>

<PyAttribute name={"render"} type={"Component[[]]"} value={"render"}>

Component to render.

</PyAttribute>

<PyAttribute name={"children"} type={"Sequence[Route | Layout]"} value={"children or []"}>

Nested routes.

</PyAttribute>

<PyAttribute name={"is_index"} type={"bool"} value={"self.path == ''"}>

True if this is an index route (empty path).

</PyAttribute>

<PyAttribute name={"is_dynamic"} type={"bool"} value={"any((seg.is_dynamic or seg.is_optional) for seg in (self.segments))"}>

True if path contains dynamic or optional segments.

</PyAttribute>

<PyAttribute name={"dev"} type={"bool"} value={"dev"}>

Whether route is dev-only.

</PyAttribute>

<PyAttribute name={"parent"} type={"Route | Layout | None"} value={"None"} />

## Functions

<PyFunction name={"__init__"} type={"(self, path, render, children=None, dev=False)"}>

<PySourceCode >

```python
def __init__(
	self,
	path: str,
	render: Component[[]],
	children: "Sequence[Route | Layout] | None" = None,
	dev: bool = False,
):
	self.path = ensure_relative_path(path)
	self.segments = parse_route_path(path)

	self.render = render
	self.children = children or []
	self.dev = dev
	self.parent: Route | Layout | None = None

	self.is_index = self.path == ""
	self.is_dynamic = any(
		seg.is_dynamic or seg.is_optional for seg in self.segments
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />
<PyParameter name={"render"} type={"Component[[]]"} value={null} />
<PyParameter name={"children"} type={"Sequence[Route | Layout] | None"} value={"None"} />
<PyParameter name={"dev"} type={"bool"} value={"False"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"_path_list"} type={"(self, include_layouts=False) -> list[str]"}>

<PySourceCode >

```python
def _path_list(self, include_layouts: bool = False) -> list[str]:
	# Question marks cause problems for the URL of our prerendering requests +
	# React-Router file loading
	path = self.path.replace("?", "^")
	if self.parent:
		return [*self.parent._path_list(include_layouts=include_layouts), path]  # pyright: ignore[reportPrivateUsage]
	return [path]
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"include_layouts"} type={"bool"} value={"False"} />

</div>

<PyFunctionReturn type={"list[str]"} />

</PyFunction>

<PyFunction name={"unique_path"} type={"(self)"}>

<PySourceCode >

```python
def unique_path(self):
	# Return absolute path with leading '/'
	return ensure_absolute_path("/".join(self._path_list()))
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"file_path"} type={"(self) -> str"}>

<PySourceCode >

```python
def file_path(self) -> str:
	path = "/".join(self._path_list(include_layouts=False))
	if self.is_index:
		path += "index"
	path += ".jsx"
	# Replace Windows-invalid characters in filenames
	return _sanitize_filename(path)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>

<PyFunction name={"__repr__"} type={"(self) -> str"}>

<PySourceCode >

```python
@override
def __repr__(self) -> str:
	return (
		f"Route(path='{self.path or ''}'"
		+ (f", children={len(self.children)}" if self.children else "")
		+ ")"
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>

<PyFunction name={"default_route_info"} type={"(self) -> RouteInfo"}>

Return a default RouteInfo for this route.

Only valid for non-dynamic routes. Raises InvalidRouteError if the
route contains any dynamic (":name"), optional ("segment?"), or
catch-all ("*") segments. Also rejects if any ancestor Route is dynamic.

<PySourceCode >

```python
def default_route_info(self) -> "RouteInfo":
	"""Return a default RouteInfo for this route.

	Only valid for non-dynamic routes. Raises InvalidRouteError if the
	route contains any dynamic (":name"), optional ("segment?"), or
	catch-all ("*") segments. Also rejects if any ancestor Route is dynamic.
	"""

	# Disallow optional, dynamic, and catch-all segments on self and ancestors
	if route_or_ancestors_have_dynamic(self):
		raise InvalidRouteError(
			f"Cannot build default RouteInfo for dynamic route '{self.path}'."
		)

	pathname = self.unique_path()
	return {
		"pathname": pathname,
		"hash": "",
		"query": "",
		"queryParams": {},
		"pathParams": {},
		"catchall": [],
	}
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"pulse.routing.RouteInfo"} />

</PyFunction>