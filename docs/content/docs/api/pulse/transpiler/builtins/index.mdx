---
title: "builtins"
---

Python builtin functions and methods -> JavaScript equivalents.

This module provides transpilation for Python builtins to JavaScript.
Builtin methods use runtime type checks when the type is not statically known.

<PyAttribute name={"BUILTINS"} type={"dict[str, Transformer[Any]]"} value={"dict(print=emit_print, len=emit_len, min=emit_min, max=emit_max, abs=emit_abs, round=emit_round, str=emit_str, int=emit_int, float=emit_float, list=emit_list, bool=emit_bool, set=emit_set, tuple=emit_tuple, dict=emit_dict, filter=emit_filter, map=emit_map, reversed=emit_reversed, enumerate=emit_enumerate, range=emit_range, sorted=emit_sorted, zip=emit_zip, pow=emit_pow, chr=emit_chr, ord=emit_ord, any=emit_any, all=emit_all, sum=emit_sum, divmod=emit_divmod, isinstance=emit_isinstance, Exception=emit_exception, ValueError=emit_value_error, TypeError=emit_type_error, RuntimeError=emit_runtime_error)"} />

<PyAttribute name={"STR_METHODS"} type={null} value={"{k for k in (StringMethods.__dict__) if not k.startswith('_')}"} />

<PyAttribute name={"LIST_METHODS"} type={null} value={"{k for k in (ListMethods.__dict__) if not k.startswith('_')}"} />

<PyAttribute name={"DICT_METHODS"} type={null} value={"{k for k in (DictMethods.__dict__) if not k.startswith('_')}"} />

<PyAttribute name={"SET_METHODS"} type={null} value={"{k for k in (SetMethods.__dict__) if not k.startswith('_')}"} />

<PyAttribute name={"ALL_METHODS"} type={null} value={"STR_METHODS | LIST_METHODS | DICT_METHODS | SET_METHODS"} />

<PyAttribute name={"METHOD_CLASSES"} type={"builtins.list[builtins.type[BuiltinMethods]]"} value={"[DictMethods, SetMethods, ListMethods, StringMethods]"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"BuiltinMethods"} href={"/docs/api/pulse/transpiler/builtins/BuiltinMethods"} />
<Card title={"StringMethods"} href={"/docs/api/pulse/transpiler/builtins/StringMethods"} />
<Card title={"ListMethods"} href={"/docs/api/pulse/transpiler/builtins/ListMethods"} />
<Card title={"DictMethods"} href={"/docs/api/pulse/transpiler/builtins/DictMethods"} />
<Card title={"SetMethods"} href={"/docs/api/pulse/transpiler/builtins/SetMethods"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"emit_print"} type={"(*args, /, *, ctx) -> Expr"}>

print(*args) -> console.log(...)

<PySourceCode >

```python
@transformer("print")
def emit_print(*args: Any, ctx: Transpiler) -> Expr:
	"""print(*args) -> console.log(...)"""
	return Call(Member(Identifier("console"), "log"), [ctx.emit_expr(a) for a in args])
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_len"} type={"(x, *, ctx) -> Expr"}>

len(x) -> x.length ?? x.size

<PySourceCode >

```python
@transformer("len")
def emit_len(x: Any, *, ctx: Transpiler) -> Expr:
	"""len(x) -> x.length ?? x.size"""
	x = ctx.emit_expr(x)
	return Binary(Member(x, "length"), "??", Member(x, "size"))
```

</PySourceCode>

<div >

<PyParameter name={"x"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_min"} type={"(*args, /, *, ctx) -> Expr"}>

min(*args) -> Math.min(...)

<PySourceCode >

```python
@transformer("min")
def emit_min(*args: Any, ctx: Transpiler) -> Expr:
	"""min(*args) -> Math.min(...)"""
	if builtins.len(args) == 0:
		raise TranspileError("min() expects at least one argument")
	if builtins.len(args) == 1:
		iterable = ctx.emit_expr(args[0])
		return Call(
			Member(Identifier("Math"), "min"),
			[Spread(Call(Member(Identifier("Array"), "from"), [iterable]))],
		)
	return Call(Member(Identifier("Math"), "min"), [ctx.emit_expr(a) for a in args])
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_max"} type={"(*args, /, *, ctx) -> Expr"}>

max(*args) -> Math.max(...)

<PySourceCode >

```python
@transformer("max")
def emit_max(*args: Any, ctx: Transpiler) -> Expr:
	"""max(*args) -> Math.max(...)"""
	if builtins.len(args) == 0:
		raise TranspileError("max() expects at least one argument")
	if builtins.len(args) == 1:
		iterable = ctx.emit_expr(args[0])
		return Call(
			Member(Identifier("Math"), "max"),
			[Spread(Call(Member(Identifier("Array"), "from"), [iterable]))],
		)
	return Call(Member(Identifier("Math"), "max"), [ctx.emit_expr(a) for a in args])
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_abs"} type={"(x, *, ctx) -> Expr"}>

abs(x) -> Math.abs(x)

<PySourceCode >

```python
@transformer("abs")
def emit_abs(x: Any, *, ctx: Transpiler) -> Expr:
	"""abs(x) -> Math.abs(x)"""
	return Call(Member(Identifier("Math"), "abs"), [ctx.emit_expr(x)])
```

</PySourceCode>

<div >

<PyParameter name={"x"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_round"} type={"(number, ndigits=None, *, ctx) -> Expr"}>

round(number, ndigits=None) -> Math.round(...) or toFixed(...)

<PySourceCode >

```python
@transformer("round")
def emit_round(number: Any, ndigits: Any = None, *, ctx: Transpiler) -> Expr:
	"""round(number, ndigits=None) -> Math.round(...) or toFixed(...)"""
	number = ctx.emit_expr(number)
	if ndigits is None:
		return Call(Member(Identifier("Math"), "round"), [number])
	# With ndigits: Number(Number(x).toFixed(ndigits)) to keep numeric semantics
	return Call(
		Identifier("Number"),
		[
			Call(
				Member(Call(Identifier("Number"), [number]), "toFixed"),
				[ctx.emit_expr(ndigits)],
			)
		],
	)
```

</PySourceCode>

<div >

<PyParameter name={"number"} type={"Any"} value={null} />
<PyParameter name={"ndigits"} type={"Any"} value={"None"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_str"} type={"(x, *, ctx) -> Expr"}>

str(x) -> String(x)

<PySourceCode >

```python
@transformer("str")
def emit_str(x: Any, *, ctx: Transpiler) -> Expr:
	"""str(x) -> String(x)"""
	return Call(Identifier("String"), [ctx.emit_expr(x)])
```

</PySourceCode>

<div >

<PyParameter name={"x"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_int"} type={"(*args, /, *, ctx) -> Expr"}>

int(x) or int(x, base) -> parseInt(...)

<PySourceCode >

```python
@transformer("int")
def emit_int(*args: Any, ctx: Transpiler) -> Expr:
	"""int(x) or int(x, base) -> parseInt(...)"""
	if builtins.len(args) == 1:
		return Call(Identifier("parseInt"), [ctx.emit_expr(args[0])])
	if builtins.len(args) == 2:
		return Call(
			Identifier("parseInt"), [ctx.emit_expr(args[0]), ctx.emit_expr(args[1])]
		)
	raise TranspileError("int() expects one or two arguments")
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_float"} type={"(x, *, ctx) -> Expr"}>

float(x) -> parseFloat(x)

<PySourceCode >

```python
@transformer("float")
def emit_float(x: Any, *, ctx: Transpiler) -> Expr:
	"""float(x) -> parseFloat(x)"""
	return Call(Identifier("parseFloat"), [ctx.emit_expr(x)])
```

</PySourceCode>

<div >

<PyParameter name={"x"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_list"} type={"(x, *, ctx) -> Expr"}>

list(x) -> Array.from(x)

<PySourceCode >

```python
@transformer("list")
def emit_list(x: Any, *, ctx: Transpiler) -> Expr:
	"""list(x) -> Array.from(x)"""
	return Call(Member(Identifier("Array"), "from"), [ctx.emit_expr(x)])
```

</PySourceCode>

<div >

<PyParameter name={"x"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_bool"} type={"(x, *, ctx) -> Expr"}>

bool(x) -> Boolean(x)

<PySourceCode >

```python
@transformer("bool")
def emit_bool(x: Any, *, ctx: Transpiler) -> Expr:
	"""bool(x) -> Boolean(x)"""
	return Call(Identifier("Boolean"), [ctx.emit_expr(x)])
```

</PySourceCode>

<div >

<PyParameter name={"x"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_set"} type={"(*args, /, *, ctx) -> Expr"}>

set() or set(iterable) -> new Set([iterable])

<PySourceCode >

```python
@transformer("set")
def emit_set(*args: Any, ctx: Transpiler) -> Expr:
	"""set() or set(iterable) -> new Set([iterable])"""
	if builtins.len(args) == 0:
		return New(Identifier("Set"), [])
	if builtins.len(args) == 1:
		return New(Identifier("Set"), [ctx.emit_expr(args[0])])
	raise TranspileError("set() expects at most one argument")
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_tuple"} type={"(*args, /, *, ctx) -> Expr"}>

tuple() or tuple(iterable) -> Array.from(iterable)

<PySourceCode >

```python
@transformer("tuple")
def emit_tuple(*args: Any, ctx: Transpiler) -> Expr:
	"""tuple() or tuple(iterable) -> Array.from(iterable)"""
	if builtins.len(args) == 0:
		return Array([])
	if builtins.len(args) == 1:
		return Call(Member(Identifier("Array"), "from"), [ctx.emit_expr(args[0])])
	raise TranspileError("tuple() expects at most one argument")
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_dict"} type={"(*args, /, *, ctx) -> Expr"}>

dict() or dict(iterable) -> new Map([iterable])

<PySourceCode >

```python
@transformer("dict")
def emit_dict(*args: Any, ctx: Transpiler) -> Expr:
	"""dict() or dict(iterable) -> new Map([iterable])"""
	if builtins.len(args) == 0:
		return New(Identifier("Map"), [])
	if builtins.len(args) == 1:
		return New(Identifier("Map"), [ctx.emit_expr(args[0])])
	raise TranspileError("dict() expects at most one argument")
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_filter"} type={"(*args, /, *, ctx) -> Expr"}>

filter(func, iterable) -> iterable.filter(func)

<PySourceCode >

```python
@transformer("filter")
def emit_filter(*args: Any, ctx: Transpiler) -> Expr:
	"""filter(func, iterable) -> iterable.filter(func)"""
	if not (1 <= builtins.len(args) <= 2):
		raise TranspileError("filter() expects one or two arguments")
	if builtins.len(args) == 1:
		# filter(iterable) - filter truthy values
		iterable = ctx.emit_expr(args[0])
		predicate = Arrow(["v"], Identifier("v"))
		return Call(Member(iterable, "filter"), [predicate])
	func, iterable = ctx.emit_expr(args[0]), ctx.emit_expr(args[1])
	# filter(None, iterable) means filter truthy
	if builtins.isinstance(func, (Literal, Undefined)) and (
		builtins.isinstance(func, Undefined)
		or (builtins.isinstance(func, Literal) and func.value is None)
	):
		func = Arrow(["v"], Identifier("v"))
	return Call(Member(iterable, "filter"), [func])
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_map"} type={"(func, iterable, *, ctx) -> Expr"}>

map(func, iterable) -> iterable.map(func)

<PySourceCode >

```python
@transformer("map")
def emit_map(func: Any, iterable: Any, *, ctx: Transpiler) -> Expr:
	"""map(func, iterable) -> iterable.map(func)"""
	return Call(Member(ctx.emit_expr(iterable), "map"), [ctx.emit_expr(func)])
```

</PySourceCode>

<div >

<PyParameter name={"func"} type={"Any"} value={null} />
<PyParameter name={"iterable"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_reversed"} type={"(iterable, *, ctx) -> Expr"}>

reversed(iterable) -> iterable.slice().reverse()

<PySourceCode >

```python
@transformer("reversed")
def emit_reversed(iterable: Any, *, ctx: Transpiler) -> Expr:
	"""reversed(iterable) -> iterable.slice().reverse()"""
	return Call(
		Member(Call(Member(ctx.emit_expr(iterable), "slice"), []), "reverse"), []
	)
```

</PySourceCode>

<div >

<PyParameter name={"iterable"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_enumerate"} type={"(iterable, start=None, *, ctx) -> Expr"}>

enumerate(iterable, start=0) -> iterable.map((v, i) => [i + start, v])

<PySourceCode >

```python
@transformer("enumerate")
def emit_enumerate(iterable: Any, start: Any = None, *, ctx: Transpiler) -> Expr:
	"""enumerate(iterable, start=0) -> iterable.map((v, i) => [i + start, v])"""
	base = Literal(0) if start is None else ctx.emit_expr(start)
	return Call(
		Member(ctx.emit_expr(iterable), "map"),
		[
			Arrow(
				["v", "i"],
				Array([Binary(Identifier("i"), "+", base), Identifier("v")]),
			)
		],
	)
```

</PySourceCode>

<div >

<PyParameter name={"iterable"} type={"Any"} value={null} />
<PyParameter name={"start"} type={"Any"} value={"None"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_range"} type={"(*args, /, *, ctx) -> Expr"}>

range(stop) or range(start, stop[, step]) -> Array.from(...)

<PySourceCode >

```python
@transformer("range")
def emit_range(*args: Any, ctx: Transpiler) -> Expr:
	"""range(stop) or range(start, stop[, step]) -> Array.from(...)"""
	if not (1 <= builtins.len(args) <= 3):
		raise TranspileError("range() expects 1 to 3 arguments")
	if builtins.len(args) == 1:
		stop = ctx.emit_expr(args[0])
		length = Call(Member(Identifier("Math"), "max"), [Literal(0), stop])
		return Call(
			Member(Identifier("Array"), "from"),
			[Call(Member(New(Identifier("Array"), [length]), "keys"), [])],
		)
	start = ctx.emit_expr(args[0])
	stop = ctx.emit_expr(args[1])
	step = ctx.emit_expr(args[2]) if builtins.len(args) == 3 else Literal(1)
	# count = max(0, ceil((stop - start) / step))
	diff = Binary(stop, "-", start)
	div = Binary(diff, "/", step)
	ceil = Call(Member(Identifier("Math"), "ceil"), [div])
	count = Call(Member(Identifier("Math"), "max"), [Literal(0), ceil])
	# Array.from(new Array(count).keys(), i => start + i * step)
	return Call(
		Member(Identifier("Array"), "from"),
		[
			Call(Member(New(Identifier("Array"), [count]), "keys"), []),
			Arrow(["i"], Binary(start, "+", Binary(Identifier("i"), "*", step))),
		],
	)
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_sorted"} type={"(*args, /, *, key=None, reverse=None, ctx) -> Expr"}>

sorted(iterable, key=None, reverse=False) -> iterable.slice().sort(...)

<PySourceCode >

```python
@transformer("sorted")
def emit_sorted(
	*args: Any, key: Any = None, reverse: Any = None, ctx: Transpiler
) -> Expr:
	"""sorted(iterable, key=None, reverse=False) -> iterable.slice().sort(...)"""
	if builtins.len(args) != 1:
		raise TranspileError("sorted() expects exactly one positional argument")
	iterable = ctx.emit_expr(args[0])
	clone = Call(Member(iterable, "slice"), [])
	# comparator: (a, b) => (a > b) - (a < b) or with key
	if key is None:
		cmp_expr = Binary(
			Binary(Identifier("a"), ">", Identifier("b")),
			"-",
			Binary(Identifier("a"), "<", Identifier("b")),
		)
	else:
		key_js = ctx.emit_expr(key)
		cmp_expr = Binary(
			Binary(
				Call(key_js, [Identifier("a")]),
				">",
				Call(key_js, [Identifier("b")]),
			),
			"-",
			Binary(
				Call(key_js, [Identifier("a")]),
				"<",
				Call(key_js, [Identifier("b")]),
			),
		)
	sort_call = Call(Member(clone, "sort"), [Arrow(["a", "b"], cmp_expr)])
	if reverse is None:
		return sort_call
	return Ternary(
		ctx.emit_expr(reverse), Call(Member(sort_call, "reverse"), []), sort_call
	)
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"key"} type={"Any"} value={"None"} />
<PyParameter name={"reverse"} type={"Any"} value={"None"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_zip"} type={"(*args, /, *, ctx) -> Expr"}>

zip(*iterables) -> Array.from(...) with paired elements

<PySourceCode >

```python
@transformer("zip")
def emit_zip(*args: Any, ctx: Transpiler) -> Expr:
	"""zip(*iterables) -> Array.from(...) with paired elements"""
	if builtins.len(args) == 0:
		return Array([])

	js_args = [ctx.emit_expr(a) for a in args]

	def length_of(x: Expr) -> Expr:
		return Member(x, "length")

	min_len = length_of(js_args[0])
	for it in js_args[1:]:
		min_len = Call(Member(Identifier("Math"), "min"), [min_len, length_of(it)])

	elems = [Subscript(arg, Identifier("i")) for arg in js_args]
	make_pair = Arrow(["i"], Array(elems))
	return Call(
		Member(Identifier("Array"), "from"),
		[Call(Member(New(Identifier("Array"), [min_len]), "keys"), []), make_pair],
	)
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_pow"} type={"(base, exp, *, ctx) -> Expr"}>

pow(base, exp) -> Math.pow(base, exp)

<PySourceCode >

```python
@transformer("pow")
def emit_pow(base: Any, exp: Any, *, ctx: Transpiler) -> Expr:
	"""pow(base, exp) -> Math.pow(base, exp)"""
	return Call(
		Member(Identifier("Math"), "pow"), [ctx.emit_expr(base), ctx.emit_expr(exp)]
	)
```

</PySourceCode>

<div >

<PyParameter name={"base"} type={"Any"} value={null} />
<PyParameter name={"exp"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_chr"} type={"(x, *, ctx) -> Expr"}>

chr(x) -> String.fromCharCode(x)

<PySourceCode >

```python
@transformer("chr")
def emit_chr(x: Any, *, ctx: Transpiler) -> Expr:
	"""chr(x) -> String.fromCharCode(x)"""
	return Call(Member(Identifier("String"), "fromCharCode"), [ctx.emit_expr(x)])
```

</PySourceCode>

<div >

<PyParameter name={"x"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_ord"} type={"(x, *, ctx) -> Expr"}>

ord(x) -> x.charCodeAt(0)

<PySourceCode >

```python
@transformer("ord")
def emit_ord(x: Any, *, ctx: Transpiler) -> Expr:
	"""ord(x) -> x.charCodeAt(0)"""
	return Call(Member(ctx.emit_expr(x), "charCodeAt"), [Literal(0)])
```

</PySourceCode>

<div >

<PyParameter name={"x"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_any"} type={"(x, *, ctx) -> Expr"}>

any(iterable) -> iterable.some(v => v)

<PySourceCode >

```python
@transformer("any")
def emit_any(x: Any, *, ctx: Transpiler) -> Expr:
	"""any(iterable) -> iterable.some(v => v)"""
	x = ctx.emit_expr(x)
	# Optimization: if x is a map call, use .some directly
	if (
		builtins.isinstance(x, Call)
		and builtins.isinstance(x.callee, Member)
		and x.callee.prop == "map"
		and x.args
	):
		return Call(Member(x.callee.obj, "some"), [x.args[0]])
	return Call(Member(x, "some"), [Arrow(["v"], Identifier("v"))])
```

</PySourceCode>

<div >

<PyParameter name={"x"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_all"} type={"(x, *, ctx) -> Expr"}>

all(iterable) -> iterable.every(v => v)

<PySourceCode >

```python
@transformer("all")
def emit_all(x: Any, *, ctx: Transpiler) -> Expr:
	"""all(iterable) -> iterable.every(v => v)"""
	x = ctx.emit_expr(x)
	# Optimization: if x is a map call, use .every directly
	if (
		builtins.isinstance(x, Call)
		and builtins.isinstance(x.callee, Member)
		and x.callee.prop == "map"
		and x.args
	):
		return Call(Member(x.callee.obj, "every"), [x.args[0]])
	return Call(Member(x, "every"), [Arrow(["v"], Identifier("v"))])
```

</PySourceCode>

<div >

<PyParameter name={"x"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_sum"} type={"(*args, /, *, ctx) -> Expr"}>

sum(iterable, start=0) -> iterable.reduce((a, b) => a + b, start)

<PySourceCode >

```python
@transformer("sum")
def emit_sum(*args: Any, ctx: Transpiler) -> Expr:
	"""sum(iterable, start=0) -> iterable.reduce((a, b) => a + b, start)"""
	if not (1 <= builtins.len(args) <= 2):
		raise TranspileError("sum() expects one or two arguments")
	start = ctx.emit_expr(args[1]) if builtins.len(args) == 2 else Literal(0)
	base = ctx.emit_expr(args[0])
	reducer = Arrow(["a", "b"], Binary(Identifier("a"), "+", Identifier("b")))
	return Call(Member(base, "reduce"), [reducer, start])
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_divmod"} type={"(x, y, *, ctx) -> Expr"}>

divmod(x, y) -> [Math.floor(x / y), x - Math.floor(x / y) * y]

<PySourceCode >

```python
@transformer("divmod")
def emit_divmod(x: Any, y: Any, *, ctx: Transpiler) -> Expr:
	"""divmod(x, y) -> [Math.floor(x / y), x - Math.floor(x / y) * y]"""
	x, y = ctx.emit_expr(x), ctx.emit_expr(y)
	q = Call(Member(Identifier("Math"), "floor"), [Binary(x, "/", y)])
	r = Binary(x, "-", Binary(q, "*", y))
	return Array([q, r])
```

</PySourceCode>

<div >

<PyParameter name={"x"} type={"Any"} value={null} />
<PyParameter name={"y"} type={"Any"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_isinstance"} type={"(*args, /, *, ctx) -> Expr"}>

isinstance is not directly supported in v2; raise error.

<PySourceCode >

```python
@transformer("isinstance")
def emit_isinstance(*args: Any, ctx: Transpiler) -> Expr:
	"""isinstance is not directly supported in v2; raise error."""
	raise TranspileError("isinstance() is not supported in JavaScript transpilation")
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_exception"} type={"(*args, /, *, ctx) -> Expr"}>

Exception(msg) -> new Error(msg)

<PySourceCode >

```python
@transformer("Exception")
def emit_exception(*args: Any, ctx: Transpiler) -> Expr:
	"""Exception(msg) -> new Error(msg)"""
	return New(Identifier("Error"), [ctx.emit_expr(a) for a in args])
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_value_error"} type={"(*args, /, *, ctx) -> Expr"}>

ValueError(msg) -> new Error(msg)

<PySourceCode >

```python
@transformer("ValueError")
def emit_value_error(*args: Any, ctx: Transpiler) -> Expr:
	"""ValueError(msg) -> new Error(msg)"""
	return New(Identifier("Error"), [ctx.emit_expr(a) for a in args])
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_type_error"} type={"(*args, /, *, ctx) -> Expr"}>

TypeError(msg) -> new TypeError(msg)

<PySourceCode >

```python
@transformer("TypeError")
def emit_type_error(*args: Any, ctx: Transpiler) -> Expr:
	"""TypeError(msg) -> new TypeError(msg)"""
	return New(Identifier("TypeError"), [ctx.emit_expr(a) for a in args])
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"emit_runtime_error"} type={"(*args, /, *, ctx) -> Expr"}>

RuntimeError(msg) -> new Error(msg)

<PySourceCode >

```python
@transformer("RuntimeError")
def emit_runtime_error(*args: Any, ctx: Transpiler) -> Expr:
	"""RuntimeError(msg) -> new Error(msg)"""
	return New(Identifier("Error"), [ctx.emit_expr(a) for a in args])
```

</PySourceCode>

<div >

<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>
<PyFunction name={"_try_dispatch_method"} type={"(cls, obj, method, args, kwargs=None) -> Expr | None"}>

Try to dispatch a method call to a specific builtin class.

Returns the transformed expression, or None if the method returns None
(fall through to default) or if dispatch fails.

<PySourceCode >

```python
def _try_dispatch_method(
	cls: builtins.type[BuiltinMethods],
	obj: Expr,
	method: str,
	args: list[Expr],
	kwargs: builtins.dict[builtins.str, Expr] | None = None,
) -> Expr | None:
	"""Try to dispatch a method call to a specific builtin class.

	Returns the transformed expression, or None if the method returns None
	(fall through to default) or if dispatch fails.
	"""
	if method not in cls.__methods__():
		return None

	try:
		handler = cls(obj)
		method_fn = builtins.getattr(handler, method, None)
		if method_fn is None:
			return None
		if kwargs:
			return method_fn(*args, **kwargs)
		return method_fn(*args)
	except TypeError:
		return None
```

</PySourceCode>

<div >

<PyParameter name={"cls"} type={"builtins.type[BuiltinMethods]"} value={null} />
<PyParameter name={"obj"} type={"Expr"} value={null} />
<PyParameter name={"method"} type={"str"} value={null} />
<PyParameter name={"args"} type={"list[Expr]"} value={null} />
<PyParameter name={"kwargs"} type={"builtins.dict[builtins.str, Expr] | None"} value={"None"} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr | None"} />

</PyFunction>
<PyFunction name={"emit_method"} type={"(obj, method, args, kwargs=None) -> Expr | None"}>

Emit a method call, handling Python builtin methods.

For known literal types (Literal str, Template, Array, New Set/Map),
dispatches directly without runtime checks.

For unknown types, builds a ternary chain that checks types at runtime
and dispatches to the appropriate method implementation.

<PySourceCode >

```python
def emit_method(
	obj: Expr,
	method: str,
	args: list[Expr],
	kwargs: builtins.dict[builtins.str, Expr] | None = None,
) -> Expr | None:
	"""Emit a method call, handling Python builtin methods.

	For known literal types (Literal str, Template, Array, New Set/Map),
	dispatches directly without runtime checks.

	For unknown types, builds a ternary chain that checks types at runtime
	and dispatches to the appropriate method implementation.

	Returns:
		Expr if the method should be transpiled specially
		None if the method should be emitted as a regular method call
	"""
	if method not in ALL_METHODS:
		return None

	# Fast path: known literal types - dispatch directly without runtime checks
	if builtins.isinstance(obj, Literal) and builtins.isinstance(obj.value, str):
		if method in StringMethods.__methods__():
			result = _try_dispatch_method(StringMethods, obj, method, args, kwargs)
			if result is not None:
				return result
		return None

	if builtins.isinstance(obj, Template):
		if method in StringMethods.__methods__():
			result = _try_dispatch_method(StringMethods, obj, method, args, kwargs)
			if result is not None:
				return result
		return None

	if builtins.isinstance(obj, Array):
		if method in ListMethods.__methods__():
			result = _try_dispatch_method(ListMethods, obj, method, args, kwargs)
			if result is not None:
				return result
		return None

	# Fast path: new Set(...) and new Map(...) are known types
	if builtins.isinstance(obj, New) and builtins.isinstance(obj.ctor, Identifier):
		if obj.ctor.name == "Set" and method in SetMethods.__methods__():
			result = _try_dispatch_method(SetMethods, obj, method, args, kwargs)
			if result is not None:
				return result
			return None
		if obj.ctor.name == "Map" and method in DictMethods.__methods__():
			result = _try_dispatch_method(DictMethods, obj, method, args, kwargs)
			if result is not None:
				return result
			return None

	# Slow path: unknown type - build ternary chain with runtime type checks
	# Start with the default fallback (regular method call)
	default_expr = Call(Member(obj, method), args)
	expr: Expr = default_expr

	# Apply in increasing priority so that later (higher priority) wrappers
	# end up outermost in the final expression.
	for cls in METHOD_CLASSES:
		if method not in cls.__methods__():
			continue

		dispatch_expr = _try_dispatch_method(cls, obj, method, args, kwargs)
		if dispatch_expr is not None:
			expr = Ternary(cls.__runtime_check__(obj), dispatch_expr, expr)

	# If we built ternaries, return them; otherwise return None to fall through
	if expr is not default_expr:
		return expr

	return None
```

</PySourceCode>

<div >

<PyParameter name={"obj"} type={"Expr"} value={null} />
<PyParameter name={"method"} type={"str"} value={null} />
<PyParameter name={"args"} type={"list[Expr]"} value={null} />
<PyParameter name={"kwargs"} type={"builtins.dict[builtins.str, Expr] | None"} value={"None"} />

</div>

<PyFunctionReturn type={"Expr | None"}>

Expr if the method should be transpiled specially

</PyFunctionReturn>

</PyFunction>

</Tab>

</Tabs>