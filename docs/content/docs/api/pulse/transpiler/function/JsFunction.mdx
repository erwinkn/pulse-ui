---
title: "JsFunction"
---

A transpiled JavaScript function.

Wraps a Python function with:
- A unique identifier for deduplication
- Resolved dependencies (other functions, imports, constants, etc.)
- The ability to transpile to JavaScript code

When emitted, produces the unique JS function name (e.g., "myFunc_1").

## Attributes

<PyAttribute name={"fn"} type={"Callable[[*Args], R]"} value={"fn"} />

<PyAttribute name={"id"} type={"str"} value={"next_id()"} />

<PyAttribute name={"deps"} type={"dict[str, Expr]"} value={"analyze_deps(fn)"} />

<PyAttribute name={"js_name"} type={"str"} value={null}>

Unique JS identifier for this function.

</PyAttribute>

## Functions

<PyFunction name={"__init__"} type={"(self, fn, *, _register=True) -> None"}>

<PySourceCode >

```python
def __init__(self, fn: Callable[..., Any], *, _register: bool = True) -> None:
	self.fn = fn
	self.id = next_id()
	self._transpiled = None
	if _register:
		# Register self in cache BEFORE analyzing deps (handles cycles)
		FUNCTION_CACHE[fn] = self
	# Now analyze and build deps (may recursively call JsFunction() which will find us in cache)
	self.deps = analyze_deps(fn)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"fn"} type={"Callable[..., Any]"} value={null} />
<PyParameter name={"_register"} type={"bool"} value={"True"} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"__call__"} type={"(self, *args) -> R"}>

<PySourceCode >

```python
@override
def __call__(self, *args: *Args) -> R:  # pyright: ignore[reportIncompatibleMethodOverride]
	return Expr.__call__(self, *args)  # pyright: ignore[reportReturnType]
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"args"} type={"*Args"} value={"()"} />

</div>

<PyFunctionReturn type={"pulse.transpiler.function.R"} />

</PyFunction>

<PyFunction name={"emit"} type={"(self, out) -> None"}>

Emit this function as its unique JS identifier.

<PySourceCode >

```python
@override
def emit(self, out: list[str]) -> None:
	"""Emit this function as its unique JS identifier."""
	out.append(self.js_name)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"out"} type={"list[str]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"render"} type={"(self) -> VDOMNode"}>

Render as a registry reference.

<PySourceCode >

```python
@override
def render(self) -> VDOMNode:
	"""Render as a registry reference."""
	return {"t": "ref", "key": self.id}
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.vdom.VDOMNode"} />

</PyFunction>

<PyFunction name={"transpile"} type={"(self) -> Function"}>

Transpile this function to a v2 Function node.

Returns the Function node (cached after first call).

<PySourceCode >

```python
def transpile(self) -> Function:
	"""Transpile this function to a v2 Function node.

	Returns the Function node (cached after first call).
	"""
	if self._transpiled is not None:
		return self._transpiled

	result, _ = _transpile_function_body(self.fn, self.deps)

	# Convert Arrow to Function if needed, and set the name
	if isinstance(result, Function):
		result = Function(
			params=result.params,
			body=result.body,
			name=self.js_name,
			is_async=result.is_async,
		)
	else:
		# Arrow - wrap in Function with name
		result = Function(
			params=list(result.params),
			body=[Return(result.body)]
			if isinstance(result.body, Expr)
			else result.body,
			name=self.js_name,
			is_async=False,
		)

	self._transpiled = result
	return result
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Function"} />

</PyFunction>

<PyFunction name={"imports"} type={"(self) -> dict[str, Expr]"}>

Get all Import dependencies.

<PySourceCode >

```python
def imports(self) -> dict[str, Expr]:
	"""Get all Import dependencies."""
	return {k: v for k, v in self.deps.items() if isinstance(v, Import)}
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"dict[str, pulse.transpiler.nodes.Expr]"} />

</PyFunction>

<PyFunction name={"functions"} type={"(self) -> dict[str, AnyJsFunction]"}>

Get all JsFunction dependencies.

<PySourceCode >

```python
def functions(self) -> dict[str, AnyJsFunction]:
	"""Get all JsFunction dependencies."""
	return {
		k: v
		for k, v in self.deps.items()
		if isinstance(v, (JsFunction, JsxFunction))
	}
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"dict[str, pulse.transpiler.function.AnyJsFunction]"} />

</PyFunction>