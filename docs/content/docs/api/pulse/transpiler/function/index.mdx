---
title: "function"
---

Function transpilation system for transpiler.

Provides the @javascript decorator for marking Python functions for JS transpilation,
and JsFunction which wraps transpiled functions with their dependencies.

<PyAttribute name={"Args"} type={null} value={"TypeVarTuple('Args')"} />

<PyAttribute name={"P"} type={null} value={"ParamSpec('P')"} />

<PyAttribute name={"R"} type={null} value={"TypeVar('R')"} />

<PyAttribute name={"AnyJsFunction"} type={"TypeAlias"} value={"'JsFunction[*tuple[Any, ...], Any] | JsxFunction[..., Any]'"} />

<PyAttribute name={"FUNCTION_CACHE"} type={"dict[Callable[..., Any], AnyJsFunction]"} value={"{}"} />

<PyAttribute name={"CONSTANT_REGISTRY"} type={"dict[int, 'Constant']"} value={"{}"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"Constant"} href={"/docs/api/pulse/transpiler/function/Constant"} />
<Card title={"JsFunction"} href={"/docs/api/pulse/transpiler/function/JsFunction"} />
<Card title={"JsxFunction"} href={"/docs/api/pulse/transpiler/function/JsxFunction"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"clear_function_cache"} type={"() -> None"}>

Clear function/constant/ref caches and reset the shared ID counters.

<PySourceCode >

```python
def clear_function_cache() -> None:
	"""Clear function/constant/ref caches and reset the shared ID counters."""
	from pulse.transpiler.assets import clear_asset_registry
	from pulse.transpiler.imports import clear_import_registry

	FUNCTION_CACHE.clear()
	CONSTANT_REGISTRY.clear()
	clear_import_registry()
	clear_asset_registry()
	reset_id_counter()
```

</PySourceCode>

<PyFunctionReturn type={"None"} />

</PyFunction>
<PyFunction name={"registered_constants"} type={"() -> list[Constant]"}>

Get all registered constants.

<PySourceCode >

```python
def registered_constants() -> list[Constant]:
	"""Get all registered constants."""
	return list(CONSTANT_REGISTRY.values())
```

</PySourceCode>

<PyFunctionReturn type={"list[pulse.transpiler.function.Constant]"} />

</PyFunction>
<PyFunction name={"_transpile_function_body"} type={"(fn, deps, *, jsx=False) -> tuple[Function | Arrow, str]"}>

Shared transpilation logic for JsFunction and JsxFunction.

Returns the transpiled Function/Arrow node and the source code.

<PySourceCode >

```python
def _transpile_function_body(
	fn: Callable[..., Any],
	deps: dict[str, Expr],
	*,
	jsx: bool = False,
) -> tuple[Function | Arrow, str]:
	"""Shared transpilation logic for JsFunction and JsxFunction.

	Returns the transpiled Function/Arrow node and the source code.
	"""
	# Get and parse source
	src = getsourcecode(fn)
	src = textwrap.dedent(src)
	try:
		source_start_line = inspect.getsourcelines(fn)[1]
	except (OSError, TypeError):
		source_start_line = None
	module = ast.parse(src)

	# Find the function definition
	fndefs = [
		n for n in module.body if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef))
	]
	if not fndefs:
		raise TranspileError("No function definition found in source")
	fndef = fndefs[-1]

	# Get filename for error messages and source file resolution
	try:
		filename = inspect.getfile(fn)
	except (TypeError, OSError):
		filename = None

	# Transpile with source context for errors
	try:
		source_file = Path(filename) if filename else None
		transpiler = Transpiler(fndef, deps, jsx=jsx, source_file=source_file)
		result = transpiler.transpile()
	except TranspileError as e:
		# Re-raise with source context if not already present
		if e.source is None:
			raise e.with_context(
				source=src,
				filename=filename,
				func_name=fn.__name__,
				source_start_line=source_start_line,
			) from None
		raise

	return result, src
```

</PySourceCode>

<div >

<PyParameter name={"fn"} type={"Callable[..., Any]"} value={null} />
<PyParameter name={"deps"} type={"dict[str, Expr]"} value={null} />
<PyParameter name={"jsx"} type={"bool"} value={"False"} />

</div>

<PyFunctionReturn type={"tuple[pulse.transpiler.nodes.Function | pulse.transpiler.nodes.Arrow, str]"} />

</PyFunction>
<PyFunction name={"analyze_code_object"} type={"(fn) -> tuple[dict[str, Any], set[str]]"}>

Analyze code object and resolve globals + closure variables.

Returns a tuple of:
    - effective_globals: dict mapping names to their values (includes closure vars)
    - all_names: set of all names referenced in the code (including nested functions)

<PySourceCode >

```python
def analyze_code_object(
	fn: Callable[..., object],
) -> tuple[dict[str, Any], set[str]]:
	"""Analyze code object and resolve globals + closure variables.

	Returns a tuple of:
	    - effective_globals: dict mapping names to their values (includes closure vars)
	    - all_names: set of all names referenced in the code (including nested functions)
	"""
	import dis

	code = fn.__code__

	# Collect all names from code object and nested functions in one pass
	seen_codes: set[int] = set()
	all_names: set[str] = set()

	# Opcodes that load names from globals/locals (not attributes)
	GLOBAL_LOAD_OPS = frozenset(
		{
			"LOAD_GLOBAL",
			"LOAD_NAME",
			"STORE_GLOBAL",
			"STORE_NAME",
			"DELETE_GLOBAL",
			"DELETE_NAME",
		}
	)

	def walk_code(c: pytypes.CodeType) -> None:
		if id(c) in seen_codes:
			return
		seen_codes.add(id(c))

		# Only collect names that are actually loaded as globals, not attributes
		# co_names contains both global names and attribute names, so we need
		# to check the bytecode to distinguish them
		for instr in dis.get_instructions(c):
			if instr.opname in GLOBAL_LOAD_OPS and instr.argval is not None:
				all_names.add(instr.argval)

		all_names.update(c.co_freevars)  # Include closure variables

		for const in c.co_consts:
			if isinstance(const, pytypes.CodeType):
				walk_code(const)

	walk_code(code)

	# Build effective globals dict: start with function's globals, then add closure values
	effective_globals = dict(fn.__globals__)

	# Resolve closure variables from closure cells
	if code.co_freevars and fn.__closure__:
		closure = fn.__closure__
		for i, freevar_name in enumerate(code.co_freevars):
			if i < len(closure):
				cell = closure[i]
				# Get the value from the closure cell
				try:
					effective_globals[freevar_name] = cell.cell_contents
				except ValueError:
					# Cell is empty (unbound), skip it
					pass

	return effective_globals, all_names
```

</PySourceCode>

<div >

<PyParameter name={"fn"} type={"Callable[..., object]"} value={null} />

</div>

<PyFunctionReturn type={"tuple[dict[str, typing.Any], set[str]]"} />

</PyFunction>
<PyFunction name={"analyze_deps"} type={"(fn) -> dict[str, Expr]"}>

Analyze a function and return its dependencies as Expr instances.

Walks the function's code object to find all referenced names,
then resolves them from globals/closure and converts to Expr.

<PySourceCode >

```python
def analyze_deps(fn: Callable[..., Any]) -> dict[str, Expr]:
	"""Analyze a function and return its dependencies as Expr instances.

	Walks the function's code object to find all referenced names,
	then resolves them from globals/closure and converts to Expr.
	"""
	# Analyze code object and resolve globals + closure vars
	effective_globals, all_names = analyze_code_object(fn)

	# Build dependencies dictionary - all values are Expr
	deps: dict[str, Expr] = {}

	for name in all_names:
		value = effective_globals.get(name)

		if value is None:
			# Not in globals - could be a builtin or unresolved
			# For now, skip - builtins will be handled by the transpiler
			# TODO: Add builtin support
			continue

		# Already an Expr
		if isinstance(value, Expr):
			deps[name] = value
			continue

		# Check global registry (for registered values like math.floor)
		if id(value) in EXPR_REGISTRY:
			deps[name] = EXPR_REGISTRY[id(value)]
			continue

		# Module imports must be registered (module object itself is in EXPR_REGISTRY)
		if inspect.ismodule(value):
			raise TranspileError(
				f"Could not resolve module '{name}' (value: {value!r}). "
				+ "Register the module (or its values) in EXPR_REGISTRY."
			)

		# Functions - check cache, then create JsFunction
		if inspect.isfunction(value):
			if value in FUNCTION_CACHE:
				deps[name] = FUNCTION_CACHE[value]
			else:
				deps[name] = JsFunction(value)
			continue

		# Skip Expr subclasses (the classes themselves) as they are often
		# used for type hinting or within function scope and handled
		# by the transpiler via other means (e.g. BUILTINS or special cases)
		if isinstance(value, type) and issubclass(value, Expr):
			continue

		# Other callables (classes, methods, etc.) - not supported
		if callable(value):  # pyright: ignore[reportUnknownArgumentType]
			raise TranspileError(
				f"Callable '{name}' (type: {type(value).__name__}) is not supported. "  # pyright: ignore[reportUnknownArgumentType]
				+ "Only functions can be transpiled."
			)

		# Constants - primitives inline, non-primitives hoisted
		if isinstance(value, (bool, int, float, str)) or value is None:
			deps[name] = Expr.of(value)
		else:
			# Non-primitive: wrap in Constant for hoisting
			try:
				deps[name] = Constant.wrap(value, name)
			except TypeError:
				raise TranspileError(
					f"Cannot convert '{name}' (type: {type(value).__name__}) to Expr"
				) from None

	return deps
```

</PySourceCode>

<div >

<PyParameter name={"fn"} type={"Callable[..., Any]"} value={null} />

</div>

<PyFunctionReturn type={"dict[str, pulse.transpiler.nodes.Expr]"} />

</PyFunction>
<PyFunction name={"javascript"} type={"(fn=None, *, jsx=False) -> Any"}>

Decorator to convert a Python function into a JsFunction or JsxFunction.

When jsx=False (default), returns a JsFunction instance.
When jsx=True, returns a JsxFunction instance.

Both are cached in FUNCTION_CACHE for deduplication and code generation.

<PySourceCode >

```python
def javascript(fn: Callable[[*Args], R] | None = None, *, jsx: bool = False) -> Any:
	"""Decorator to convert a Python function into a JsFunction or JsxFunction.

	When jsx=False (default), returns a JsFunction instance.
	When jsx=True, returns a JsxFunction instance.

	Both are cached in FUNCTION_CACHE for deduplication and code generation.
	"""

	def decorator(f: Callable[[*Args], R]) -> Any:
		cached = FUNCTION_CACHE.get(f)
		if cached is not None:
			# Already cached - return as-is (respects original jsx setting)
			return cached

		if jsx:
			# Create JsxFunction for React component semantics
			jsx_fn = JsxFunction(f)
			# Preserve the original function's type signature for type checkers
			return jsx_fn.as_(type(f))

		# Create regular JsFunction
		return JsFunction(f)

	if fn is not None:
		return decorator(fn)
	return decorator
```

</PySourceCode>

<div >

<PyParameter name={"fn"} type={"Callable[[*Args], R] | None"} value={"None"} />
<PyParameter name={"jsx"} type={"bool"} value={"False"} />

</div>

<PyFunctionReturn type={"typing.Any"} />

</PyFunction>
<PyFunction name={"registered_functions"} type={"() -> list[AnyJsFunction]"}>

Get all registered JS functions.

<PySourceCode >

```python
def registered_functions() -> list[AnyJsFunction]:
	"""Get all registered JS functions."""
	return list(FUNCTION_CACHE.values())
```

</PySourceCode>

<PyFunctionReturn type={"list[pulse.transpiler.function.AnyJsFunction]"} />

</PyFunction>
<PyFunction name={"_unwrap_jsfunction"} type={"(expr) -> AnyJsFunction | None"}>

Unwrap common wrappers to get the underlying JsFunction or JsxFunction.

<PySourceCode >

```python
def _unwrap_jsfunction(expr: Expr) -> AnyJsFunction | None:
	"""Unwrap common wrappers to get the underlying JsFunction or JsxFunction."""
	if isinstance(expr, (JsFunction, JsxFunction)):
		return expr
	if isinstance(expr, Jsx):
		inner = expr.expr
		if isinstance(inner, Expr):
			return _unwrap_jsfunction(inner)
	return None
```

</PySourceCode>

<div >

<PyParameter name={"expr"} type={"Expr"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.function.AnyJsFunction | None"} />

</PyFunction>
<PyFunction name={"collect_function_graph"} type={"(functions=None) -> tuple[list[Constant], list[AnyJsFunction]]"}>

Collect all constants and functions in dependency order (depth-first).

<PySourceCode >

```python
def collect_function_graph(
	functions: list[AnyJsFunction] | None = None,
) -> tuple[list[Constant], list[AnyJsFunction]]:
	"""Collect all constants and functions in dependency order (depth-first).

	Args:
		functions: Functions to walk. If None, uses all registered functions.

	Returns:
		Tuple of (constants, functions) in dependency order.
	"""
	if functions is None:
		functions = registered_functions()

	seen_funcs: set[str] = set()
	seen_consts: set[str] = set()
	all_funcs: list[AnyJsFunction] = []
	all_consts: list[Constant] = []

	def walk(fn: AnyJsFunction) -> None:
		if fn.id in seen_funcs:
			return
		seen_funcs.add(fn.id)

		for dep in fn.deps.values():
			if isinstance(dep, Constant):
				if dep.id not in seen_consts:
					seen_consts.add(dep.id)
					all_consts.append(dep)
				continue
			if isinstance(dep, Expr):
				inner_fn = _unwrap_jsfunction(dep)
				if inner_fn is not None:
					walk(inner_fn)

		all_funcs.append(fn)

	for fn in functions:
		walk(fn)

	return all_consts, all_funcs
```

</PySourceCode>

<div >

<PyParameter name={"functions"} type={"list[AnyJsFunction] | None"} value={"None"}>

Functions to walk. If None, uses all registered functions.

</PyParameter>

</div>

<PyFunctionReturn type={"tuple"}>

Tuple of (constants, functions) in dependency order.

</PyFunctionReturn>

</PyFunction>

</Tab>

</Tabs>