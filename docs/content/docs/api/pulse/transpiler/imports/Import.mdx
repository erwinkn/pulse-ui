---
title: "Import"
---

JS import that auto-registers and dedupes.

An Expr that emits as its unique identifier (e.g., useState_1).
Overrides transpile_call for JSX component behavior and transpile_getattr for
member access.

## Attributes

<PyAttribute name={"name"} type={"str"} value={"name"} />

<PyAttribute name={"src"} type={"str"} value={"import_src"} />

<PyAttribute name={"kind"} type={"ImportKind"} value={"kind"} />

<PyAttribute name={"is_type"} type={"bool"} value={null} />

<PyAttribute name={"lazy"} type={"bool"} value={"lazy"} />

<PyAttribute name={"before"} type={"tuple[str, ...]"} value={null} />

<PyAttribute name={"id"} type={"str"} value={null} />

<PyAttribute name={"version"} type={"str | None"} value={"version"} />

<PyAttribute name={"asset"} type={"LocalAsset | None"} value={"asset"} />

<PyAttribute name={"js_name"} type={"str"} value={null}>

Unique JS identifier for this import.

</PyAttribute>

<PyAttribute name={"is_local"} type={"bool"} value={null}>

Check if this is a local file import (has registered asset).

</PyAttribute>

<PyAttribute name={"is_lazy"} type={"bool"} value={null}>

Check if this is a lazy import.

</PyAttribute>

<PyAttribute name={"is_default"} type={"bool"} value={null} />

<PyAttribute name={"is_namespace"} type={"bool"} value={null} />

<PyAttribute name={"is_side_effect"} type={"bool"} value={null} />

## Functions

<PyFunction name={"__init__"} type={"(self, name, src, *, kind=None, is_type=False, lazy=False, version=None, before=(), _caller_depth=2) -> None"}>

<PySourceCode >

```python
def __init__(
	self,
	name: str,
	src: str,
	*,
	kind: ImportKind | None = None,
	is_type: bool = False,
	lazy: bool = False,
	version: str | None = None,
	before: tuple[str, ...] | list[str] = (),
	_caller_depth: int = 2,
) -> None:
	# Validate: lazy imports cannot be type-only
	if lazy and is_type:
		raise TranspileError("Import cannot be both lazy and type-only")

	# Auto-resolve local paths (relative or absolute) to actual files
	asset: LocalAsset | None = None
	import_src = src

	if is_local_path(src):
		# Resolve to actual file (handles JS extension resolution)
		caller = caller_file(depth=_caller_depth) if is_relative_path(src) else None
		resolved = resolve_local_path(src, caller)
		if resolved is not None:
			# Register with unified asset registry
			asset = register_local_asset(resolved)
			import_src = str(resolved)

	# Default kind to "named" if not specified
	if kind is None:
		kind = "named"

	self.name = name
	self.src = import_src
	self.kind = kind
	self.version = version
	self.lazy = lazy
	self.asset = asset

	before_tuple = tuple(before) if isinstance(before, list) else before

	# Dedupe key: includes lazy flag to keep lazy and eager imports separate
	if kind == "named":
		key: _ImportKey = (name, import_src, "named", lazy)
	else:
		key = ("", import_src, kind, lazy)

	if key in _IMPORT_REGISTRY:
		existing = _IMPORT_REGISTRY[key]

		# Merge: type-only + regular = regular
		if existing.is_type and not is_type:
			existing.is_type = False

		# Merge: union of before constraints
		if before_tuple:
			merged_before = set(existing.before) | set(before_tuple)
			existing.before = tuple(sorted(merged_before))

		# Merge: version
		existing.version = pick_more_specific(existing.version, version)

		# Reuse ID and merged values
		self.id = existing.id
		self.is_type = existing.is_type
		self.before = existing.before
		self.version = existing.version
	else:
		# New import
		self.id = next_id()
		self.is_type = is_type
		self.before = before_tuple
		_IMPORT_REGISTRY[key] = self
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"name"} type={"str"} value={null} />
<PyParameter name={"src"} type={"str"} value={null} />
<PyParameter name={"kind"} type={"ImportKind | None"} value={"None"} />
<PyParameter name={"is_type"} type={"bool"} value={"False"} />
<PyParameter name={"lazy"} type={"bool"} value={"False"} />
<PyParameter name={"version"} type={"str | None"} value={"None"} />
<PyParameter name={"before"} type={"tuple[str, ...] | list[str]"} value={"()"} />
<PyParameter name={"_caller_depth"} type={"int"} value={"2"} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"emit"} type={"(self, out) -> None"}>

Emit this import as its unique JS identifier.

<PySourceCode >

```python
@override
def emit(self, out: list[str]) -> None:
	"""Emit this import as its unique JS identifier."""
	out.append(self.js_name)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"out"} type={"list[str]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"render"} type={"(self) -> VDOMNode"}>

Render as a registry reference.

<PySourceCode >

```python
@override
def render(self) -> VDOMNode:
	"""Render as a registry reference."""
	return {"t": "ref", "key": self.id}
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.vdom.VDOMNode"} />

</PyFunction>

<PyFunction name={"__call__"} type={"(self, *args, **kwargs) -> 'Call'"}>

Allow calling Import objects in Python code.

Returns a Call expression.

<PySourceCode >

```python
@override
def __call__(self, *args: Any, **kwargs: Any) -> "Call":
	"""Allow calling Import objects in Python code.

	Returns a Call expression.
	"""
	return Expr.__call__(self, *args, **kwargs)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"kwargs"} type={"Any"} value={"{}"} />

</div>

<PyFunctionReturn type={"'Call'"} />

</PyFunction>