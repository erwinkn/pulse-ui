---
title: "imports"
---

Import with auto-registration for transpiler.

<PyAttribute name={"ImportKind"} type={"TypeAlias"} value={"Lit['named', 'default', 'namespace', 'side_effect']"} />

<Tabs items={["Class","Functions"]}>

<Tab value={"Class"}>

<Cards >

<Card title={"Import"} href={"/docs/api/pulse/transpiler/imports/Import"} />

</Cards>

</Tab>
<Tab value={"Functions"}>

<PyFunction name={"caller_file"} type={"(depth=2) -> Path"}>

Get the file path of the caller.

<PySourceCode >

```python
def caller_file(depth: int = 2) -> Path:
	"""Get the file path of the caller."""
	frame = inspect.currentframe()
	try:
		for _ in range(depth):
			if frame is None:
				raise RuntimeError("Could not determine caller file")
			frame = frame.f_back
		if frame is None:
			raise RuntimeError("Could not determine caller file")
		return Path(frame.f_code.co_filename)
	finally:
		del frame
```

</PySourceCode>

<div >

<PyParameter name={"depth"} type={"int"} value={"2"} />

</div>

<PyFunctionReturn type={"pathlib.Path"} />

</PyFunction>
<PyFunction name={"is_relative_path"} type={"(path) -> bool"}>

Check if path is a relative import (starts with ./ or ../).

<PySourceCode >

```python
def is_relative_path(path: str) -> bool:
	"""Check if path is a relative import (starts with ./ or ../)."""
	return path.startswith("./") or path.startswith("../")
```

</PySourceCode>

<div >

<PyParameter name={"path"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"bool"} />

</PyFunction>
<PyFunction name={"is_absolute_path"} type={"(path) -> bool"}>

Check if path is an absolute filesystem path.

<PySourceCode >

```python
def is_absolute_path(path: str) -> bool:
	"""Check if path is an absolute filesystem path."""
	return path.startswith("/")
```

</PySourceCode>

<div >

<PyParameter name={"path"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"bool"} />

</PyFunction>
<PyFunction name={"is_local_path"} type={"(path) -> bool"}>

Check if path is a local file path (relative or absolute).

<PySourceCode >

```python
def is_local_path(path: str) -> bool:
	"""Check if path is a local file path (relative or absolute)."""
	return is_relative_path(path) or is_absolute_path(path)
```

</PySourceCode>

<div >

<PyParameter name={"path"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"bool"} />

</PyFunction>
<PyFunction name={"resolve_js_file"} type={"(base_path) -> Path | None"}>

Resolve a JS-like import path to an actual file.

Follows ESM resolution order:
1. Exact path (if has extension)
2. Try JS extensions: .ts, .tsx, .js, .jsx, .mjs, .mts
3. Try /index with each extension

Returns None if no file is found.

<PySourceCode >

```python
def resolve_js_file(base_path: Path) -> Path | None:
	"""Resolve a JS-like import path to an actual file.

	Follows ESM resolution order:
	1. Exact path (if has extension)
	2. Try JS extensions: .ts, .tsx, .js, .jsx, .mjs, .mts
	3. Try /index with each extension

	Returns None if no file is found.
	"""
	# If path already has an extension that exists, use it
	if base_path.suffix and base_path.exists():
		return base_path

	# If no extension, try JS-like extensions
	if not base_path.suffix:
		for ext in _JS_EXTENSIONS:
			candidate = base_path.with_suffix(ext)
			if candidate.exists():
				return candidate

		# Try /index with each extension
		for ext in _JS_EXTENSIONS:
			candidate = base_path / f"index{ext}"
			if candidate.exists():
				return candidate

	return None
```

</PySourceCode>

<div >

<PyParameter name={"base_path"} type={"Path"} value={null} />

</div>

<PyFunctionReturn type={"pathlib.Path | None"} />

</PyFunction>
<PyFunction name={"resolve_local_path"} type={"(path, caller=None) -> Path | None"}>

Resolve a local import path to an actual file.

For relative paths, resolves relative to caller.
For absolute paths, uses the path directly.

For paths without extensions, tries JS-like resolution.
Falls back to the raw resolved path if the file doesn't exist
(might be a generated file or future file).

Returns None only for non-local paths or relative paths without a caller.

<PySourceCode >

```python
def resolve_local_path(path: str, caller: Path | None = None) -> Path | None:
	"""Resolve a local import path to an actual file.

	For relative paths, resolves relative to caller.
	For absolute paths, uses the path directly.

	For paths without extensions, tries JS-like resolution.
	Falls back to the raw resolved path if the file doesn't exist
	(might be a generated file or future file).

	Returns None only for non-local paths or relative paths without a caller.
	"""
	if is_relative_path(path):
		if caller is None:
			return None
		base_path = (caller.parent / Path(path)).resolve()
	elif is_absolute_path(path):
		base_path = Path(path).resolve()
	else:
		return None

	# If the path has an extension, return it (even if it doesn't exist)
	if base_path.suffix:
		return base_path

	# Try JS-like resolution for existing files
	resolved = resolve_js_file(base_path)
	if resolved is not None:
		return resolved

	# Fallback: return the base path even if the file doesn't exist
	return base_path
```

</PySourceCode>

<div >

<PyParameter name={"path"} type={"str"} value={null} />
<PyParameter name={"caller"} type={"Path | None"} value={"None"} />

</div>

<PyFunctionReturn type={"pathlib.Path | None"} />

</PyFunction>
<PyFunction name={"get_registered_imports"} type={"() -> list['Import']"}>

Get all registered imports.

<PySourceCode >

```python
def get_registered_imports() -> list["Import"]:
	"""Get all registered imports."""
	return list(_IMPORT_REGISTRY.values())
```

</PySourceCode>

<PyFunctionReturn type={"list['Import']"} />

</PyFunction>
<PyFunction name={"clear_import_registry"} type={"() -> None"}>

Clear the import registry.

<PySourceCode >

```python
def clear_import_registry() -> None:
	"""Clear the import registry."""
	_IMPORT_REGISTRY.clear()
```

</PySourceCode>

<PyFunctionReturn type={"None"} />

</PyFunction>

</Tab>

</Tabs>