---
title: "Element"
---

A React element: built-in tag, fragment, or client component.

Tag conventions:
- "" (empty string): Fragment
- "div", "span", etc.: HTML element
- "$$ComponentId": Client component (registered in JS registry)
- Expr (Import, Member, etc.): Direct component reference for transpilation

Props can be either:
- tuple[str, Prop]: key-value pair
- Spread: spread expression (...expr)

## Attributes

<PyAttribute name={"__slots__"} type={"tuple[str, ...]"} value={"('tag', 'props', 'children', 'key')"} />

<PyAttribute name={"tag"} type={"str | Expr"} value={"tag"} />

<PyAttribute name={"props"} type={"Sequence[tuple[str, Prop] | Spread] | dict[str, Any] | None"} value={"props"} />

<PyAttribute name={"children"} type={"Sequence[Node] | None"} value={null} />

<PyAttribute name={"key"} type={"str | Expr | None"} value={"key"} />

## Functions

<PyFunction name={"__init__"} type={"(self, tag, props=None, children=None, key=None) -> None"}>

<PySourceCode >

```python
def __init__(
	self,
	tag: str | Expr,
	props: Sequence[tuple[str, Prop] | Spread] | dict[str, Any] | None = None,
	children: Sequence[Node] | None = None,
	key: str | Expr | None = None,
) -> None:
	self.tag = tag
	self.props = props
	if children is None:
		self.children = None
	else:
		if isinstance(tag, str):
			parent_name = tag[2:] if tag.startswith("$$") else tag
		else:
			tag_out: list[str] = []
			tag.emit(tag_out)
			parent_name = "".join(tag_out)
		self.children = flatten_children(
			children,
			parent_name=parent_name,
			warn_stacklevel=5,
		)
	self.key = key
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"tag"} type={"str | Expr"} value={null} />
<PyParameter name={"props"} type={"Sequence[tuple[str, Prop] | Spread] | dict[str, Any] | None"} value={"None"} />
<PyParameter name={"children"} type={"Sequence[Node] | None"} value={"None"} />
<PyParameter name={"key"} type={"str | Expr | None"} value={"None"} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"_emit_key"} type={"(self, out) -> None"}>

Emit key prop (string or expression).

<PySourceCode >

```python
def _emit_key(self, out: list[str]) -> None:
	"""Emit key prop (string or expression)."""
	if self.key is None:
		return
	if isinstance(self.key, str):
		out.append('key="')
		out.append(_escape_jsx_attr(self.key))
		out.append('"')
	else:
		# Expression key: key={expr}
		out.append("key={")
		self.key.emit(out)
		out.append("}")
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"out"} type={"list[str]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"emit"} type={"(self, out) -> None"}>

<PySourceCode >

```python
@override
def emit(self, out: list[str]) -> None:
	# Fragment (only for string tags)
	if self.tag == "":
		if self.key is not None:
			# Fragment with key needs explicit Fragment component
			out.append("<Fragment ")
			self._emit_key(out)
			out.append(">")
			for c in self.children or []:
				_emit_jsx_child(c, out)
			out.append("</Fragment>")
		else:
			out.append("<>")
			for c in self.children or []:
				_emit_jsx_child(c, out)
			out.append("</>")
		return

	# Resolve tag - either emit Expr or use string (strip $$ prefix)
	tag_out: list[str] = []
	if isinstance(self.tag, Expr):
		self.tag.emit(tag_out)
	else:
		tag_out.append(self.tag[2:] if self.tag.startswith("$$") else self.tag)
	tag_str = "".join(tag_out)

	# Build props into a separate buffer to check if empty
	props_out: list[str] = []
	if self.key is not None:
		self._emit_key(props_out)
	if self.props:
		# Handle both dict (from render path) and sequence (from transpilation)
		# Dict case: items() yields tuple[str, Any], never Spread
		# Sequence case: already list[tuple[str, Prop] | Spread]
		props_iter: Iterable[tuple[str, Any]] | Sequence[tuple[str, Prop] | Spread]
		if isinstance(self.props, dict):
			props_iter = self.props.items()
		else:
			props_iter = self.props
		for prop in props_iter:
			if props_out:
				props_out.append(" ")
			if isinstance(prop, Spread):
				props_out.append("{...")
				prop.expr.emit(props_out)
				props_out.append("}")
			else:
				name, value = prop
				_emit_jsx_prop(name, value, props_out)

	# Build children into a separate buffer to check if empty
	children_out: list[str] = []
	for c in self.children or []:
		_emit_jsx_child(c, children_out)

	# Self-closing if no children
	if not children_out:
		out.append("<")
		out.append(tag_str)
		if props_out:
			out.append(" ")
			out.extend(props_out)
		out.append(" />")
		return

	# Open tag
	out.append("<")
	out.append(tag_str)
	if props_out:
		out.append(" ")
		out.extend(props_out)
	out.append(">")
	# Children
	out.extend(children_out)
	# Close tag
	out.append("</")
	out.append(tag_str)
	out.append(">")
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"out"} type={"list[str]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"transpile_subscript"} type={"(self, key, ctx) -> Expr"}>

Transpile subscript as adding children to this element.

Handles both single children and tuple of children.

<PySourceCode >

```python
@override
def transpile_subscript(self, key: ast.expr, ctx: Transpiler) -> Expr:
	"""Transpile subscript as adding children to this element.

	Handles both single children and tuple of children.
	"""
	if self.children:
		raise TranspileError(
			f"Element '{self.tag}' already has children; cannot add more via subscript"
		)

	# Convert key to list of children
	if isinstance(key, ast.Tuple):
		children = [ctx.emit_expr(e) for e in key.elts]
	else:
		children = [ctx.emit_expr(key)]

	return Element(
		tag=self.tag,
		props=self.props,
		children=children,
		key=self.key,
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"key"} type={"ast.expr"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>

<PyFunction name={"__getitem__"} type={"(self, key) -> Element"}>

Return new Element with children set via subscript.

Raises if this element already has children.
Accepts a single child or a Sequence of children.

<PySourceCode >

```python
@override
def __getitem__(self, key: Any) -> Element:  # pyright: ignore[reportIncompatibleMethodOverride]
	"""Return new Element with children set via subscript.

	Raises if this element already has children.
	Accepts a single child or a Sequence of children.
	"""
	if self.children:
		raise ValueError(
			f"Element '{self.tag}' already has children; cannot add more via subscript"
		)

	# Convert key to sequence of children
	if isinstance(key, (list, tuple)):
		children = list(cast(list[Any] | tuple[Any, ...], key))
	else:
		children = [key]

	return Element(
		tag=self.tag,
		props=self.props,
		children=children,
		key=self.key,
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"key"} type={"Any"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Element"} />

</PyFunction>

<PyFunction name={"with_children"} type={"(self, children) -> Element"}>

Return new Element with children set.

Raises if this element already has children.

<PySourceCode >

```python
def with_children(self, children: Sequence[Node]) -> Element:
	"""Return new Element with children set.

	Raises if this element already has children.
	"""
	if self.children:
		raise ValueError(
			f"Element '{self.tag}' already has children; cannot add more via subscript"
		)
	return Element(
		tag=self.tag,
		props=self.props,
		children=list(children),
		key=self.key,
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"children"} type={"Sequence[Node]"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Element"} />

</PyFunction>

<PyFunction name={"props_dict"} type={"(self) -> dict[str, Any]"}>

Convert props to dict for rendering.

Raises TypeError if props contain Spread (only valid in transpilation).

<PySourceCode >

```python
def props_dict(self) -> dict[str, Any]:
	"""Convert props to dict for rendering.

	Raises TypeError if props contain Spread (only valid in transpilation).
	"""
	if not self.props:
		return {}
	# Already a dict (from renderer reconciliation)
	if isinstance(self.props, dict):
		return self.props
	# Sequence of (key, value) pairs or Spread
	result: dict[str, Any] = {}
	for prop in self.props:
		if isinstance(prop, Spread):
			raise TypeError(
				"Element with spread props cannot be rendered; spread is only valid during transpilation"
			)
		k, v = prop
		result[k] = v
	return result
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"dict[str, typing.Any]"} />

</PyFunction>

<PyFunction name={"render"} type={"(self) -> VDOMNode"}>

Element rendering is handled by Renderer.render_node(), not render().

This method validates render-time constraints and raises TypeError
because Element produces VDOMElement, not VDOMExpr.

<PySourceCode >

```python
@override
def render(self) -> VDOMNode:
	"""Element rendering is handled by Renderer.render_node(), not render().

	This method validates render-time constraints and raises TypeError
	because Element produces VDOMElement, not VDOMExpr.
	"""
	# Validate key is string or numeric (not arbitrary Expr) during rendering
	if self.key is not None and not isinstance(self.key, (str, int)):
		raise TypeError(
			f"Element key must be a string or int for rendering, got {type(self.key).__name__}. "
			+ "Expression keys are only valid during transpilation (emit)."
		)
	raise TypeError(
		"Element cannot be rendered as VDOMExpr; use Renderer.render_node() instead"
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.vdom.VDOMNode"} />

</PyFunction>