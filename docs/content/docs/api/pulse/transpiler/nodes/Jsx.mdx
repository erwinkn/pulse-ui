---
title: "Jsx"
---

JSX wrapper that makes any Expr callable as a component.

When called in transpiled code, produces Element(tag=expr, ...).
This enables patterns like `Jsx(Member(AppShell, "Header"))` to emit
`\<AppShell.Header ... />`.

Example:
        app_shell = Import("AppShell", "@mantine/core")
        Header = Jsx(Member(app_shell, "Header"))
        # In @javascript:
        # Header(height=60) -> \<AppShell_1.Header height=\{60\} />

## Attributes

<PyAttribute name={"expr"} type={"Expr"} value={"expr"} />

<PyAttribute name={"id"} type={"str"} value={"next_id()"} />

## Functions

<PyFunction name={"__init__"} type={"(self, expr) -> None"}>

<PySourceCode >

```python
def __init__(self, expr: Expr) -> None:
	from pulse.transpiler.id import next_id

	self.expr = expr
	self.id = next_id()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"expr"} type={"Expr"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"transpile_call"} type={"(self, args, keywords, ctx) -> Expr"}>

Transpile a call to this JSX wrapper into an Element.

Positional args become children, keyword args become props.
The `key` kwarg is extracted specially. Spread (**expr) is supported.

<PySourceCode >

```python
@override
def transpile_call(
	self,
	args: list[ast.expr],
	keywords: list[ast.keyword],
	ctx: "Transpiler",
) -> Expr:
	"""Transpile a call to this JSX wrapper into an Element.

	Positional args become children, keyword args become props.
	The `key` kwarg is extracted specially. Spread (**expr) is supported.
	"""
	children: list[Node] = [ctx.emit_expr(a) for a in args]

	props: list[tuple[str, Prop] | Spread] = []
	key: str | Expr | None = None
	for kw in keywords:
		if kw.arg is None:
			# **spread syntax
			props.append(spread_dict(ctx.emit_expr(kw.value)))
		else:
			k = kw.arg
			v = ctx.emit_expr(kw.value)
			if k == "key":
				# Accept any expression as key for transpilation
				if isinstance(v, Literal) and isinstance(v.value, str):
					key = v.value  # Optimize string literals
				else:
					key = v  # Keep as expression
			else:
				props.append((k, v))

	return Element(
		tag=self.expr,
		props=props if props else None,
		children=children if children else None,
		key=key,
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"args"} type={"list[ast.expr]"} value={null} />
<PyParameter name={"keywords"} type={"list[ast.keyword]"} value={null} />
<PyParameter name={"ctx"} type={"'Transpiler'"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>

<PyFunction name={"__call__"} type={"(self, *args, **kwargs) -> Element"}>

Allow calling Jsx in Python code.

Supports two usage patterns:
1. Decorator: @Jsx(expr) def Component(...): ...
2. Call: Jsx(expr)(props, children) -> Element

<PySourceCode >

```python
@override
def __call__(self, *args: Any, **kwargs: Any) -> Element:
	"""Allow calling Jsx in Python code.

	Supports two usage patterns:
	1. Decorator: @Jsx(expr) def Component(...): ...
	2. Call: Jsx(expr)(props, children) -> Element
	"""

	# Normal call: build Element
	props: dict[str, Any] = {}
	key: str | None = None
	children: list[Node] = list(args)

	for k, v in kwargs.items():
		if k == "key":
			if not isinstance(v, str):
				raise ValueError("key must be a string")
			key = v
		else:
			props[k] = v

	return Element(
		tag=self.expr,
		props=props if props else None,
		children=children if children else None,
		key=key,
	)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"args"} type={"Any"} value={"()"} />
<PyParameter name={"kwargs"} type={"Any"} value={"{}"} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Element"} />

</PyFunction>