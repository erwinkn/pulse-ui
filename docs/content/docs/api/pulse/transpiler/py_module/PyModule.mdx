---
title: "PyModule"
---

Expr for a Python module imported as a whole (e.g., `import math`).

Subclasses can define transpiler mappings as class attributes:
- Expr attributes are used directly
- Callable attributes are wrapped in Transformer
- Primitives are converted via Expr.of()

The transpiler dict is built automatically via __init_subclass__.

## Attributes

<PyAttribute name={"__slots__"} type={"tuple[str, str]"} value={"('transpiler', 'name')"} />

<PyAttribute name={"transpiler"} type={"dict[str, Expr]"} value={"transpiler if transpiler is not None else {}"} />

<PyAttribute name={"name"} type={"str"} value={"name"} />

## Functions

<PyFunction name={"__init__"} type={"(self, transpiler=None, name='')"}>

<PySourceCode >

```python
def __init__(self, transpiler: dict[str, Expr] | None = None, name: str = ""):
	self.transpiler = transpiler if transpiler is not None else {}
	self.name = name
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"transpiler"} type={"dict[str, Expr] | None"} value={"None"} />
<PyParameter name={"name"} type={"str"} value={"''"} />

</div>

<PyFunctionReturn type={null} />

</PyFunction>

<PyFunction name={"__init_subclass__"} type={"(cls, **kwargs) -> None"}>

<PySourceCode >

```python
def __init_subclass__(cls, **kwargs: Any) -> None:
	super().__init_subclass__(**kwargs)
	cls._transpiler = {}
	for attr_name in dir(cls):
		if attr_name.startswith("_"):
			continue
		attr = getattr(cls, attr_name)
		if isinstance(attr, Expr):
			cls._transpiler[attr_name] = attr
		elif callable(attr):
			cls._transpiler[attr_name] = Transformer(
				cast(Callable[..., Expr], attr), name=attr_name
			)
		elif isinstance(attr, (bool, int, float, str)) or attr is None:
			cls._transpiler[attr_name] = Expr.of(attr)
```

</PySourceCode>

<div >

<PyParameter name={"cls"} type={null} value={null} />
<PyParameter name={"kwargs"} type={"Any"} value={"{}"} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"emit"} type={"(self, out) -> None"}>

<PySourceCode >

```python
@override
def emit(self, out: list[str]) -> None:
	label = self.name or "PyModule"
	raise TypeError(f"{label} cannot be emitted directly")
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"out"} type={"list[str]"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"render"} type={"(self) -> VDOMNode"}>

<PySourceCode >

```python
@override
def render(self) -> VDOMNode:
	label = self.name or "PyModule"
	raise TypeError(f"{label} cannot be rendered directly")
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.vdom.VDOMNode"} />

</PyFunction>

<PyFunction name={"transpile_call"} type={"(self, args, keywords, ctx) -> Expr"}>

<PySourceCode >

```python
@override
def transpile_call(
	self,
	args: list[ast.expr],
	keywords: list[ast.keyword],
	ctx: Transpiler,
) -> Expr:
	label = self.name or "PyModule"
	raise TypeError(f"{label} cannot be called directly")
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"args"} type={"list[ast.expr]"} value={null} />
<PyParameter name={"keywords"} type={"list[ast.keyword]"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>

<PyFunction name={"transpile_getattr"} type={"(self, attr, ctx) -> Expr"}>

<PySourceCode >

```python
@override
def transpile_getattr(self, attr: str, ctx: Transpiler) -> Expr:
	if attr not in self.transpiler:
		label = self.name or "Module"
		raise TypeError(f"{label} has no attribute '{attr}'")
	return self.transpiler[attr]
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"attr"} type={"str"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>

<PyFunction name={"transpile_subscript"} type={"(self, key, ctx) -> Expr"}>

<PySourceCode >

```python
@override
def transpile_subscript(self, key: ast.expr, ctx: Transpiler) -> Expr:
	label = self.name or "PyModule"
	raise TypeError(f"{label} cannot be subscripted")
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"key"} type={"ast.expr"} value={null} />
<PyParameter name={"ctx"} type={"Transpiler"} value={null} />

</div>

<PyFunctionReturn type={"pulse.transpiler.nodes.Expr"} />

</PyFunction>

<PyFunction name={"_build_transpiler"} type={"(items) -> dict[str, Expr]"}>

Build transpiler dict from name/value pairs.

<PySourceCode >

```python
@staticmethod
def _build_transpiler(items: Iterable[tuple[str, Any]]) -> dict[str, Expr]:
	"""Build transpiler dict from name/value pairs."""
	result: dict[str, Expr] = {}
	for attr_name, attr in items:
		if isinstance(attr, Expr):
			result[attr_name] = attr
		elif callable(attr):
			result[attr_name] = Transformer(
				cast(Callable[..., Expr], attr), name=attr_name
			)
		elif isinstance(attr, (bool, int, float, str)) or attr is None:
			result[attr_name] = Expr.of(attr)
	return result
```

</PySourceCode>

<div >

<PyParameter name={"items"} type={"Iterable[tuple[str, Any]]"} value={null} />

</div>

<PyFunctionReturn type={"dict[str, pulse.transpiler.nodes.Expr]"} />

</PyFunction>

<PyFunction name={"register"} type={"(module, transpilation) -> None"}>

Register a Python module for transpilation.

<PySourceCode >

```python
@staticmethod
def register(  # pyright: ignore[reportIncompatibleMethodOverride, reportImplicitOverride]
	module: ModuleType,
	transpilation: type[PyModule]
	| dict[str, Expr | Primitive | Callable[..., Expr]],
) -> None:
	"""Register a Python module for transpilation.

	Args:
		module: The Python module to register (e.g., `math`)
		transpilation: Either a PyModule subclass or a dict mapping attribute names to:
			- Expr: used directly
			- Primitive (bool, int, float, str, None): converted via Expr.of()
			- Callable[..., Expr]: wrapped in Transformer
	"""
	# Get transpiler dict - use pre-built _transpiler for PyModule subclasses
	if isinstance(transpilation, dict):
		transpiler_dict = PyModule._build_transpiler(transpilation.items())
	elif hasattr(transpilation, "_transpiler"):
		transpiler_dict = transpilation._transpiler
	else:
		# Legacy: class namespace without PyModule inheritance
		items = (
			(name, getattr(transpilation, name))
			for name in dir(transpilation)
			if not name.startswith("_")
		)
		transpiler_dict = PyModule._build_transpiler(items)

	# Register individual values for lookup by id
	for attr_name, expr in transpiler_dict.items():
		module_value = getattr(module, attr_name, None)
		if module_value is not None:
			Expr.register(module_value, expr)

	# Register the module object itself
	Expr.register(module, PyModule(transpiler_dict, name=module.__name__))
```

</PySourceCode>

<div >

<PyParameter name={"module"} type={"ModuleType"} value={undefined}>

The Python module to register (e.g., `math`)

</PyParameter>
<PyParameter name={"transpilation"} type={"type[PyModule] | dict[str, Expr | Primitive | Callable[..., Expr]]"} value={undefined}>

Either a PyModule subclass or a dict mapping attribute names to:
- Expr: used directly
- Primitive (bool, int, float, str, None): converted via Expr.of()
- Callable[..., Expr]: wrapped in Transformer

</PyParameter>

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>