---
title: "Deployment"
---

Ready to share your Pulse app with the world? This guide walks you through deploying your application to production.

Pulse apps are Python backends that communicate with React frontends over WebSockets. When deploying, you need to decide how to host these two pieces - together on one server, or separately. We'll cover both approaches and help you choose the right one.

## Which mode should I use?

**If you're just getting started, use single-server mode.** It's simpler to set up, easier to debug, and works great for most applications. You can always switch to subdomains mode later if your needs change.

Here's a quick comparison:

| | Single-server | Subdomains |
|---|---|---|
| **Setup complexity** | Simple | More involved |
| **Best for** | Most apps, getting started | Large-scale apps, separate teams |
| **Scaling** | Scale everything together | Scale API and frontend independently |
| **Infrastructure** | One server/container | Separate API server + CDN |

## Single-server mode (recommended for most apps)

In single-server mode, your Pulse server handles everything: the API, WebSocket connections, and serving the React frontend. This is the default and the easiest way to deploy.

```python
import pulse as ps

app = ps.App(
    routes=[...],
    mode="single-server",  # This is the default, you can omit it
    server_address="https://myapp.example.com",
)
```

Why this mode is simpler:
- **One thing to deploy** - Your Pulse server handles both the API and frontend
- **No CORS headaches** - Everything runs on the same origin, so browsers don't block requests
- **Cookies just work** - Session cookies are automatically configured for same-origin requests

During development, Pulse proxies frontend requests to the React dev server. In production, you build the React app once and serve it statically from the same server.

## Subdomains mode (for scaling independently)

As your app grows, you might want to host the API and frontend separately. For example, you could put your React app on a CDN for fast global delivery while running your API on dedicated servers that can scale based on load.

In subdomains mode, you host them on different subdomains like `api.example.com` and `app.example.com`:

```python
app = ps.App(
    routes=[...],
    mode="subdomains",
    server_address="https://api.example.com",
)
```

This mode requires more configuration because the browser sees these as different origins:
- **CORS must be configured** - The browser needs permission to make cross-origin requests
- **Cookies need domain settings** - Session cookies must be set up to work across subdomains
- **Separate deployments** - You'll deploy the frontend (often to a CDN like Cloudflare or Vercel) and the API server separately

Choose this mode when:
- You have separate teams managing the frontend and backend
- You need to scale the API independently of the frontend
- You want to serve the frontend from a CDN for better global performance

## Server address configuration

The `server_address` tells Pulse where your API will be accessible from the internet. Pulse uses this to:
- Generate the correct WebSocket URL for the React client to connect to
- Set up CORS policies so browsers allow the connection
- Configure cookie domains for session management

You'll typically have different addresses for development and production:

```python
# During development, you're running locally
app = ps.App(
    routes=[...],
    dev_server_address="http://localhost:8000",  # Local dev server
)

# In production, use your actual domain
app = ps.App(
    routes=[...],
    server_address="https://api.myapp.com",  # Your production URL
)
```

If you need to generate the React client code for a specific environment, you can pass the address directly to code generation:

```python
# Generate client code pointing to your production API
app.run_codegen(address="https://api.myapp.com")
```

## Cookie configuration

Pulse uses cookies to manage user sessions. The defaults work well for most apps, so you usually don't need to change anything here.

However, if you're using subdomains mode or have specific security requirements, you can customize the cookie settings:

```python
from pulse import Cookie

app = ps.App(
    routes=[...],
    cookie=Cookie(
        name="pulse_session",        # Cookie name (default is fine for most apps)
        domain=".example.com",       # Leading dot lets the cookie work across subdomains
        secure=True,                 # Only send over HTTPS (always use in production)
        samesite="lax",              # Protects against CSRF attacks
        max_age_seconds=86400 * 30,  # How long until the cookie expires (30 days here)
    ),
)
```

The `domain` setting is particularly important for subdomains mode. Setting it to `.example.com` (with the leading dot) allows the cookie to be shared between `api.example.com` and `app.example.com`.

## CORS configuration

CORS (Cross-Origin Resource Sharing) controls which websites can make requests to your API. Pulse configures this automatically based on your deployment mode, so you usually don't need to touch it.

If you need custom CORS settings (for example, to allow requests from additional domains), you can configure them explicitly:

```python
app = ps.App(
    routes=[...],
    cors={
        "allow_origins": ["https://app.example.com"],  # Which domains can make requests
        "allow_credentials": True,   # Allow cookies to be sent with requests
        "allow_methods": ["*"],      # Which HTTP methods are allowed
        "allow_headers": ["*"],      # Which headers can be sent
    },
)
```

## Running in production

Once your app is configured, you need to run it with a production-grade ASGI server. Uvicorn is a popular choice.

### With Uvicorn

The simplest way to run your app in production:

```bash
uvicorn app:app.asgi --host 0.0.0.0 --port 8000
```

This tells Uvicorn to:
- Load your app from `app.py` and access its `.asgi` attribute
- Listen on all network interfaces (`0.0.0.0`) so it's accessible from outside the container
- Run on port 8000

For more control over initialization (useful for loading configuration or setting up database connections), use the factory pattern:

```python
# app.py
def create_app():
    # You can load config, set up connections, etc. here
    app = ps.App(routes=[...], server_address="https://api.example.com")
    return app.asgi
```

```bash
uvicorn app:create_app --factory --host 0.0.0.0 --port 8000
```

### Environment variables

Pulse reads these environment variables to configure itself:

| Variable | Purpose | Example |
|----------|---------|---------|
| `PULSE_ENV` | Set to `prod` for production mode | `prod` |
| `PULSE_HOST` | Server host to bind to | `0.0.0.0` |
| `PULSE_PORT` | Server port | `8000` |

Setting `PULSE_ENV=prod` enables production optimizations and disables development features like hot reloading.

## AWS deployment

If you're deploying to AWS, the `pulse-aws` package makes it easy to run Pulse on Lambda, ECS, and other AWS services.

For example, to create a Lambda handler:

```python
from pulse_aws import create_lambda_handler

# This wraps your Pulse app in a Lambda-compatible handler
handler = create_lambda_handler(app)
```

See the [Pulse AWS package documentation](/docs/packages/pulse-aws) for detailed guides on deploying to different AWS services.

## See also

- [Package: Pulse AWS](/docs/packages/pulse-aws)
