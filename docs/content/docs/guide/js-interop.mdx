---
title: "JS Interop"
---

Pulse allows you to write Python code that gets transpiled to JavaScript and executed in the browser. This is useful for DOM manipulation, accessing browser APIs, or performing client-side operations that cannot be done from the server.

## The `@javascript` decorator

Mark a Python function with `@ps.javascript` to make it available for client-side execution. The function is transpiled to JavaScript at build time.

```python
import pulse as ps
from pulse.js import document, window

@ps.javascript
def focus_input(selector: str):
    document.querySelector(selector).focus()

@ps.javascript
def scroll_to_top():
    window.scrollTo(0, 0)
```

The transpiler supports a subset of Python syntax including variables, functions, conditionals, loops, list comprehensions, and most common operations.

## Running JavaScript from callbacks

Use `ps.run_js()` inside event handlers to execute your transpiled functions in the browser.

```python
@ps.component
def MyForm():
    with ps.init():
        state = FormState()

    def on_submit():
        state.save()
        ps.run_js(focus_input("#next-field"))  # Fire and forget

    return ps.form(onSubmit=on_submit)[
        # ... form fields
    ]
```

## Getting results from the client

If you need data back from the browser, use `result=True` and await the result.

```python
@ps.javascript
def get_scroll_position():
    return {"x": window.scrollX, "y": window.scrollY}

@ps.javascript
def get_selected_text():
    return window.getSelection().toString()

@ps.component
def ScrollTracker():
    with ps.init():
        state = TrackerState()

    async def on_check_position():
        pos = await ps.run_js(get_scroll_position(), result=True)
        state.update_position(pos["x"], pos["y"])

    async def on_get_selection():
        text = await ps.run_js(get_selected_text(), result=True)
        state.set_selected(text)
```

## Available JavaScript modules

Pulse provides type-safe wrappers for common browser APIs. Import them from `pulse.js`.

```python
from pulse.js import (
    document,    # DOM manipulation
    window,      # Window object
    console,     # Console logging
    navigator,   # Browser info
    Math,        # Math functions
    JSON,        # JSON parsing/stringifying
    Date,        # Date handling
    Error,       # Error creation
    Array,       # Array methods
    Object,      # Object methods
    Set,         # Set constructor
    Map,         # Map constructor
)
```

Example using multiple modules:

```python
from pulse.js import document, console, Math

@ps.javascript
def highlight_random_item(selector: str):
    items = document.querySelectorAll(selector)
    if items.length > 0:
        idx = Math.floor(Math.random() * items.length)
        items[idx].classList.add("highlighted")
        console.log(f"Highlighted item {idx}")
```

## Error handling

JavaScript errors can be caught in Python when awaiting results.

```python
from pulse.render_session import JsExecError
from pulse.js import Error

@ps.javascript
def might_fail():
    raise Error("Something went wrong")

async def on_click():
    try:
        await ps.run_js(might_fail(), result=True)
    except JsExecError as e:
        print(f"JS error: {e}")
```

Note: In transpiled functions, `raise Error(...)` becomes `throw Error(...)` in JavaScript.

## Creating JSX components

For more complex client-side UI, use `@ps.javascript(jsx=True)` to create React components that run entirely in the browser.

```python
from pulse.js import Math
from pulse.js.pulse import usePulseChannel

useState = ps.Import("useState", "react")
useEffect = ps.Import("useEffect", "react")

@ps.javascript(jsx=True)
def ClientCounter(*, initialValue: int = 0):
    count, setCount = useState(initialValue)

    def increment():
        setCount(lambda c: c + 1)

    return ps.div(className="counter")[
        ps.span(f"Count: {count}"),
        ps.button(onClick=increment)["Increment"],
    ]
```

JSX components are useful for:
- High-frequency interactions where server roundtrips would be too slow
- Animations and transitions
- Client-side state that does not need to be synchronized with the server
- Integration with client-side libraries

## Imports and external dependencies

Use `ps.Import` to reference JavaScript modules.

```python
# Import from npm packages
useState = ps.Import("useState", "react")
motion = ps.Import("motion", "framer-motion")

# Import default export
lodash = ps.Import("default", "lodash")

@ps.javascript
def debounced_search(query: str):
    return lodash.debounce(lambda: search(query), 300)
```

## See also

- [Tutorial: JS Interop](/docs/tutorial/14-js-interop)
- [Reference: JS Interop](/docs/reference/pulse/js-interop)
- [Reference: pulse.transpiler](/docs/reference/pulse-transpiler)
