---
title: "Hooks"
description: "Render-time hooks and runtime helpers"
---

## state

Get or create a State instance persisted across renders.

```python
def state(key: str, arg: S | Callable[[], S]) -> S
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `key` | `str` | required | Unique identifier within the component |
| `arg` | `S \| Callable[[], S]` | required | State instance or factory function |

### Returns

The same State instance on subsequent renders with the same key.

### Example

```python
def counter():
    s = ps.state("counter", lambda: CounterState())
    return m.Button(f"Count: {s.count}", on_click=lambda: s.increment())
```

### Notes

- Key must be non-empty string
- Can only be called once per render with the same key
- Factory is only called on first render; subsequent renders return cached instance
- State is disposed when component unmounts

---

## init

Context manager for one-time initialization in components. Variables assigned inside the block persist across re-renders.

```python
def init() -> InitContext
```

### Usage

```python
def my_component():
    with ps.init():
        counter = 0
        api = ApiClient()
        data = fetch_initial_data()

    # counter, api, data retain their values across renders
    return m.Text(f"Counter: {counter}")
```

### Rules

- Can only be used once per component
- **Must be at the top level of the component function** (not inside conditionals, loops, or nested functions)
- Cannot contain control flow (`if`, `for`, `while`, `try`, `with`, `match`)
- Cannot use `as` binding (`with ps.init() as ctx:` not allowed)
- Variables are restored from first render on subsequent renders

### How It Works

`ps.init()` uses **AST rewriting** to transform your code at decoration time. When you use the `@ps.component` decorator, Pulse parses your function's source code and rewrites `with ps.init():` blocks into conditional logic.

On first render, the code inside the block runs normally and variables are captured. On subsequent renders, the block is skipped entirely and variables are restored from storage.

### Equivalent to `ps.setup()`

Under the hood, `ps.init()` is syntactic sugar. This code:

```python
@ps.component
def Counter():
    with ps.init():
        state = CounterState()
        value = expensive_calculation()

    return ps.div(f"Count: {state.count}")
```

Is equivalent to:

```python
@ps.component
def Counter():
    def init():
        return CounterState(), expensive_calculation()

    state, value = ps.setup(init)

    return ps.div(f"Count: {state.count}")
```

### Troubleshooting

If you encounter issues with `ps.init()` (e.g., source code not available in some deployment environments, or unexpected behavior), use `ps.setup()` instead. It provides the same functionality without AST rewriting:

```python
# If ps.init() causes issues, use ps.setup() instead
state = ps.setup(lambda: CounterState())
```

---

## effects

Register effects that persist across renders.

```python
def effects(
    *fns: EffectFn,
    on_error: Callable[[Exception], None] | None = None,
    key: str | None = None,
) -> None
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `*fns` | `EffectFn` | required | Effect functions to register |
| `on_error` | `Callable[[Exception], None] \| None` | `None` | Error handler |
| `key` | `str \| None` | `None` | Optional key; if changed, effects are recreated |

### Example

```python
def user_profile(user_id: str):
    s = ps.state("user", lambda: UserState(user_id))

    ps.effects(
        lambda: print(f"User changed: {s.name}"),
        lambda: subscribe_to_updates(s.user_id),
        key=user_id,  # Recreate effects when user_id changes
    )

    return m.Text(s.name)
```

### Notes

- Can only be called once per component render
- Effects are disposed when component unmounts
- Changing `key` disposes old effects and creates new ones

---

## stable

Return a stable wrapper that always calls the latest value.

```python
@overload
def stable(key: str) -> Any: ...

@overload
def stable(key: str, value: TCallable) -> TCallable: ...

@overload
def stable(key: str, value: T) -> Callable[[], T]: ...
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `key` | `str` | required | Unique identifier |
| `value` | `Any` | optional | Value or callable to wrap |

### Returns

A stable wrapper function that delegates to the current value.

### Example

```python
def my_component():
    s = ps.state("data", lambda: DataState())

    # Without stable, this would create a new function each render
    handle_click = ps.stable("click", lambda: s.increment())

    return m.Button("Click", on_click=handle_click)
```

### Use Cases

- Event handlers passed to child components to prevent unnecessary re-renders
- Callbacks registered with external systems
- Any function reference that needs to stay stable across renders

---

## route

Get the current route context.

```python
def route() -> RouteContext
```

### Returns

`RouteContext` with access to route parameters, path, and query.

### Example

```python
def user_page():
    r = ps.route()
    user_id = r.params.get("user_id")  # From /users/:user_id
    page = r.query.get("page", "1")    # From ?page=2
    return m.Text(f"User {user_id}, Page {page}")
```

---

## navigate

Navigate to a new URL.

```python
def navigate(path: str, *, replace: bool = False, hard: bool = False) -> None
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `path` | `str` | required | Destination URL |
| `replace` | `bool` | `False` | Replace current history entry |
| `hard` | `bool` | `False` | Full page reload instead of client-side navigation |

### Example

```python
async def handle_login():
    await api.login(username, password)
    ps.navigate("/dashboard")
```

---

## redirect

Redirect during render (throws exception to interrupt render).

```python
def redirect(path: str, *, replace: bool = False) -> NoReturn
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `path` | `str` | required | Destination URL |
| `replace` | `bool` | `False` | Replace current history entry |

### Example

```python
def protected_page():
    user = get_current_user()
    if not user:
        ps.redirect("/login")  # Interrupts render

    return m.Text(f"Welcome, {user.name}")
```

---

## not_found

Trigger 404 during render (throws exception to interrupt render).

```python
def not_found() -> NoReturn
```

### Example

```python
def user_page():
    r = ps.route()
    user = get_user(r.params["id"])
    if not user:
        ps.not_found()  # Shows 404 page

    return m.Text(user.name)
```

---

## session

Get the current user session data.

```python
def session() -> ReactiveDict[str, Any]
```

### Returns

`ReactiveDict` of session data that persists across page navigations.

### Example

```python
def my_component():
    sess = ps.session()
    sess["last_visited"] = datetime.now()
    return m.Text(f"Visits: {sess.get('visit_count', 0)}")
```

---

## session_id

Get the current session identifier.

```python
def session_id() -> str
```

---

## websocket_id

Get the current WebSocket connection identifier.

```python
def websocket_id() -> str
```

---

## set_cookie

Set a cookie on the client.

```python
async def set_cookie(
    name: str,
    value: str,
    domain: str | None = None,
    secure: bool = True,
    samesite: Literal["lax", "strict", "none"] = "lax",
    max_age_seconds: int = 7 * 24 * 3600,
) -> None
```

---

## call_api

Make an API call through the client browser.

```python
async def call_api(
    path: str,
    *,
    method: str = "POST",
    headers: Mapping[str, str] | None = None,
    body: Any | None = None,
    credentials: str = "include",
) -> dict[str, Any]
```

Useful for calling third-party APIs that require browser cookies/credentials.

---

## server_address

Get the server's public address.

```python
def server_address() -> str
```

---

## client_address

Get the client's IP address.

```python
def client_address() -> str
```

---

## global_state

Create a globally shared state accessor.

```python
def global_state(
    factory: Callable[P, S] | type[S],
    key: str | None = None,
) -> GlobalStateAccessor[P, S]
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `factory` | `Callable \| type` | required | State class or factory function |
| `key` | `str \| None` | `None` | Optional custom key |

### Returns

`GlobalStateAccessor` - callable that returns the shared state instance.

### Example

```python
@ps.global_state
class AppSettings(ps.State):
    theme: str = "light"
    language: str = "en"

def settings_panel():
    settings = AppSettings()  # Same instance across all components
    return m.Select(
        value=settings.theme,
        data=["light", "dark"],
        on_change=lambda v: setattr(settings, "theme", v),
    )

# With instance ID for per-entity global state
@ps.global_state
class UserCache(ps.State):
    data: dict = {}

def user_profile(user_id: str):
    cache = UserCache(id=user_id)  # Shared per user_id
    return m.Text(cache.data.get("name", "Loading..."))
```

---

## hooks API

Low-level API for creating custom hooks.

### hooks.create

Register a new hook.

```python
def create(
    name: str,
    factory: HookFactory[T] = _default_factory,
    *,
    metadata: HookMetadata | None = None,
) -> Hook[T]
```

### HookState

Base class for hook state. Override lifecycle methods:

```python
class HookState(Disposable):
    def on_render_start(self, render_cycle: int) -> None: ...
    def on_render_end(self, render_cycle: int) -> None: ...
    def dispose(self) -> None: ...
```

### HookMetadata

```python
@dataclass
class HookMetadata:
    description: str | None = None
    owner: str | None = None
    version: str | None = None
    extra: Mapping[str, Any] | None = None
```

### Example Custom Hook

```python
class TimerHookState(ps.hooks.State):
    def __init__(self):
        self.start_time = time.time()

    def elapsed(self) -> float:
        return time.time() - self.start_time

    def dispose(self) -> None:
        pass

_timer_hook = ps.hooks.create("my_app:timer", lambda: TimerHookState())

def use_timer() -> TimerHookState:
    return _timer_hook()
```
