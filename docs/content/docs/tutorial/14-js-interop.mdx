---
title: "JS Interop"
---

Pulse lets you build web apps entirely in Python, but sometimes you need to reach into JavaScript. Maybe you want to focus an input field, scroll to an element, use a browser API, or integrate a JavaScript library that doesn't have a Pulse wrapper. JavaScript interop makes all of this possible.

## Running JavaScript from Python

The most direct way to run JavaScript is with `ps.run_js()`. You write the JavaScript code as a string, and Pulse executes it in the browser.

```python
class ScrollState(ps.State):
    async def scroll_to_top(self):
        await ps.run_js("window.scrollTo({ top: 0, behavior: 'smooth' })")

    async def focus_email(self):
        await ps.run_js("document.querySelector('#email').focus()")
```

For more complex operations, you can get a return value:

```python
async def get_window_size(self):
    size = await ps.run_js(
        "({ width: window.innerWidth, height: window.innerHeight })",
        result=True
    )
    print(f"Window is {size['width']}x{size['height']}")
```

## The @ps.javascript Decorator

Writing JavaScript as strings works, but it's error-prone and doesn't give you any editor support. Pulse offers a better way: write Python functions that get transpiled to JavaScript.

```python
@ps.javascript
def focus_element(selector: str):
    document.querySelector(selector).focus()


@ps.javascript
def scroll_to_element(element_id: str):
    el = document.getElementById(element_id)
    if el:
        el.scrollIntoView({"behavior": "smooth"})


class FormState(ps.State):
    async def on_error(self):
        # Focus the email field when there's an error
        await ps.run_js(focus_element("#email"))

    async def go_to_section(self, section_id: str):
        await ps.run_js(scroll_to_element(section_id))
```

The `@ps.javascript` decorator marks a function for transpilation. When you call `ps.run_js(focus_element("#email"))`, Pulse:
1. Transpiles the Python function to JavaScript
2. Calls it with the provided arguments
3. Executes it in the browser

This approach gives you:
- **Syntax highlighting and editor support** in your Python code
- **Type checking** for your parameters
- **Reusable JavaScript functions** you can call from multiple places

## What You Can Do in @ps.javascript Functions

The transpiler supports a subset of Python that maps cleanly to JavaScript:
- Variables and assignments
- Conditionals (`if`/`else`)
- Loops (`for`, `while`)
- Function calls
- Object and array access
- Basic operators

You can access browser globals like `document`, `window`, `console`, `localStorage`, etc.

```python
@ps.javascript
def save_to_storage(key: str, value: str):
    localStorage.setItem(key, value)


@ps.javascript
def log_and_alert(message: str):
    console.log(message)
    window.alert(message)


@ps.javascript
def get_cookies():
    return document.cookie
```

## Wrapping React Components

One of the most powerful uses of JS interop is wrapping existing React components. If there's a React component library you want to use that doesn't have a Pulse package, you can wrap it yourself.

```python
from pulse import react_component, Import

# Import a component from a npm package
DatePicker = react_component(
    Import("DatePicker", from_="react-datepicker")
)

# Now use it like any other Pulse component
@ps.component
def booking_form():
    with ps.init():
        selected_date = None

    return ps.div(
        ps.label("Select a date:"),
        DatePicker(
            selected=selected_date,
            onChange=lambda date: print(f"Selected: {date}"),
        ),
    )
```

The `Import` specifies where to find the component:
- Named import: `Import("DatePicker", from_="react-datepicker")`
- Default import: `Import(default="Calendar", from_="react-calendar")`

## Handling Complex Interop

Sometimes you need more control. Here are some patterns for complex scenarios:

### Getting Results from JavaScript

```python
@ps.javascript
def get_selection():
    selection = window.getSelection()
    if selection:
        return selection.toString()
    return ""


class EditorState(ps.State):
    async def copy_selection(self):
        text = await ps.run_js(get_selection(), result=True)
        if text:
            # Do something with the selected text
            print(f"User selected: {text}")
```

### Calling External Libraries

If you've added a JavaScript library to your project, you can call it:

```python
@ps.javascript
def init_chart(container_id: str, data: list):
    # Assuming Chart.js is loaded
    ctx = document.getElementById(container_id).getContext("2d")
    Chart(ctx, {
        "type": "bar",
        "data": {
            "labels": data.map(lambda d: d["label"]),
            "datasets": [{
                "data": data.map(lambda d: d["value"]),
            }]
        }
    })
```

### Browser APIs

```python
@ps.javascript
def request_notification_permission():
    if "Notification" in window:
        Notification.requestPermission()


@ps.javascript
def copy_to_clipboard(text: str):
    navigator.clipboard.writeText(text)


@ps.javascript
def get_geolocation():
    return Promise(lambda resolve, reject:
        navigator.geolocation.getCurrentPosition(
            lambda pos: resolve({"lat": pos.coords.latitude, "lng": pos.coords.longitude}),
            lambda err: reject(err)
        )
    )
```

## When to Use JS Interop

Use JS interop when you need to:
- **Access browser APIs** (clipboard, notifications, geolocation)
- **Manipulate the DOM directly** (focus, scroll, measure elements)
- **Use JavaScript libraries** without a Pulse wrapper
- **Optimize performance** for client-side-only operations

Prefer staying in Python when you can. Pulse's normal state and rendering system handles most cases, and keeping logic in Python means you get all the benefits of server-side execution (security, consistency, easier debugging).

## Tips

1. **Keep JS functions small and focused**: They should do one thing.

2. **Handle errors**: JavaScript can fail. Use try/catch in complex functions.

3. **Remember it's async**: `ps.run_js()` is always async because it communicates with the browser.

4. **Test your transpiled code**: The transpiler handles common patterns, but complex Python might not translate as expected.

5. **Check the generated code**: If something isn't working, look at what JavaScript is actually being generated.

## See also

- [Core Guide: JS Interop](/docs/guide/js-interop)
- [Reference: JS Interop](/docs/reference/pulse/js-interop)
- [Reference: pulse.transpiler](/docs/reference/pulse-transpiler)
