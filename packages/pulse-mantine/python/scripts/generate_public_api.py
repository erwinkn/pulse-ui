from __future__ import annotations

import ast
import subprocess
from collections import defaultdict
from pathlib import Path

SCRIPT_DIR = Path(__file__).resolve().parent
PACKAGE_DIR = SCRIPT_DIR.parent / "src" / "pulse_mantine"
RUNTIME_INIT = PACKAGE_DIR / "__init__.py"
STUB_INIT = PACKAGE_DIR / "__init__.pyi"

SKIP_FILES = {"__init__.py", "__init__.pyi"}


def dotted_name(node: ast.AST) -> str | None:
	if isinstance(node, ast.Name):
		return node.id
	if isinstance(node, ast.Attribute):
		base = dotted_name(node.value)
		if base is None:
			return None
		return f"{base}.{node.attr}"
	return None


def is_typevar_call(node: ast.AST) -> bool:
	if not isinstance(node, ast.Call):
		return False
	target = dotted_name(node.func)
	return target in {"TypeVar", "typing.TypeVar"}


def module_name(path: Path) -> str:
	return ".".join(path.relative_to(PACKAGE_DIR.parent).with_suffix("").parts)


def collect_exports() -> tuple[dict[str, str], dict[str, list[str]]]:
	exports: dict[str, str] = {}
	module_exports: defaultdict[str, list[str]] = defaultdict(list)

	for path in sorted(PACKAGE_DIR.rglob("*.py")):
		if path.name in SKIP_FILES:
			continue
		tree = ast.parse(path.read_text())
		module = module_name(path)

		def register(name: str, module: str) -> None:
			if name.startswith("_") or name in {"__all__", "__doc__"}:
				return
			if len(name) == 1 and name.isupper():
				return
			if name in exports and exports[name] != module:
				other = exports[name]
				raise RuntimeError(
					f"Duplicate export detected for {name}: {module} vs {other}"
				)
			exports[name] = module
			module_exports[module].append(name)

		for node in tree.body:
			if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
				if any(
					isinstance(dec, ast.Call)
					and dotted_name(dec.func) == "ps.react_component"
					for dec in node.decorator_list
				):
					register(node.name, module)
			elif isinstance(node, ast.ClassDef):
				register(node.name, module)
			elif isinstance(node, ast.Assign):
				for target in node.targets:
					if isinstance(target, ast.Name):
						if is_typevar_call(node.value):
							continue
						register(target.id, module)
			elif isinstance(node, ast.AnnAssign):
				if isinstance(node.target, ast.Name):
					if node.value and is_typevar_call(node.value):
						continue
					register(node.target.id, module)

	for names in module_exports.values():
		names.sort()

	return exports, module_exports


def render_runtime_init(exports: dict[str, str]) -> str:
	lines = [
		"from __future__ import annotations",
		"",
		"# Auto-generated by scripts/generate_public_api.py. Do not edit manually.",
		"from importlib import import_module",
		"from typing import Any",
		"",
		"_EXPORTS: dict[str, str] = {",
	]

	for name in sorted(exports):
		module = exports[name]
		lines.append(f'    "{name}": "{module}",')
	lines.append("}")
	lines.append("")
	lines.append(
		"__all__ = tuple(sorted(_EXPORTS)) # pyright: ignore[reportUnsupportedDunderAll]"
	)
	lines.append("")
	lines.append("def __getattr__(name: str) -> Any:")
	lines.append("    try:")
	lines.append("        module_name = _EXPORTS[name]")
	lines.append("    except KeyError as exc:")
	lines.append(
		'        raise AttributeError(f"module {__name__} has no attribute {name}") from exc'
	)
	lines.append("    module = import_module(module_name)")
	lines.append("    value = getattr(module, name)")
	lines.append("    globals()[name] = value")
	lines.append("    return value")
	lines.append("")
	lines.append("def __dir__() -> list[str]:")
	lines.append("    return sorted(__all__)")
	lines.append("")
	return "\n".join(lines)


def render_stub_init(
	module_exports: dict[str, list[str]], exports: dict[str, str]
) -> str:
	lines = [
		"# Auto-generated by scripts/generate_public_api.py. Do not edit manually.",
		"from __future__ import annotations",
		"",
	]

	for name in sorted(exports):
		module = exports[name]
		lines.append(f"from {module} import {name} as {name}")

	lines.append("")
	return "\n".join(lines)


def main() -> None:
	exports, module_exports = collect_exports()
	RUNTIME_INIT.write_text(render_runtime_init(exports) + "\n")
	STUB_INIT.write_text(render_stub_init(module_exports, exports) + "\n")
	subprocess.run(
		["ruff", "check", "--fix", str(RUNTIME_INIT), str(STUB_INIT)], check=False
	)
	subprocess.run(["ruff", "format", str(RUNTIME_INIT), str(STUB_INIT)], check=False)


if __name__ == "__main__":
	main()
