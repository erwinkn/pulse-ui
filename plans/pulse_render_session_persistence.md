# RenderSession Drain & Hydrate Enablement

This ExecPlan is a living document. The sections `Progress`, `Surprises & Discoveries`, `Decision Log`, and `Outcomes & Retrospective` must stay up to date as work proceeds.

## Purpose / Big Picture

Pulse currently persists individual `State` classes, but a full browser session still disappears if the hosting worker restarts. By teaching `RenderSession` how to drain and hydrate itself we can pause an active client connection, serialize the entire rendering surface (hooks, render trees, channels, forms, pending work), and later resume it on another process without visible regressions. Success means calling `RenderSession.drain()` to capture a snapshot, storing it (e.g., Redis or disk), then invoking `RenderSession.hydrate(app, snapshot)` to obtain a session that can keep rendering, deliver callbacks, and satisfy client messages exactly where it left off.

## Progress

- [x] (2025-10-24 07:46Z) Drafted the RenderSession persistence plan after auditing render, hook, channel, and form subsystems.
- [ ] Implementation work to add drainage, hydration, schema validation, migrations, and regression tests for RenderSession snapshots remains pending.

## Surprises & Discoveries

None discovered yet; use this section to log unexpected runtime behaviour, API gaps, or design changes uncovered while executing the milestones.

## Decision Log

Adopt a snapshot format that stores structural data as plain Python dictionaries and encodes opaque objects (normalized element trees, hook payloads, callbacks, event handlers) using `cloudpickle` plus Base64 so the snapshot stays JSON-friendly. Each snapshot structure carries a `__version__` field; schema updates must bump the version and provide migration helpers at the RenderSession layer.

Session migration now follows a two-stage lifecycle. At time T we capture a stable baseline snapshot that freezes the tree, hooks, state, and in-flight work. The original worker keeps running long enough to accumulate a backlog of messages, resolved futures, and channel responses produced between T and the moment the client reconnects (time T₂). We then drain that backlog as a second payload and apply it after the baseline hydration so the resumed session observes all events that occurred during the handoff window.

## Outcomes & Retrospective

Pending; this section will summarize validation results, observed performance, and any follow-up work once the feature ships.

## Context and Orientation

`packages/pulse/python/src/pulse/render_session.py` defines `RenderSession`, the long-lived object bound to a client. It tracks identifiers, connection state, buffered `ServerMessage` envelopes, the app-wide `RouteTree`, per-path `RouteMount` records (wrapping `RouteContext`, `RenderTree`, the last element rendered, and the render `Effect`), a `ChannelsManager`, a `FormRegistry`, and per-session `global_states`. None of these structures persist across process restarts today.

Rendering flows through `RenderTree` in `packages/pulse/python/src/pulse/renderer.py`, which caches the normalized element tree, callback registry, render props, and CSS references. Each `ComponentNode` owns a `HookContext` (from `packages/pulse/python/src/pulse/hooks/core.py`), and each context holds `HookNamespace` instances keyed by hook name; namespaces map keys to concrete `HookState` objects yielded by hook factories. Hook states are plain Python objects without serialization hooks, and `HookContext` stores transient bookkeeping such as the current render cycle.

Related subsystems also require persistence. `ChannelsManager` and `Channel` (in `packages/pulse/python/src/pulse/channel.py`) manage open channel ids, per-route scoping, pending request futures, and registered handlers. `FormRegistry` (in `packages/pulse/python/src/pulse/form.py`) stores `FormRegistration` entries so POST submissions can be routed back into component callbacks. The session holds `pending_api` futures for in-flight `call_api` invocations, which cannot resume after a drain and must be failed explicitly on hydrate. `PulseContext` (in `packages/pulse/python/src/pulse/context.py`) provides the ambient `(app, session, render, route)` tuple; hydration must leave this context contract intact so hooks and callbacks keep working.

The `App` class in `packages/pulse/python/src/pulse/app.py` owns the authoritative `RouteTree`, plugin stack, and dictionaries that map render ids to `RenderSession` instances. Hydrating a session must integrate with these registries so lookups, middleware, and plugins continue to operate.

Production deployments need a transport to move baseline snapshots and backlog deltas between workers; this plan standardizes on a `RenderSessionSnapshotStore` abstraction so different environments (local tests, Redis-backed clusters, future message buses) can plug in without touching core session logic.

## Plan of Work

### Milestone 1 – Snapshot foundations

Introduce a persistence helper module (for example `packages/pulse/python/src/pulse/persist/render_session.py`) that declares typed dictionaries for `RenderSessionSnapshot`, `RouteMountSnapshot`, `RenderTreeSnapshot`, `HookContextSnapshot`, and nested records like `HookStateSnapshot` and `ChannelSnapshot`. Each snapshot type includes a `__version__` and uses shared helpers `encode_blob(bytes) -> str` and `decode_blob(str) -> bytes` to Base64-wrap `cloudpickle` payloads. Define a `RenderSessionSnapshotStore` protocol with methods to write the baseline snapshot, append backlog deltas, stream backlog updates to a consumer, acknowledge that a new worker has taken ownership, and clean up once the handoff completes. Ship an in-memory implementation for tests, and describe the production Redis-backed implementation (baseline stored in a hash, backlog streamed via Redis streams or lists with pub/sub notifications) so the team can wire it up during rollout. Add validation utilities that raise descriptive `ValueError`s when required fields or versions are missing. Write unit tests that round-trip empty/minimal snapshots through the store API to prove the helpers behave before wiring them into runtime classes.

### Milestone 2 – HookState drainage and hydration

Extend `HookState` so its persistence API mirrors `State`: add `__version__: int = 1` and an overridable `@classmethod __migrate__(cls, from_version: int, to_version: int, payload: dict[str, Any]) -> dict[str, Any]`. Provide instance methods `drain(self) -> dict[str, Any]` and `hydrate(self, payload: dict[str, Any], *, version: int | None = None) -> None` that default to copying `__dict__` or declared `__slots__`, deep-copy mutable containers, and ensure the result stays `cloudpickle`-friendly. Update `HookNamespace` and `HookContext` to emit and consume `HookContextSnapshot` objects: capture the `render_cycle`, each hook name, per-key entries (mapping the `DEFAULT_HOOK_KEY` sentinel to `None`), the concrete state class path, and drained payload plus the recorded version. Hydration must locate hook definitions via `hooks.registry()`, create fresh state instances through the factory, migrate payloads when `__version__` differs, hydrate them, and register them inside namespaces before returning the restored context. Expose `__getstate__` and `__setstate__` on `HookContext` so standard pickling delegates to these helpers. Add dedicated tests (e.g., `packages/pulse/python/tests/test_hooks_persistence.py`) that define custom hook states, mutate them, drain the context, hydrate into a new context, and confirm renders observe preserved values.

### Milestone 3 – RenderTree drainage and hydration

Teach `RenderTree` to produce a `RenderTreeSnapshot`. Draining captures whether the tree has rendered, serializes the normalized root element (or the original root when absent) via the shared Base64/`cloudpickle` helper, dumps callbacks as `{path: encoded Callback}`, and persists `render_props` and `css_refs` as sorted lists for deterministic diffs. Hydration should restore `self.root`, `self.normalized`, callback and render prop sets, and report whether the owning `RouteMount` was already rendered. Ensure `ComponentNode` and `Node` cooperate with the hook persistence from Milestone 2 so hook contexts rehydrate correctly. Add tests (e.g., `test_render_tree_persistence.py`) that build a component tree with nested hooks, render it, drain the tree, hydrate into a fresh `RenderTree`, and verify re-rendering yields identical VDOM without re-running component factories.

### Milestone 4 – RenderSession drainage and hydration

Refactor `RenderSession.mount` so the render `Effect` creation becomes a reusable helper (`_install_render_effect`). Implement `RenderSession.drain(self) -> RenderSessionSnapshot` that captures scalar fields (`id`, connection flags, addresses), serializes `message_buffer`, drains `global_states` via `State.drain`, and records a list of `RouteMountSnapshot` entries. Each mount snapshot stores the normalized path, current `RouteInfo` as a plain dict, the `rendered` flag, the drained `RenderTreeSnapshot`, the serialized current element, and any effect metadata needed to reinstate `_render_effect`. Drain `ChannelsManager` by enumerating open channels, their route bindings, pending request ids, and registered handlers encoded with `cloudpickle`. Drain `FormRegistry` by serializing each `FormRegistration` (ids, route paths, handler references). Note all `pending_api` futures in the snapshot so hydration can fail them deterministically. Define a new server→client reload envelope (for example `ReloadMessage` in `pulse/messages.py`) that instructs the browser to reload the page when persistence recovery fails. Introduce a companion `RenderSessionBacklogSnapshot` that captures events produced after the baseline snapshot: buffered messages emitted while the old worker was draining, channel responses, and any futures that completed. Wire the draining worker to the `RenderSessionSnapshotStore` so baseline payloads and backlog deltas are persisted and notifications are fired as new events arrive until ownership transfers.

Add `@classmethod RenderSession.hydrate(cls, app: App, snapshot: RenderSessionSnapshot, backlog: RenderSessionBacklogSnapshot | None = None, store: RenderSessionSnapshotStore | None = None) -> RenderSession`. Hydration instantiates a new session, reapplies addresses, restores `message_buffer`, rehydrates `global_states` via `State.hydrate`, and rebuilds each `RouteMount` without re-running component renderers yet. Reattach the drained `RenderTree`, set `rendered`, install the effect, and then perform a fresh render pass under the reinstated context; collect any resulting VDOM operations and queue them so they would be sent to the client on reconnect. Apply backlog events after the rerender by replaying data from the store (or the provided backlog snapshot): enqueue buffered messages, finalize any channel or API futures with their recorded results, and ensure ordering matches production semantics. Reconstruct channels and forms, re-register handlers, and rebuild `_channels_by_route`. After hydration, immediately resolve any remaining pending API call or channel request with a `RuntimeError("Render session resumed after persistence")` so callers unblock cleanly. If hydration, backlog application, or the rerender raises, discard the partially restored session, emit the new reload message to the client so it performs a full page refresh, and surface diagnostics via logging. Validate snapshot contents: unknown routes, hooks, or version mismatches should raise descriptive errors. Provide forward migration hooks keyed off `__version__`.

### Milestone 5 – App integration, testing, and documentation

Expose an app-level entry point `App.hydrate_render_session(snapshot: RenderSessionSnapshot, backlog: RenderSessionBacklogSnapshot | None = None, store: RenderSessionSnapshotStore | None = None) -> RenderSession` that calls the class method above, inserts the session into `app.render_sessions`, and updates `_user_to_render`, `_render_to_user`, and `_socket_to_render` maps. Add an optional helper that drains all live sessions during graceful shutdown and returns both the baseline snapshot and any backlog captured during the handoff window, persisting them through the store interface. Expand `packages/pulse/python/tests/test_render_session.py` with integration coverage: create a session, mount routes, mutate state, open channels and forms, drain into a snapshot, record backlog data through the in-memory store, hydrate into a new session, confirm callbacks and hook state continue working, and assert the rerender pass plus backlog application yields the expected queued VDOM operations. Add regression tests ensuring pending API calls are rejected after hydration, hydrating snapshots with unknown routes or hooks yields the documented errors, and simulated hydration or backlog failures cause the reload message to be enqueued. Update developer docs (README snippets, the state persistence plan, etc.) to describe how to trigger session draining, manage snapshot storage via the store interface, handle backlog snapshots, process the reload message, and understand versioning semantics. Document the Redis-backed production path (baseline stored under a session key, backlog streamed via Redis streams or pub/sub) so operators know how to deploy it.

## Acceptance Validation

Run the new targeted suites (`uv run pytest packages/pulse/python/tests/test_hooks_persistence.py`, `uv run pytest packages/pulse/python/tests/test_render_tree_persistence.py`, and extended `test_render_session.py`) to prove hooks, render trees, and sessions round-trip correctly; each should fail before its milestone work and pass after. The RenderSession suite must assert that hydration triggers a rerender, replays backlog entries delivered by the store in order, captures emitted VDOM operations, and enqueues the reload message when hydration, backlog application, or rerender raises. Include store-level tests that exercise the in-memory implementation’s append/stream/ack flows. Execute `uv run pytest` for the whole Python suite, `bun test` for the JS client harness, and finish with `make all` to mirror CI coverage.

## Risks & Open Questions

Hook factories that capture non-serializable resources (open sockets, event loops) may still fail drainage; identify such cases during testing and document how to override the default `drain`/`hydrate` pair. Pending API calls and channel requests cannot resume after a drain, so confirm that returning explicit errors does not break client retry logic—add regression tests to guard this. Monitor snapshot sizes for large renders; if Base64-encoded `cloudpickle` payloads grow too large, we may need streaming storage or per-route chunking. The snapshot store introduces operational risk: Redis outages or missed pub/sub notifications must fail fast and trigger the reload path—capture those failure modes in documentation and consider metrics/alerts.

Initial version authored on 2025-10-24 to outline end-to-end RenderSession persistence after completing State draining and hydration.
