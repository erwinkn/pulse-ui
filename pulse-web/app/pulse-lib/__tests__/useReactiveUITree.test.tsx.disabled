import { describe, it, expect } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useReactiveUITree } from '../useReactiveUITree';
import type { UIElementNode, UITextNode, UIUpdatePayload } from '../types';

const createElementNode = (tag: string, props = {}, children: any[] = []): UIElementNode => ({
  id: Math.random().toString(36),
  type: 'element',
  tag,
  props,
  children,
});

const createTextNode = (content: string): UITextNode => ({
  id: Math.random().toString(36),
  type: 'text',
  content,
});

describe('useReactiveUITree', () => {
  it('should initialize with initial tree', () => {
    const initialTree = createElementNode('div', {}, [createTextNode('Initial')]);
    const { result } = renderHook(() => useReactiveUITree({ initialTree }));
    
    expect(result.current.tree).toEqual(initialTree);
  });

  it('should apply single update', () => {
    const initialTree = createElementNode('div', { className: 'old' }, []);
    const { result } = renderHook(() => useReactiveUITree({ initialTree }));
    
    const update: UIUpdatePayload = {
      id: 'test-update',
      type: 'update_props',
      path: [],
      data: { props: { className: 'new' } }
    };

    act(() => {
      result.current.applyUpdate(update);
    });

    expect((result.current.tree as UIElementNode).props.className).toBe('new');
  });

  it('should apply batch updates', () => {
    const initialTree = createElementNode('div', {}, []);
    const { result } = renderHook(() => useReactiveUITree({ initialTree }));
    
    const updates: UIUpdatePayload[] = [
      {
        id: 'update-1',
        type: 'update_props',
        path: [],
        data: { props: { className: 'updated' } }
      },
      {
        id: 'update-2',
        type: 'insert',
        path: [],
        data: { node: createTextNode('Added text'), index: 0 }
      }
    ];

    act(() => {
      result.current.applyBatchUpdates(updates);
    });

    const updatedTree = result.current.tree as UIElementNode;
    expect(updatedTree.props.className).toBe('updated');
    expect(updatedTree.children).toHaveLength(1);
    expect((updatedTree.children[0] as UITextNode).content).toBe('Added text');
  });

  it('should set new tree', () => {
    const initialTree = createElementNode('div', {}, []);
    const newTree = createElementNode('span', {}, [createTextNode('New tree')]);
    const { result } = renderHook(() => useReactiveUITree({ initialTree }));
    
    act(() => {
      result.current.setTree(newTree);
    });

    expect(result.current.tree).toEqual(newTree);
    expect((result.current.tree as UIElementNode).tag).toBe('span');
  });

  it('should maintain stable references for callbacks', () => {
    const initialTree = createElementNode('div', {}, []);
    const { result, rerender } = renderHook(() => useReactiveUITree({ initialTree }));
    
    const initialCallbacks = {
      applyUpdate: result.current.applyUpdate,
      applyBatchUpdates: result.current.applyBatchUpdates,
      setTree: result.current.setTree,
    };

    rerender();

    expect(result.current.applyUpdate).toBe(initialCallbacks.applyUpdate);
    expect(result.current.applyBatchUpdates).toBe(initialCallbacks.applyBatchUpdates);
    expect(result.current.setTree).toBe(initialCallbacks.setTree);
  });

  it('should handle complex update sequences', () => {
    const initialTree = createElementNode('div', {}, [
      createTextNode('Original text')
    ]);
    const { result } = renderHook(() => useReactiveUITree({ initialTree }));
    
    // Replace text content
    act(() => {
      result.current.applyUpdate({
        id: 'update-1',
        type: 'update_text',
        path: [0],
        data: { content: 'Updated text' }
      });
    });

    expect(((result.current.tree as UIElementNode).children[0] as UITextNode).content)
      .toBe('Updated text');

    // Insert new element
    act(() => {
      result.current.applyUpdate({
        id: 'update-2',
        type: 'insert',
        path: [],
        data: { 
          node: createElementNode('span', { className: 'new-span' }, [createTextNode('Span text')]), 
          index: 1 
        }
      });
    });

    const updatedTree = result.current.tree as UIElementNode;
    expect(updatedTree.children).toHaveLength(2);
    expect((updatedTree.children[1] as UIElementNode).tag).toBe('span');
    expect((updatedTree.children[1] as UIElementNode).props.className).toBe('new-span');

    // Remove first element
    act(() => {
      result.current.applyUpdate({
        id: 'update-3',
        type: 'remove',
        path: [],
        data: { index: 0 }
      });
    });

    const finalTree = result.current.tree as UIElementNode;
    expect(finalTree.children).toHaveLength(1);
    expect((finalTree.children[0] as UIElementNode).tag).toBe('span');
  });
});