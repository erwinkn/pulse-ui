import { describe, it, expect } from "vitest";
import { render, screen } from "@testing-library/react";
import { UIRenderer } from "../UIRenderer";
import type { UIElementNode, UITextNode, UIFragmentNode } from "../types";

const createElementNode = (
  tag: string,
  props = {},
  children: any[] = []
): UIElementNode => ({
  id: Math.random().toString(36),
  type: "element",
  tag,
  props,
  children,
});

const createTextNode = (content: string): UITextNode => ({
  id: Math.random().toString(36),
  type: "text",
  content,
});

const createFragmentNode = (children: any[]): UIFragmentNode => ({
  id: Math.random().toString(36),
  type: "fragment",
  children,
});

describe("UIRenderer", () => {
  it("should render text nodes", () => {
    const textNode = createTextNode("Hello World");
    render(<UIRenderer node={textNode} />);
    expect(screen.getByText("Hello World")).toBeInTheDocument();
  });

  it("should render element nodes with props", () => {
    const elementNode = createElementNode(
      "div",
      {
        className: "test-class",
        "data-testid": "test-div",
      },
      [createTextNode("Content")]
    );

    render(<UIRenderer node={elementNode} />);
    const element = screen.getByTestId("test-div");
    expect(element).toBeInTheDocument();
    expect(element).toHaveClass("test-class");
    expect(element).toHaveTextContent("Content");
  });

  it("should render nested elements", () => {
    const nestedNode = createElementNode("div", { "data-testid": "outer" }, [
      createElementNode("span", { "data-testid": "inner" }, [
        createTextNode("Nested content"),
      ]),
    ]);

    render(<UIRenderer node={nestedNode} />);
    expect(screen.getByTestId("outer")).toBeInTheDocument();
    expect(screen.getByTestId("inner")).toBeInTheDocument();
    expect(screen.getByText("Nested content")).toBeInTheDocument();
  });

  it("should render fragment nodes", () => {
    const fragmentNode = createFragmentNode([
      createTextNode("First"),
      createTextNode("Second"),
    ]);

    render(<UIRenderer node={fragmentNode} />);
    // The two text nodes get concatenated
    expect(screen.getByText("FirstSecond")).toBeInTheDocument();
  });

  it("should render complex tree structure", () => {
    const complexTree = createElementNode("div", { "data-testid": "root" }, [
      createElementNode("h1", {}, [createTextNode("Title")]),
      createFragmentNode([
        createElementNode("p", {}, [createTextNode("Paragraph 1")]),
        createElementNode("p", {}, [createTextNode("Paragraph 2")]),
      ]),
      createElementNode("button", { type: "button" }, [
        createTextNode("Click me"),
      ]),
    ]);

    render(<UIRenderer node={complexTree} />);
    expect(screen.getByTestId("root")).toBeInTheDocument();
    expect(screen.getByText("Title")).toBeInTheDocument();
    expect(screen.getByText("Paragraph 1")).toBeInTheDocument();
    expect(screen.getByText("Paragraph 2")).toBeInTheDocument();
    expect(screen.getByText("Click me")).toBeInTheDocument();
  });

  it("should handle empty children arrays", () => {
    const emptyElement = createElementNode(
      "div",
      { "data-testid": "empty" },
      []
    );
    render(<UIRenderer node={emptyElement} />);
    const element = screen.getByTestId("empty");
    expect(element).toBeInTheDocument();
    expect(element).toBeEmptyDOMElement();
  });

  it("should use keys for React reconciliation", () => {
    const nodeWithKey = createElementNode(
      "div",
      { "data-testid": "keyed" },
      []
    );
    nodeWithKey.key = "unique-key";

    render(<UIRenderer node={nodeWithKey} />);
    expect(screen.getByTestId("keyed")).toBeInTheDocument();
  });
});
